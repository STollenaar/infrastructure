{
  "version": 4,
  "terraform_version": "1.6.1",
  "serial": 1,
  "lineage": "ee0f2f56-7dfa-fee7-6f3d-abe40379e6e7",
  "outputs": {},
  "resources": [
    {
      "module": "module.vault",
      "mode": "data",
      "type": "aws_iam_policy_document",
      "name": "hashicorp_vault_document",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "1820892879",
            "json": "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"VaultUserMgmt\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iam:RemoveUserFromGroup\",\n        \"iam:PutUserPolicy\",\n        \"iam:ListUserPolicies\",\n        \"iam:ListGroupsForUser\",\n        \"iam:ListAttachedUserPolicies\",\n        \"iam:ListAccessKeys\",\n        \"iam:DetachUserPolicy\",\n        \"iam:DeleteUserPolicy\",\n        \"iam:DeleteUser\",\n        \"iam:DeleteAccessKey\",\n        \"iam:CreateUser\",\n        \"iam:CreateAccessKey\",\n        \"iam:AttachUserPolicy\"\n      ],\n      \"Resource\": \"arn:aws:iam::405934267152:user/vault-*\"\n    },\n    {\n      \"Sid\": \"VaultRoleAssume\",\n      \"Effect\": \"Allow\",\n      \"Action\": \"sts:AssumeRole\",\n      \"Resource\": \"arn:aws:iam::405934267152:role/*\"\n    }\n  ]\n}",
            "override_json": null,
            "override_policy_documents": null,
            "policy_id": null,
            "source_json": null,
            "source_policy_documents": null,
            "statement": [
              {
                "actions": [
                  "iam:AttachUserPolicy",
                  "iam:CreateAccessKey",
                  "iam:CreateUser",
                  "iam:DeleteAccessKey",
                  "iam:DeleteUser",
                  "iam:DeleteUserPolicy",
                  "iam:DetachUserPolicy",
                  "iam:ListAccessKeys",
                  "iam:ListAttachedUserPolicies",
                  "iam:ListGroupsForUser",
                  "iam:ListUserPolicies",
                  "iam:PutUserPolicy",
                  "iam:RemoveUserFromGroup"
                ],
                "condition": [],
                "effect": "Allow",
                "not_actions": [],
                "not_principals": [],
                "not_resources": [],
                "principals": [],
                "resources": [
                  "arn:aws:iam::405934267152:user/vault-*"
                ],
                "sid": "VaultUserMgmt"
              },
              {
                "actions": [
                  "sts:AssumeRole"
                ],
                "condition": [],
                "effect": "Allow",
                "not_actions": [],
                "not_principals": [],
                "not_resources": [],
                "principals": [],
                "resources": [
                  "arn:aws:iam::405934267152:role/*"
                ],
                "sid": "VaultRoleAssume"
              }
            ],
            "version": "2012-10-17"
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "data",
      "type": "aws_iam_policy_document",
      "name": "vault_ecr_assume_role",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "1039140840",
            "json": "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"\",\n      \"Effect\": \"Allow\",\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::405934267152:user/vault\"\n      }\n    }\n  ]\n}",
            "override_json": null,
            "override_policy_documents": null,
            "policy_id": null,
            "source_json": null,
            "source_policy_documents": null,
            "statement": [
              {
                "actions": [
                  "sts:AssumeRole"
                ],
                "condition": [],
                "effect": "Allow",
                "not_actions": [],
                "not_principals": [],
                "not_resources": [],
                "principals": [
                  {
                    "identifiers": [
                      "arn:aws:iam::405934267152:user/vault"
                    ],
                    "type": "AWS"
                  }
                ],
                "resources": [],
                "sid": ""
              }
            ],
            "version": "2012-10-17"
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "data",
      "type": "aws_iam_policy_document",
      "name": "vault_ecr_role_policy",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "574068091",
            "json": "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:ListImages\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:DescribeRepositories\",\n        \"ecr:DescribeImages\",\n        \"ecr:BatchGetImage\"\n      ],\n      \"Resource\": \"arn:aws:ecr:*:405934267152:repository/*\"\n    },\n    {\n      \"Sid\": \"\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:GetAuthorizationToken\",\n        \"ecr:DescribeRegistry\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}",
            "override_json": null,
            "override_policy_documents": null,
            "policy_id": null,
            "source_json": null,
            "source_policy_documents": null,
            "statement": [
              {
                "actions": [
                  "ecr:BatchGetImage",
                  "ecr:DescribeImages",
                  "ecr:DescribeRepositories",
                  "ecr:GetDownloadUrlForLayer",
                  "ecr:ListImages"
                ],
                "condition": [],
                "effect": "Allow",
                "not_actions": [],
                "not_principals": [],
                "not_resources": [],
                "principals": [],
                "resources": [
                  "arn:aws:ecr:*:405934267152:repository/*"
                ],
                "sid": ""
              },
              {
                "actions": [
                  "ecr:DescribeRegistry",
                  "ecr:GetAuthorizationToken"
                ],
                "condition": [],
                "effect": "Allow",
                "not_actions": [],
                "not_principals": [],
                "not_resources": [],
                "principals": [],
                "resources": [
                  "*"
                ],
                "sid": ""
              }
            ],
            "version": "2012-10-17"
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "aws_iam_access_key",
      "name": "vault_user_key",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "create_date": "2023-10-30T10:48:00Z",
            "encrypted_secret": null,
            "encrypted_ses_smtp_password_v4": null,
            "id": "AKIAV5A4RLMIA3BTUMWL",
            "key_fingerprint": null,
            "pgp_key": null,
            "secret": "XGww1FC9zXnwOWMbhJ4dXJjQjtWSh14xJ1fcUaHc",
            "ses_smtp_password_v4": "BP1SLu6rHi8+26xmkmYJW7PRn1QbzOAz9yWJ0PVGjBMr",
            "status": "Active",
            "user": "vault"
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "aws_iam_role",
      "name": "vault_ecr",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:iam::405934267152:role/vault/vault-ecr",
            "assume_role_policy": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"\",\"Effect\":\"Allow\",\"Principal\":{\"AWS\":\"arn:aws:iam::405934267152:user/vault\"},\"Action\":\"sts:AssumeRole\"}]}",
            "create_date": "2023-10-30T18:58:36Z",
            "description": "",
            "force_detach_policies": false,
            "id": "vault-ecr",
            "inline_policy": [
              {
                "name": "vault-ecr",
                "policy": "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:ListImages\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:DescribeRepositories\",\n        \"ecr:DescribeImages\",\n        \"ecr:BatchGetImage\"\n      ],\n      \"Resource\": \"arn:aws:ecr:*:405934267152:repository/*\"\n    },\n    {\n      \"Sid\": \"\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:GetAuthorizationToken\",\n        \"ecr:DescribeRegistry\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}"
              }
            ],
            "managed_policy_arns": [],
            "max_session_duration": 3600,
            "name": "vault-ecr",
            "name_prefix": "",
            "path": "/vault/",
            "permissions_boundary": null,
            "tags": {},
            "tags_all": {},
            "unique_id": "AROAV5A4RLMIKYNEHYPDC"
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "aws_iam_role_policy",
      "name": "vault_ecr_role_policy",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "vault-ecr:vault-ecr",
            "name": "vault-ecr",
            "name_prefix": null,
            "policy": "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:ListImages\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:DescribeRepositories\",\n        \"ecr:DescribeImages\",\n        \"ecr:BatchGetImage\"\n      ],\n      \"Resource\": \"arn:aws:ecr:*:405934267152:repository/*\"\n    },\n    {\n      \"Sid\": \"\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:GetAuthorizationToken\",\n        \"ecr:DescribeRegistry\"\n      ],\n      \"Resource\": \"*\"\n    }\n  ]\n}",
            "role": "vault-ecr"
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "aws_iam_user",
      "name": "vault_user",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "arn": "arn:aws:iam::405934267152:user/vault",
            "force_destroy": false,
            "id": "vault",
            "name": "vault",
            "path": "/",
            "permissions_boundary": null,
            "tags": {},
            "tags_all": {},
            "unique_id": "AIDAV5A4RLMIDSLESKY4E"
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "aws_iam_user_policy",
      "name": "vault_user_policy",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "vault:hashicorp-vault",
            "name": "hashicorp-vault",
            "name_prefix": null,
            "policy": "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"VaultUserMgmt\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iam:RemoveUserFromGroup\",\n        \"iam:PutUserPolicy\",\n        \"iam:ListUserPolicies\",\n        \"iam:ListGroupsForUser\",\n        \"iam:ListAttachedUserPolicies\",\n        \"iam:ListAccessKeys\",\n        \"iam:DetachUserPolicy\",\n        \"iam:DeleteUserPolicy\",\n        \"iam:DeleteUser\",\n        \"iam:DeleteAccessKey\",\n        \"iam:CreateUser\",\n        \"iam:CreateAccessKey\",\n        \"iam:AttachUserPolicy\"\n      ],\n      \"Resource\": \"arn:aws:iam::405934267152:user/vault-*\"\n    },\n    {\n      \"Sid\": \"VaultRoleAssume\",\n      \"Effect\": \"Allow\",\n      \"Action\": \"sts:AssumeRole\",\n      \"Resource\": \"arn:aws:iam::405934267152:role/*\"\n    }\n  ]\n}",
            "user": "vault"
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "hcp_vault_secrets_app",
      "name": "aws",
      "provider": "provider[\"registry.terraform.io/hashicorp/hcp\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "app_name": "aws",
            "description": "aws parameters app",
            "id": "aws",
            "organization_id": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
            "project_id": "903fb074-79fb-4a64-9a67-70d2717666bf"
          },
          "sensitive_attributes": [],
          "dependencies": [
            "data.aws_ssm_parameter.vault_client_id",
            "data.aws_ssm_parameter.vault_client_secret",
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "hcp_vault_secrets_app",
      "name": "proxmox_vault",
      "provider": "provider[\"registry.terraform.io/hashicorp/hcp\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "app_name": "proxmox",
            "description": "Proxmox hosted Vault tokens",
            "id": "proxmox",
            "organization_id": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
            "project_id": "903fb074-79fb-4a64-9a67-70d2717666bf"
          },
          "sensitive_attributes": [],
          "dependencies": [
            "data.aws_ssm_parameter.vault_client_id",
            "data.aws_ssm_parameter.vault_client_secret",
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "hcp_vault_secrets_secret",
      "name": "vault_user_access_key",
      "provider": "provider[\"registry.terraform.io/hashicorp/hcp\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "app_name": "aws",
            "id": "aws",
            "organization_id": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
            "project_id": "903fb074-79fb-4a64-9a67-70d2717666bf",
            "secret_name": "access_key",
            "secret_value": "AKIAV5A4RLMIA3BTUMWL"
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "hcp_vault_secrets_secret",
      "name": "vault_user_secret_access_key",
      "provider": "provider[\"registry.terraform.io/hashicorp/hcp\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "app_name": "aws",
            "id": "aws",
            "organization_id": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
            "project_id": "903fb074-79fb-4a64-9a67-70d2717666bf",
            "secret_name": "secret_access_key",
            "secret_value": "XGww1FC9zXnwOWMbhJ4dXJjQjtWSh14xJ1fcUaHc"
          },
          "sensitive_attributes": [
            [
              {
                "type": "get_attr",
                "value": "secret_value"
              }
            ]
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "helm_release",
      "name": "external_secrets",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "atomic": false,
            "chart": "external-secrets",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "external-secrets",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "v0.9.7",
                "chart": "external-secrets",
                "name": "external-secrets",
                "namespace": "vault",
                "revision": 1,
                "values": "{}",
                "version": "0.9.7"
              }
            ],
            "name": "external-secrets",
            "namespace": "vault",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://charts.external-secrets.io",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_list": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": null,
            "verify": false,
            "version": "0.9.7",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "helm_release",
      "name": "prometheus_operator",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "atomic": false,
            "chart": "kube-prometheus-stack",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "prometheus-operator",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 50,
            "metadata": [
              {
                "app_version": "v0.68.0",
                "chart": "kube-prometheus-stack",
                "name": "prometheus-operator",
                "namespace": "monitoring",
                "revision": 1,
                "values": "{\"additionalPrometheusRulesMap\":{},\"alertmanager\":{\"alertmanagerSpec\":{\"additionalConfig\":{},\"additionalConfigString\":\"\",\"additionalPeers\":[],\"affinity\":{},\"alertmanagerConfigMatcherStrategy\":{},\"alertmanagerConfigNamespaceSelector\":{},\"alertmanagerConfigSelector\":{},\"alertmanagerConfiguration\":{},\"clusterAdvertiseAddress\":false,\"clusterGossipInterval\":\"\",\"clusterPeerTimeout\":\"\",\"clusterPushpullInterval\":\"\",\"configMaps\":[],\"containers\":[],\"externalUrl\":null,\"forceEnableClusterMode\":false,\"image\":{\"registry\":\"quay.io\",\"repository\":\"prometheus/alertmanager\",\"sha\":\"\",\"tag\":\"v0.26.0\"},\"initContainers\":[],\"listenLocal\":false,\"logFormat\":\"logfmt\",\"logLevel\":\"info\",\"minReadySeconds\":0,\"nodeSelector\":{},\"paused\":false,\"podAntiAffinity\":\"\",\"podAntiAffinityTopologyKey\":\"kubernetes.io/hostname\",\"podMetadata\":{},\"portName\":\"http-web\",\"priorityClassName\":\"\",\"replicas\":1,\"resources\":{},\"retention\":\"120h\",\"routePrefix\":\"/\",\"scheme\":\"\",\"secrets\":[],\"securityContext\":{\"fsGroup\":2000,\"runAsGroup\":2000,\"runAsNonRoot\":true,\"runAsUser\":1000,\"seccompProfile\":{\"type\":\"RuntimeDefault\"}},\"storage\":{},\"tlsConfig\":{},\"tolerations\":[],\"topologySpreadConstraints\":[],\"useExistingSecret\":false,\"volumeMounts\":[],\"volumes\":[],\"web\":{}},\"annotations\":{},\"apiVersion\":\"v2\",\"config\":{\"global\":{\"resolve_timeout\":\"5m\"},\"inhibit_rules\":[{\"equal\":[\"namespace\",\"alertname\"],\"source_matchers\":[\"severity = critical\"],\"target_matchers\":[\"severity =~ warning|info\"]},{\"equal\":[\"namespace\",\"alertname\"],\"source_matchers\":[\"severity = warning\"],\"target_matchers\":[\"severity = info\"]},{\"equal\":[\"namespace\"],\"source_matchers\":[\"alertname = InfoInhibitor\"],\"target_matchers\":[\"severity = info\"]}],\"receivers\":[{\"name\":\"null\"}],\"route\":{\"group_by\":[\"namespace\"],\"group_interval\":\"5m\",\"group_wait\":\"30s\",\"receiver\":\"null\",\"repeat_interval\":\"12h\",\"routes\":[{\"matchers\":[\"alertname =~ \\\"InfoInhibitor|Watchdog\\\"\"],\"receiver\":\"null\"}]},\"templates\":[\"/etc/alertmanager/config/*.tmpl\"]},\"enabled\":false,\"extraSecret\":{\"annotations\":{},\"data\":{}},\"ingress\":{\"annotations\":{},\"enabled\":false,\"hosts\":[],\"labels\":{},\"paths\":[],\"tls\":[]},\"ingressPerReplica\":{\"annotations\":{},\"enabled\":false,\"hostDomain\":\"\",\"hostPrefix\":\"\",\"labels\":{},\"paths\":[],\"tlsSecretName\":\"\",\"tlsSecretPerReplica\":{\"enabled\":false,\"prefix\":\"alertmanager\"}},\"podDisruptionBudget\":{\"enabled\":false,\"maxUnavailable\":\"\",\"minAvailable\":1},\"secret\":{\"annotations\":{}},\"service\":{\"additionalPorts\":[],\"annotations\":{},\"clusterIP\":\"\",\"externalIPs\":[],\"externalTrafficPolicy\":\"Cluster\",\"labels\":{},\"loadBalancerIP\":\"\",\"loadBalancerSourceRanges\":[],\"nodePort\":30903,\"port\":9093,\"sessionAffinity\":\"\",\"targetPort\":9093,\"type\":\"ClusterIP\"},\"serviceAccount\":{\"annotations\":{},\"automountServiceAccountToken\":true,\"create\":true,\"name\":\"\"},\"serviceMonitor\":{\"additionalEndpoints\":[],\"additionalLabels\":{},\"bearerTokenFile\":null,\"enableHttp2\":true,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"scheme\":\"\",\"selfMonitor\":true,\"targetLimit\":0,\"tlsConfig\":{}},\"servicePerReplica\":{\"annotations\":{},\"enabled\":false,\"externalTrafficPolicy\":\"Cluster\",\"loadBalancerSourceRanges\":[],\"nodePort\":30904,\"port\":9093,\"targetPort\":9093,\"type\":\"ClusterIP\"},\"stringConfig\":\"\",\"templateFiles\":{},\"tplConfig\":false},\"cleanPrometheusOperatorObjectNames\":false,\"commonLabels\":{},\"coreDns\":{\"enabled\":true,\"service\":{\"port\":9153,\"targetPort\":9153},\"serviceMonitor\":{\"additionalLabels\":{},\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"targetLimit\":0}},\"crds\":{\"enabled\":true},\"defaultRules\":{\"additionalRuleAnnotations\":{},\"additionalRuleGroupAnnotations\":{\"alertmanager\":{},\"configReloaders\":{},\"etcd\":{},\"general\":{},\"k8s\":{},\"kubeApiserverAvailability\":{},\"kubeApiserverBurnrate\":{},\"kubeApiserverHistogram\":{},\"kubeApiserverSlos\":{},\"kubeControllerManager\":{},\"kubePrometheusGeneral\":{},\"kubePrometheusNodeRecording\":{},\"kubeProxy\":{},\"kubeSchedulerAlerting\":{},\"kubeSchedulerRecording\":{},\"kubeStateMetrics\":{},\"kubelet\":{},\"kubernetesApps\":{},\"kubernetesResources\":{},\"kubernetesStorage\":{},\"kubernetesSystem\":{},\"network\":{},\"node\":{},\"nodeExporterAlerting\":{},\"nodeExporterRecording\":{},\"prometheus\":{},\"prometheusOperator\":{}},\"additionalRuleGroupLabels\":{\"alertmanager\":{},\"configReloaders\":{},\"etcd\":{},\"general\":{},\"k8s\":{},\"kubeApiserverAvailability\":{},\"kubeApiserverBurnrate\":{},\"kubeApiserverHistogram\":{},\"kubeApiserverSlos\":{},\"kubeControllerManager\":{},\"kubePrometheusGeneral\":{},\"kubePrometheusNodeRecording\":{},\"kubeProxy\":{},\"kubeSchedulerAlerting\":{},\"kubeSchedulerRecording\":{},\"kubeStateMetrics\":{},\"kubelet\":{},\"kubernetesApps\":{},\"kubernetesResources\":{},\"kubernetesStorage\":{},\"kubernetesSystem\":{},\"network\":{},\"node\":{},\"nodeExporterAlerting\":{},\"nodeExporterRecording\":{},\"prometheus\":{},\"prometheusOperator\":{}},\"additionalRuleLabels\":{},\"annotations\":{},\"appNamespacesTarget\":\".*\",\"create\":false,\"disabled\":{},\"keepFiringFor\":\"\",\"labels\":{},\"rules\":{\"alertmanager\":true,\"configReloaders\":true,\"etcd\":true,\"general\":true,\"k8s\":true,\"kubeApiserverAvailability\":true,\"kubeApiserverBurnrate\":true,\"kubeApiserverHistogram\":true,\"kubeApiserverSlos\":true,\"kubeControllerManager\":true,\"kubePrometheusGeneral\":true,\"kubePrometheusNodeRecording\":true,\"kubeProxy\":true,\"kubeSchedulerAlerting\":true,\"kubeSchedulerRecording\":true,\"kubeStateMetrics\":true,\"kubelet\":true,\"kubernetesApps\":true,\"kubernetesResources\":true,\"kubernetesStorage\":true,\"kubernetesSystem\":true,\"network\":true,\"node\":true,\"nodeExporterAlerting\":true,\"nodeExporterRecording\":true,\"prometheus\":true,\"prometheusOperator\":true,\"windows\":true},\"runbookUrl\":\"https://runbooks.prometheus-operator.dev/runbooks\"},\"extraManifests\":[],\"fullnameOverride\":\"\",\"global\":{\"imagePullSecrets\":[],\"imageRegistry\":\"\",\"rbac\":{\"create\":true,\"createAggregateClusterRoles\":false,\"pspAnnotations\":{},\"pspEnabled\":false}},\"grafana\":{\"additionalDataSources\":[],\"adminPassword\":\"prom-operator\",\"defaultDashboardsEnabled\":true,\"defaultDashboardsTimezone\":\"utc\",\"deleteDatasources\":[],\"enabled\":true,\"extraConfigmapMounts\":[],\"forceDeployDashboards\":false,\"forceDeployDatasources\":false,\"ingress\":{\"annotations\":{},\"enabled\":false,\"hosts\":[],\"labels\":{},\"path\":\"/\",\"tls\":[]},\"namespaceOverride\":\"\",\"rbac\":{\"pspEnabled\":false},\"service\":{\"portName\":\"http-web\"},\"serviceMonitor\":{\"enabled\":true,\"interval\":\"\",\"labels\":{},\"path\":\"/metrics\",\"relabelings\":[],\"scheme\":\"http\",\"scrapeTimeout\":\"30s\",\"tlsConfig\":{}},\"sidecar\":{\"dashboards\":{\"annotations\":{},\"enabled\":true,\"label\":\"grafana_dashboard\",\"labelValue\":\"1\",\"multicluster\":{\"etcd\":{\"enabled\":false},\"global\":{\"enabled\":false}},\"provider\":{\"allowUiUpdates\":false},\"searchNamespace\":\"ALL\"},\"datasources\":{\"alertmanager\":{\"enabled\":true,\"handleGrafanaManagedAlerts\":false,\"implementation\":\"prometheus\",\"uid\":\"alertmanager\"},\"annotations\":{},\"createPrometheusReplicasDatasources\":false,\"defaultDatasourceEnabled\":true,\"enabled\":true,\"exemplarTraceIdDestinations\":{},\"httpMethod\":\"POST\",\"isDefaultDatasource\":true,\"label\":\"grafana_datasource\",\"labelValue\":\"1\",\"uid\":\"prometheus\"}}},\"kube-state-metrics\":{\"namespaceOverride\":\"\",\"prometheus\":{\"monitor\":{\"enabled\":true,\"honorLabels\":true,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"scrapeTimeout\":\"\",\"targetLimit\":0}},\"rbac\":{\"create\":true},\"releaseLabel\":true,\"selfMonitor\":{\"enabled\":false}},\"kubeApiServer\":{\"enabled\":true,\"serviceMonitor\":{\"additionalLabels\":{},\"interval\":\"\",\"jobLabel\":\"component\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[{\"action\":\"drop\",\"regex\":\"apiserver_request_duration_seconds_bucket;(0.15|0.2|0.3|0.35|0.4|0.45|0.6|0.7|0.8|0.9|1.25|1.5|1.75|2|3|3.5|4|4.5|6|7|8|9|15|25|40|50)\",\"sourceLabels\":[\"__name__\",\"le\"]}],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"selector\":{\"matchLabels\":{\"component\":\"apiserver\",\"provider\":\"kubernetes\"}},\"targetLimit\":0},\"tlsConfig\":{\"insecureSkipVerify\":false,\"serverName\":\"kubernetes\"}},\"kubeControllerManager\":{\"enabled\":true,\"endpoints\":[],\"service\":{\"enabled\":true,\"port\":null,\"targetPort\":null},\"serviceMonitor\":{\"additionalLabels\":{},\"enabled\":true,\"https\":null,\"insecureSkipVerify\":null,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"serverName\":null,\"targetLimit\":0}},\"kubeDns\":{\"enabled\":false,\"service\":{\"dnsmasq\":{\"port\":10054,\"targetPort\":10054},\"skydns\":{\"port\":10055,\"targetPort\":10055}},\"serviceMonitor\":{\"additionalLabels\":{},\"dnsmasqMetricRelabelings\":[],\"dnsmasqRelabelings\":[],\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"targetLimit\":0}},\"kubeEtcd\":{\"enabled\":true,\"endpoints\":[],\"service\":{\"enabled\":true,\"port\":2381,\"targetPort\":2381},\"serviceMonitor\":{\"additionalLabels\":{},\"caFile\":\"\",\"certFile\":\"\",\"enabled\":true,\"insecureSkipVerify\":false,\"interval\":\"\",\"keyFile\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"scheme\":\"http\",\"serverName\":\"\",\"targetLimit\":0}},\"kubeProxy\":{\"enabled\":true,\"endpoints\":[],\"service\":{\"enabled\":true,\"port\":10249,\"targetPort\":10249},\"serviceMonitor\":{\"additionalLabels\":{},\"enabled\":true,\"https\":false,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"targetLimit\":0}},\"kubeScheduler\":{\"enabled\":true,\"endpoints\":[],\"service\":{\"enabled\":true,\"port\":null,\"targetPort\":null},\"serviceMonitor\":{\"additionalLabels\":{},\"enabled\":true,\"https\":null,\"insecureSkipVerify\":null,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"serverName\":null,\"targetLimit\":0}},\"kubeStateMetrics\":{\"enabled\":true},\"kubeTargetVersionOverride\":\"\",\"kubeVersionOverride\":\"\",\"kubelet\":{\"enabled\":true,\"namespace\":\"kube-system\",\"serviceMonitor\":{\"additionalLabels\":{},\"attachMetadata\":{\"node\":false},\"cAdvisor\":true,\"cAdvisorMetricRelabelings\":[{\"action\":\"drop\",\"regex\":\"container_cpu_(cfs_throttled_seconds_total|load_average_10s|system_seconds_total|user_seconds_total)\",\"sourceLabels\":[\"__name__\"]},{\"action\":\"drop\",\"regex\":\"container_fs_(io_current|io_time_seconds_total|io_time_weighted_seconds_total|reads_merged_total|sector_reads_total|sector_writes_total|writes_merged_total)\",\"sourceLabels\":[\"__name__\"]},{\"action\":\"drop\",\"regex\":\"container_memory_(mapped_file|swap)\",\"sourceLabels\":[\"__name__\"]},{\"action\":\"drop\",\"regex\":\"container_(file_descriptors|tasks_state|threads_max)\",\"sourceLabels\":[\"__name__\"]},{\"action\":\"drop\",\"regex\":\"container_spec.*\",\"sourceLabels\":[\"__name__\"]},{\"action\":\"drop\",\"regex\":\".+;\",\"sourceLabels\":[\"id\",\"pod\"]}],\"cAdvisorRelabelings\":[{\"action\":\"replace\",\"sourceLabels\":[\"__metrics_path__\"],\"targetLabel\":\"metrics_path\"}],\"honorLabels\":true,\"honorTimestamps\":true,\"https\":true,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"probes\":true,\"probesMetricRelabelings\":[],\"probesRelabelings\":[{\"action\":\"replace\",\"sourceLabels\":[\"__metrics_path__\"],\"targetLabel\":\"metrics_path\"}],\"proxyUrl\":\"\",\"relabelings\":[{\"action\":\"replace\",\"sourceLabels\":[\"__metrics_path__\"],\"targetLabel\":\"metrics_path\"}],\"resource\":false,\"resourcePath\":\"/metrics/resource/v1alpha1\",\"resourceRelabelings\":[{\"action\":\"replace\",\"sourceLabels\":[\"__metrics_path__\"],\"targetLabel\":\"metrics_path\"}],\"sampleLimit\":0,\"targetLimit\":0}},\"kubernetesServiceMonitors\":{\"enabled\":true},\"nameOverride\":\"\",\"namespaceOverride\":\"\",\"nodeExporter\":{\"enabled\":true,\"operatingSystems\":{\"darwin\":{\"enabled\":true},\"linux\":{\"enabled\":true}}},\"prometheus\":{\"additionalPodMonitors\":[],\"additionalRulesForClusterRole\":[],\"additionalServiceMonitors\":[],\"agentMode\":false,\"annotations\":{},\"enabled\":true,\"extraSecret\":{\"annotations\":{},\"data\":{}},\"ingress\":{\"annotations\":{},\"enabled\":false,\"hosts\":[],\"labels\":{},\"paths\":[],\"tls\":[]},\"ingressPerReplica\":{\"annotations\":{},\"enabled\":false,\"hostDomain\":\"\",\"hostPrefix\":\"\",\"labels\":{},\"paths\":[],\"tlsSecretName\":\"\",\"tlsSecretPerReplica\":{\"enabled\":false,\"prefix\":\"prometheus\"}},\"networkPolicy\":{\"enabled\":false,\"flavor\":\"kubernetes\"},\"podDisruptionBudget\":{\"enabled\":false,\"maxUnavailable\":\"\",\"minAvailable\":1},\"podSecurityPolicy\":{\"allowedCapabilities\":[],\"allowedHostPaths\":[],\"volumes\":[]},\"prometheusSpec\":{\"additionalAlertManagerConfigs\":[],\"additionalAlertManagerConfigsSecret\":{},\"additionalAlertRelabelConfigs\":[],\"additionalAlertRelabelConfigsSecret\":{},\"additionalArgs\":[],\"additionalConfig\":{},\"additionalConfigString\":\"\",\"additionalPrometheusSecretsAnnotations\":{},\"additionalRemoteRead\":[],\"additionalRemoteWrite\":[],\"additionalScrapeConfigs\":[{\"job_name\":\"istiod\",\"kubernetes_sd_configs\":[{\"namespaces\":{\"names\":[\"istio-system\"]},\"role\":\"endpoints\"}],\"relabel_configs\":[{\"action\":\"keep\",\"regex\":\"istiod;http-monitoring\",\"source_labels\":[\"__meta_kubernetes_service_name\",\"__meta_kubernetes_endpoint_port_name\"]}],\"scheme\":\"http\"},{\"job_name\":\"envoy-stats\",\"kubernetes_sd_configs\":[{\"role\":\"pod\"}],\"metrics_path\":\"/stats/prometheus\",\"relabel_configs\":[{\"action\":\"keep\",\"regex\":\".*-envoy-prom\",\"source_labels\":[\"__meta_kubernetes_pod_container_port_name\"]},{\"action\":\"drop\",\"regex\":\"Succeeded\",\"source_labels\":[\"__meta_kubernetes_pod_phase\"]}],\"scheme\":\"http\"}],\"additionalScrapeConfigsSecret\":{},\"affinity\":{},\"alertingEndpoints\":[],\"allowOverlappingBlocks\":false,\"apiserverConfig\":{},\"arbitraryFSAccessThroughSMs\":false,\"configMaps\":[],\"containers\":[],\"disableCompaction\":false,\"enableAdminAPI\":false,\"enableFeatures\":[],\"enableRemoteWriteReceiver\":false,\"enforcedLabelLimit\":false,\"enforcedLabelNameLengthLimit\":false,\"enforcedLabelValueLengthLimit\":false,\"enforcedNamespaceLabel\":\"\",\"enforcedSampleLimit\":false,\"enforcedTargetLimit\":false,\"evaluationInterval\":\"\",\"excludedFromEnforcement\":[],\"exemplars\":\"\",\"externalLabels\":{},\"externalUrl\":\"\",\"hostAliases\":[],\"hostNetwork\":false,\"ignoreNamespaceSelectors\":false,\"image\":{\"registry\":\"quay.io\",\"repository\":\"prometheus/prometheus\",\"sha\":\"\",\"tag\":\"v2.47.1\"},\"initContainers\":[],\"listenLocal\":false,\"logFormat\":\"logfmt\",\"logLevel\":\"info\",\"minReadySeconds\":0,\"nodeSelector\":{},\"overrideHonorLabels\":false,\"overrideHonorTimestamps\":false,\"paused\":false,\"podAntiAffinity\":\"\",\"podAntiAffinityTopologyKey\":\"kubernetes.io/hostname\",\"podMetadata\":{},\"podMonitorNamespaceSelector\":{},\"podMonitorSelector\":{},\"podMonitorSelectorNilUsesHelmValues\":true,\"portName\":\"http-web\",\"priorityClassName\":\"\",\"probeNamespaceSelector\":{},\"probeSelector\":{},\"probeSelectorNilUsesHelmValues\":true,\"prometheusExternalLabelName\":\"\",\"prometheusExternalLabelNameClear\":false,\"prometheusRulesExcludedFromEnforce\":[],\"query\":{},\"queryLogFile\":false,\"remoteRead\":[],\"remoteWrite\":[],\"remoteWriteDashboards\":false,\"replicaExternalLabelName\":\"\",\"replicaExternalLabelNameClear\":false,\"replicas\":1,\"resources\":{},\"retention\":\"10d\",\"retentionSize\":\"\",\"routePrefix\":\"/\",\"ruleNamespaceSelector\":{},\"ruleSelector\":{},\"ruleSelectorNilUsesHelmValues\":true,\"scrapeConfigNamespaceSelector\":{},\"scrapeConfigSelector\":{},\"scrapeConfigSelectorNilUsesHelmValues\":true,\"scrapeInterval\":\"\",\"scrapeTimeout\":\"\",\"secrets\":[],\"securityContext\":{\"fsGroup\":2000,\"runAsGroup\":2000,\"runAsNonRoot\":true,\"runAsUser\":1000,\"seccompProfile\":{\"type\":\"RuntimeDefault\"}},\"serviceMonitorNamespaceSelector\":{},\"serviceMonitorSelector\":{},\"serviceMonitorSelectorNilUsesHelmValues\":true,\"shards\":1,\"storageSpec\":{},\"thanos\":{},\"tolerations\":[],\"topologySpreadConstraints\":[],\"tracingConfig\":{},\"tsdb\":{\"outOfOrderTimeWindow\":\"0s\"},\"version\":\"\",\"volumeMounts\":[],\"volumes\":[],\"walCompression\":true,\"web\":{}},\"service\":{\"additionalPorts\":[],\"annotations\":{},\"clusterIP\":\"\",\"externalIPs\":[],\"externalTrafficPolicy\":\"Cluster\",\"labels\":{},\"loadBalancerIP\":\"\",\"loadBalancerSourceRanges\":[],\"nodePort\":30090,\"port\":9090,\"publishNotReadyAddresses\":false,\"sessionAffinity\":\"\",\"targetPort\":9090,\"type\":\"ClusterIP\"},\"serviceAccount\":{\"annotations\":{},\"create\":true,\"name\":\"\"},\"serviceMonitor\":{\"additionalEndpoints\":[],\"additionalLabels\":{},\"bearerTokenFile\":null,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"relabelings\":[],\"sampleLimit\":0,\"scheme\":\"\",\"selfMonitor\":true,\"targetLimit\":0,\"tlsConfig\":{}},\"servicePerReplica\":{\"annotations\":{},\"enabled\":false,\"externalTrafficPolicy\":\"Cluster\",\"loadBalancerSourceRanges\":[],\"nodePort\":30091,\"port\":9090,\"targetPort\":9090,\"type\":\"ClusterIP\"},\"thanosIngress\":{\"annotations\":{},\"enabled\":false,\"hosts\":[],\"labels\":{},\"nodePort\":30901,\"paths\":[],\"servicePort\":10901,\"tls\":[]},\"thanosService\":{\"annotations\":{},\"clusterIP\":\"None\",\"enabled\":false,\"externalTrafficPolicy\":\"Cluster\",\"httpNodePort\":30902,\"httpPort\":10902,\"httpPortName\":\"http\",\"labels\":{},\"nodePort\":30901,\"port\":10901,\"portName\":\"grpc\",\"targetHttpPort\":\"http\",\"targetPort\":\"grpc\",\"type\":\"ClusterIP\"},\"thanosServiceExternal\":{\"annotations\":{},\"enabled\":false,\"externalTrafficPolicy\":\"Cluster\",\"httpNodePort\":30902,\"httpPort\":10902,\"httpPortName\":\"http\",\"labels\":{},\"loadBalancerIP\":\"\",\"loadBalancerSourceRanges\":[],\"nodePort\":30901,\"port\":10901,\"portName\":\"grpc\",\"targetHttpPort\":\"http\",\"targetPort\":\"grpc\",\"type\":\"LoadBalancer\"},\"thanosServiceMonitor\":{\"additionalLabels\":{},\"bearerTokenFile\":null,\"enabled\":false,\"interval\":\"\",\"metricRelabelings\":[],\"relabelings\":[],\"scheme\":\"\",\"tlsConfig\":{}}},\"prometheus-node-exporter\":{\"extraArgs\":[\"--collector.filesystem.mount-points-exclude=^/(dev|proc|sys|var/lib/docker/.+|var/lib/kubelet/.+)($|/)\",\"--collector.filesystem.fs-types-exclude=^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$\"],\"namespaceOverride\":\"\",\"podLabels\":{\"jobLabel\":\"node-exporter\"},\"prometheus\":{\"monitor\":{\"enabled\":true,\"interval\":\"\",\"jobLabel\":\"jobLabel\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"scrapeTimeout\":\"\",\"targetLimit\":0}},\"rbac\":{\"pspEnabled\":false},\"releaseLabel\":true,\"service\":{\"portName\":\"http-metrics\"}},\"prometheus-windows-exporter\":{\"config\":\"collectors:\\n  enabled: '[defaults],memory,container'\",\"podLabels\":{\"jobLabel\":\"windows-exporter\"},\"prometheus\":{\"monitor\":{\"enabled\":true,\"jobLabel\":\"jobLabel\"}}},\"prometheusOperator\":{\"admissionWebhooks\":{\"annotations\":{},\"caBundle\":\"\",\"certManager\":{\"admissionCert\":{\"duration\":\"\"},\"enabled\":false,\"rootCert\":{\"duration\":\"\"}},\"createSecretJob\":{\"securityContext\":{\"allowPrivilegeEscalation\":false,\"capabilities\":{\"drop\":[\"ALL\"]},\"readOnlyRootFilesystem\":true}},\"enabled\":true,\"failurePolicy\":\"\",\"patch\":{\"affinity\":{},\"annotations\":{},\"enabled\":true,\"image\":{\"pullPolicy\":\"IfNotPresent\",\"registry\":\"registry.k8s.io\",\"repository\":\"ingress-nginx/kube-webhook-certgen\",\"sha\":\"\",\"tag\":\"v20221220-controller-v1.5.1-58-g787ea74b6\"},\"nodeSelector\":{},\"podAnnotations\":{},\"priorityClassName\":\"\",\"resources\":{},\"securityContext\":{\"runAsGroup\":2000,\"runAsNonRoot\":true,\"runAsUser\":2000,\"seccompProfile\":{\"type\":\"RuntimeDefault\"}},\"tolerations\":[]},\"patchWebhookJob\":{\"securityContext\":{\"allowPrivilegeEscalation\":false,\"capabilities\":{\"drop\":[\"ALL\"]},\"readOnlyRootFilesystem\":true}},\"timeoutSeconds\":10},\"affinity\":{},\"alertmanagerConfigNamespaces\":[],\"alertmanagerInstanceNamespaces\":[],\"alertmanagerInstanceSelector\":\"\",\"annotations\":{},\"containerSecurityContext\":{\"allowPrivilegeEscalation\":false,\"capabilities\":{\"drop\":[\"ALL\"]},\"readOnlyRootFilesystem\":true},\"denyNamespaces\":[],\"dnsConfig\":{},\"enabled\":true,\"hostNetwork\":false,\"image\":{\"pullPolicy\":\"IfNotPresent\",\"registry\":\"quay.io\",\"repository\":\"prometheus-operator/prometheus-operator\",\"sha\":\"\",\"tag\":\"\"},\"kubeletService\":{\"enabled\":true,\"name\":\"\",\"namespace\":\"kube-system\"},\"labels\":{},\"namespaces\":{},\"networkPolicy\":{\"enabled\":false,\"flavor\":\"kubernetes\"},\"nodeSelector\":{},\"podAnnotations\":{},\"podLabels\":{},\"prometheusConfigReloader\":{\"enableProbe\":false,\"image\":{\"registry\":\"quay.io\",\"repository\":\"prometheus-operator/prometheus-config-reloader\",\"sha\":\"\",\"tag\":\"\"},\"resources\":{}},\"prometheusInstanceNamespaces\":[],\"prometheusInstanceSelector\":\"\",\"resources\":{},\"revisionHistoryLimit\":10,\"secretFieldSelector\":\"type!=kubernetes.io/dockercfg,type!=kubernetes.io/service-account-token,type!=helm.sh/release.v1\",\"securityContext\":{\"fsGroup\":65534,\"runAsGroup\":65534,\"runAsNonRoot\":true,\"runAsUser\":65534,\"seccompProfile\":{\"type\":\"RuntimeDefault\"}},\"service\":{\"additionalPorts\":[],\"annotations\":{},\"clusterIP\":\"\",\"externalIPs\":[],\"externalTrafficPolicy\":\"Cluster\",\"labels\":{},\"loadBalancerIP\":\"\",\"loadBalancerSourceRanges\":[],\"nodePort\":30080,\"nodePortTls\":30443,\"type\":\"ClusterIP\"},\"serviceAccount\":{\"create\":true,\"name\":\"\"},\"serviceMonitor\":{\"additionalLabels\":{},\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"relabelings\":[],\"sampleLimit\":0,\"scrapeTimeout\":\"\",\"selfMonitor\":true,\"targetLimit\":0},\"thanosImage\":{\"registry\":\"quay.io\",\"repository\":\"thanos/thanos\",\"sha\":\"\",\"tag\":\"v0.32.5\"},\"thanosRulerInstanceNamespaces\":[],\"thanosRulerInstanceSelector\":\"\",\"tls\":{\"enabled\":true,\"internalPort\":10250,\"tlsMinVersion\":\"VersionTLS13\"},\"tolerations\":[],\"verticalPodAutoscaler\":{\"controlledResources\":[],\"enabled\":false,\"maxAllowed\":{},\"minAllowed\":{},\"updatePolicy\":{\"updateMode\":\"Auto\"}}},\"thanosRuler\":{\"annotations\":{},\"enabled\":false,\"extraSecret\":{\"annotations\":{},\"data\":{}},\"ingress\":{\"annotations\":{},\"enabled\":false,\"hosts\":[],\"labels\":{},\"paths\":[],\"tls\":[]},\"podDisruptionBudget\":{\"enabled\":false,\"maxUnavailable\":\"\",\"minAvailable\":1},\"service\":{\"additionalPorts\":[],\"annotations\":{},\"clusterIP\":\"\",\"externalIPs\":[],\"externalTrafficPolicy\":\"Cluster\",\"labels\":{},\"loadBalancerIP\":\"\",\"loadBalancerSourceRanges\":[],\"nodePort\":30905,\"port\":10902,\"targetPort\":10902,\"type\":\"ClusterIP\"},\"serviceAccount\":{\"annotations\":{},\"create\":true,\"name\":\"\"},\"serviceMonitor\":{\"additionalEndpoints\":[],\"additionalLabels\":{},\"bearerTokenFile\":null,\"interval\":\"\",\"labelLimit\":0,\"labelNameLengthLimit\":0,\"labelValueLengthLimit\":0,\"metricRelabelings\":[],\"proxyUrl\":\"\",\"relabelings\":[],\"sampleLimit\":0,\"scheme\":\"\",\"selfMonitor\":true,\"targetLimit\":0,\"tlsConfig\":{}},\"thanosRulerSpec\":{\"affinity\":{},\"alertmanagersConfig\":{\"existingSecret\":{},\"secret\":{}},\"containers\":[],\"evaluationInterval\":\"\",\"externalPrefix\":null,\"image\":{\"registry\":\"quay.io\",\"repository\":\"thanos/thanos\",\"sha\":\"\",\"tag\":\"v0.32.5\"},\"initContainers\":[],\"labels\":{},\"listenLocal\":false,\"logFormat\":\"logfmt\",\"logLevel\":\"info\",\"nodeSelector\":{},\"objectStorageConfig\":{\"existingSecret\":{},\"secret\":{}},\"paused\":false,\"podAntiAffinity\":\"\",\"podAntiAffinityTopologyKey\":\"kubernetes.io/hostname\",\"podMetadata\":{},\"portName\":\"web\",\"priorityClassName\":\"\",\"queryConfig\":{\"existingSecret\":{},\"secret\":{}},\"queryEndpoints\":[],\"replicas\":1,\"resources\":{},\"retention\":\"24h\",\"routePrefix\":\"/\",\"ruleNamespaceSelector\":{},\"ruleSelector\":{},\"ruleSelectorNilUsesHelmValues\":true,\"securityContext\":{\"fsGroup\":2000,\"runAsGroup\":2000,\"runAsNonRoot\":true,\"runAsUser\":1000,\"seccompProfile\":{\"type\":\"RuntimeDefault\"}},\"storage\":{},\"tolerations\":[],\"topologySpreadConstraints\":[],\"volumeMounts\":[],\"volumes\":[]}},\"windowsMonitoring\":{\"enabled\":false}}",
                "version": "52.1.0"
              }
            ],
            "name": "prometheus-operator",
            "namespace": "monitoring",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://prometheus-community.github.io/helm-charts",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_list": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "# Default values for kube-prometheus-stack.\n# This is a YAML-formatted file.\n# Declare variables to be passed into your templates.\n\n## Provide a name in place of kube-prometheus-stack for `app:` labels\n##\nnameOverride: \"\"\n\n## Override the deployment namespace\n##\nnamespaceOverride: \"\"\n\n## Provide a k8s version to auto dashboard import script example: kubeTargetVersionOverride: 1.26.6\n##\nkubeTargetVersionOverride: \"\"\n\n## Allow kubeVersion to be overridden while creating the ingress\n##\nkubeVersionOverride: \"\"\n\n## Provide a name to substitute for the full names of resources\n##\nfullnameOverride: \"\"\n\n## Labels to apply to all resources\n##\ncommonLabels: {}\n# scmhash: abc123\n# myLabel: aakkmd\n\n## Install Prometheus Operator CRDs\n##\ncrds:\n  enabled: true\n\n## Create default rules for monitoring the cluster\n##\ndefaultRules:\n  create: false\n  rules:\n    alertmanager: true\n    etcd: true\n    configReloaders: true\n    general: true\n    k8s: true\n    kubeApiserverAvailability: true\n    kubeApiserverBurnrate: true\n    kubeApiserverHistogram: true\n    kubeApiserverSlos: true\n    kubeControllerManager: true\n    kubelet: true\n    kubeProxy: true\n    kubePrometheusGeneral: true\n    kubePrometheusNodeRecording: true\n    kubernetesApps: true\n    kubernetesResources: true\n    kubernetesStorage: true\n    kubernetesSystem: true\n    kubeSchedulerAlerting: true\n    kubeSchedulerRecording: true\n    kubeStateMetrics: true\n    network: true\n    node: true\n    nodeExporterAlerting: true\n    nodeExporterRecording: true\n    prometheus: true\n    prometheusOperator: true\n    windows: true\n\n  ## Reduce app namespace alert scope\n  appNamespacesTarget: \".*\"\n\n  ## Set keep_firing_for for all alerts\n  keepFiringFor: \"\"\n\n  ## Labels for default rules\n  labels: {}\n  ## Annotations for default rules\n  annotations: {}\n\n  ## Additional labels for PrometheusRule alerts\n  additionalRuleLabels: {}\n\n  ## Additional annotations for PrometheusRule alerts\n  additionalRuleAnnotations: {}\n\n  ## Additional labels for specific PrometheusRule alert groups\n  additionalRuleGroupLabels:\n    alertmanager: {}\n    etcd: {}\n    configReloaders: {}\n    general: {}\n    k8s: {}\n    kubeApiserverAvailability: {}\n    kubeApiserverBurnrate: {}\n    kubeApiserverHistogram: {}\n    kubeApiserverSlos: {}\n    kubeControllerManager: {}\n    kubelet: {}\n    kubeProxy: {}\n    kubePrometheusGeneral: {}\n    kubePrometheusNodeRecording: {}\n    kubernetesApps: {}\n    kubernetesResources: {}\n    kubernetesStorage: {}\n    kubernetesSystem: {}\n    kubeSchedulerAlerting: {}\n    kubeSchedulerRecording: {}\n    kubeStateMetrics: {}\n    network: {}\n    node: {}\n    nodeExporterAlerting: {}\n    nodeExporterRecording: {}\n    prometheus: {}\n    prometheusOperator: {}\n\n  ## Additional annotations for specific PrometheusRule alerts groups\n  additionalRuleGroupAnnotations:\n    alertmanager: {}\n    etcd: {}\n    configReloaders: {}\n    general: {}\n    k8s: {}\n    kubeApiserverAvailability: {}\n    kubeApiserverBurnrate: {}\n    kubeApiserverHistogram: {}\n    kubeApiserverSlos: {}\n    kubeControllerManager: {}\n    kubelet: {}\n    kubeProxy: {}\n    kubePrometheusGeneral: {}\n    kubePrometheusNodeRecording: {}\n    kubernetesApps: {}\n    kubernetesResources: {}\n    kubernetesStorage: {}\n    kubernetesSystem: {}\n    kubeSchedulerAlerting: {}\n    kubeSchedulerRecording: {}\n    kubeStateMetrics: {}\n    network: {}\n    node: {}\n    nodeExporterAlerting: {}\n    nodeExporterRecording: {}\n    prometheus: {}\n    prometheusOperator: {}\n\n  ## Prefix for runbook URLs. Use this to override the first part of the runbookURLs that is common to all rules.\n  runbookUrl: \"https://runbooks.prometheus-operator.dev/runbooks\"\n\n  ## Disabled PrometheusRule alerts\n  disabled: {}\n  # KubeAPIDown: true\n  # NodeRAIDDegraded: true\n\n## Deprecated way to provide custom recording or alerting rules to be deployed into the cluster.\n##\n# additionalPrometheusRules: []\n#  - name: my-rule-file\n#    groups:\n#      - name: my_group\n#        rules:\n#        - record: my_record\n#          expr: 100 * my_record\n\n## Provide custom recording or alerting rules to be deployed into the cluster.\n##\nadditionalPrometheusRulesMap: {}\n#  rule-name:\n#    groups:\n#    - name: my_group\n#      rules:\n#      - record: my_record\n#        expr: 100 * my_record\n\n##\nglobal:\n  rbac:\n    create: true\n\n    ## Create ClusterRoles that extend the existing view, edit and admin ClusterRoles to interact with prometheus-operator CRDs\n    ## Ref: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#aggregated-clusterroles\n    createAggregateClusterRoles: false\n    pspEnabled: false\n    pspAnnotations: {}\n      ## Specify pod annotations\n      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor\n      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp\n      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl\n      ##\n      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'\n      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'\n      # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'\n\n  ## Global image registry to use if it needs to be overriden for some specific use cases (e.g local registries, custom images, ...)\n  ##\n  imageRegistry: \"\"\n\n  ## Reference to one or more secrets to be used when pulling images\n  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/\n  ##\n  imagePullSecrets: []\n  # - name: \"image-pull-secret\"\n  # or\n  # - \"image-pull-secret\"\n\nwindowsMonitoring:\n  ## Deploys the windows-exporter and Windows-specific dashboards and rules (job name must be 'windows-exporter')\n  enabled: false\n\n## Configuration for prometheus-windows-exporter\n## ref: https://github.com/prometheus-community/helm-charts/tree/main/charts/prometheus-windows-exporter\n##\nprometheus-windows-exporter:\n  ## Enable ServiceMonitor and set Kubernetes label to use as a job label\n  ##\n  prometheus:\n    monitor:\n      enabled: true\n      jobLabel: jobLabel\n\n  ## Set job label to 'windows-exporter' as required by the default Prometheus rules and Grafana dashboards\n  ##\n  podLabels:\n    jobLabel: windows-exporter\n\n  ## Enable memory and container metrics as required by the default Prometheus rules and Grafana dashboards\n  ##\n  config: |-\n    collectors:\n      enabled: '[defaults],memory,container'\n\n## Configuration for alertmanager\n## ref: https://prometheus.io/docs/alerting/alertmanager/\n##\nalertmanager:\n\n  ## Deploy alertmanager\n  ##\n  enabled: false\n\n  ## Annotations for Alertmanager\n  ##\n  annotations: {}\n\n  ## Api that prometheus will use to communicate with alertmanager. Possible values are v1, v2\n  ##\n  apiVersion: v2\n\n  ## Service account for Alertmanager to use.\n  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\n  ##\n  serviceAccount:\n    create: true\n    name: \"\"\n    annotations: {}\n    automountServiceAccountToken: true\n\n  ## Configure pod disruption budgets for Alertmanager\n  ## ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/#specifying-a-poddisruptionbudget\n  ## This configuration is immutable once created and will require the PDB to be deleted to be changed\n  ## https://github.com/kubernetes/kubernetes/issues/45398\n  ##\n  podDisruptionBudget:\n    enabled: false\n    minAvailable: 1\n    maxUnavailable: \"\"\n\n  ## Alertmanager configuration directives\n  ## ref: https://prometheus.io/docs/alerting/configuration/#configuration-file\n  ##      https://prometheus.io/webtools/alerting/routing-tree-editor/\n  ##\n  config:\n    global:\n      resolve_timeout: 5m\n    inhibit_rules:\n      - source_matchers:\n          - 'severity = critical'\n        target_matchers:\n          - 'severity =~ warning|info'\n        equal:\n          - 'namespace'\n          - 'alertname'\n      - source_matchers:\n          - 'severity = warning'\n        target_matchers:\n          - 'severity = info'\n        equal:\n          - 'namespace'\n          - 'alertname'\n      - source_matchers:\n          - 'alertname = InfoInhibitor'\n        target_matchers:\n          - 'severity = info'\n        equal:\n          - 'namespace'\n    route:\n      group_by: ['namespace']\n      group_wait: 30s\n      group_interval: 5m\n      repeat_interval: 12h\n      receiver: 'null'\n      routes:\n      - receiver: 'null'\n        matchers:\n          - alertname =~ \"InfoInhibitor|Watchdog\"\n    receivers:\n    - name: 'null'\n    templates:\n    - '/etc/alertmanager/config/*.tmpl'\n\n  ## Alertmanager configuration directives (as string type, preferred over the config hash map)\n  ## stringConfig will be used only, if tplConfig is true\n  ## ref: https://prometheus.io/docs/alerting/configuration/#configuration-file\n  ##      https://prometheus.io/webtools/alerting/routing-tree-editor/\n  ##\n  stringConfig: \"\"\n\n  ## Pass the Alertmanager configuration directives through Helm's templating\n  ## engine. If the Alertmanager configuration contains Alertmanager templates,\n  ## they'll need to be properly escaped so that they are not interpreted by\n  ## Helm\n  ## ref: https://helm.sh/docs/developing_charts/#using-the-tpl-function\n  ##      https://prometheus.io/docs/alerting/configuration/#tmpl_string\n  ##      https://prometheus.io/docs/alerting/notifications/\n  ##      https://prometheus.io/docs/alerting/notification_examples/\n  tplConfig: false\n\n  ## Alertmanager template files to format alerts\n  ## By default, templateFiles are placed in /etc/alertmanager/config/ and if\n  ## they have a .tmpl file suffix will be loaded. See config.templates above\n  ## to change, add other suffixes. If adding other suffixes, be sure to update\n  ## config.templates above to include those suffixes.\n  ## ref: https://prometheus.io/docs/alerting/notifications/\n  ##      https://prometheus.io/docs/alerting/notification_examples/\n  ##\n  templateFiles: {}\n  #\n  ## An example template:\n  #   template_1.tmpl: |-\n  #       {{ define \"cluster\" }}{{ .ExternalURL | reReplaceAll \".*alertmanager\\\\.(.*)\" \"$1\" }}{{ end }}\n  #\n  #       {{ define \"slack.myorg.text\" }}\n  #       {{- $root := . -}}\n  #       {{ range .Alerts }}\n  #         *Alert:* {{ .Annotations.summary }} - `{{ .Labels.severity }}`\n  #         *Cluster:* {{ template \"cluster\" $root }}\n  #         *Description:* {{ .Annotations.description }}\n  #         *Graph:* \u003c{{ .GeneratorURL }}|:chart_with_upwards_trend:\u003e\n  #         *Runbook:* \u003c{{ .Annotations.runbook }}|:spiral_note_pad:\u003e\n  #         *Details:*\n  #           {{ range .Labels.SortedPairs }} - *{{ .Name }}:* `{{ .Value }}`\n  #           {{ end }}\n  #       {{ end }}\n  #       {{ end }}\n\n  ingress:\n    enabled: false\n\n    # For Kubernetes \u003e= 1.18 you should specify the ingress-controller via the field ingressClassName\n    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress\n    # ingressClassName: nginx\n\n    annotations: {}\n\n    labels: {}\n\n    ## Override ingress to a different defined port on the service\n    # servicePort: 8081\n    ## Override ingress to a different service then the default, this is useful if you need to\n    ## point to a specific instance of the alertmanager (eg kube-prometheus-stack-alertmanager-0)\n    # serviceName: kube-prometheus-stack-alertmanager-0\n\n    ## Hosts must be provided if Ingress is enabled.\n    ##\n    hosts: []\n      # - alertmanager.domain.com\n\n    ## Paths to use for ingress rules - one path should match the alertmanagerSpec.routePrefix\n    ##\n    paths: []\n    # - /\n\n    ## For Kubernetes \u003e= 1.18 you should specify the pathType (determines how Ingress paths should be matched)\n    ## See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#better-path-matching-with-path-types\n    # pathType: ImplementationSpecific\n\n    ## TLS configuration for Alertmanager Ingress\n    ## Secret must be manually created in the namespace\n    ##\n    tls: []\n    # - secretName: alertmanager-general-tls\n    #   hosts:\n    #   - alertmanager.example.com\n\n  ## Configuration for Alertmanager secret\n  ##\n  secret:\n    annotations: {}\n\n  ## Configuration for creating an Ingress that will map to each Alertmanager replica service\n  ## alertmanager.servicePerReplica must be enabled\n  ##\n  ingressPerReplica:\n    enabled: false\n\n    # For Kubernetes \u003e= 1.18 you should specify the ingress-controller via the field ingressClassName\n    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress\n    # ingressClassName: nginx\n\n    annotations: {}\n    labels: {}\n\n    ## Final form of the hostname for each per replica ingress is\n    ## {{ ingressPerReplica.hostPrefix }}-{{ $replicaNumber }}.{{ ingressPerReplica.hostDomain }}\n    ##\n    ## Prefix for the per replica ingress that will have `-$replicaNumber`\n    ## appended to the end\n    hostPrefix: \"\"\n    ## Domain that will be used for the per replica ingress\n    hostDomain: \"\"\n\n    ## Paths to use for ingress rules\n    ##\n    paths: []\n    # - /\n\n    ## For Kubernetes \u003e= 1.18 you should specify the pathType (determines how Ingress paths should be matched)\n    ## See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#better-path-matching-with-path-types\n    # pathType: ImplementationSpecific\n\n    ## Secret name containing the TLS certificate for alertmanager per replica ingress\n    ## Secret must be manually created in the namespace\n    tlsSecretName: \"\"\n\n    ## Separated secret for each per replica Ingress. Can be used together with cert-manager\n    ##\n    tlsSecretPerReplica:\n      enabled: false\n      ## Final form of the secret for each per replica ingress is\n      ## {{ tlsSecretPerReplica.prefix }}-{{ $replicaNumber }}\n      ##\n      prefix: \"alertmanager\"\n\n  ## Configuration for Alertmanager service\n  ##\n  service:\n    annotations: {}\n    labels: {}\n    clusterIP: \"\"\n\n    ## Port for Alertmanager Service to listen on\n    ##\n    port: 9093\n    ## To be used with a proxy extraContainer port\n    ##\n    targetPort: 9093\n    ## Port to expose on each node\n    ## Only used if service.type is 'NodePort'\n    ##\n    nodePort: 30903\n    ## List of IP addresses at which the Prometheus server service is available\n    ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n    ##\n\n    ## Additional ports to open for Alertmanager service\n    ##\n    additionalPorts: []\n    # - name: oauth-proxy\n    #   port: 8081\n    #   targetPort: 8081\n    # - name: oauth-metrics\n    #   port: 8082\n    #   targetPort: 8082\n\n    externalIPs: []\n    loadBalancerIP: \"\"\n    loadBalancerSourceRanges: []\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n    ## If you want to make sure that connections from a particular client are passed to the same Pod each time\n    ## Accepts 'ClientIP' or ''\n    ##\n    sessionAffinity: \"\"\n\n    ## Service type\n    ##\n    type: ClusterIP\n\n  ## Configuration for creating a separate Service for each statefulset Alertmanager replica\n  ##\n  servicePerReplica:\n    enabled: false\n    annotations: {}\n\n    ## Port for Alertmanager Service per replica to listen on\n    ##\n    port: 9093\n\n    ## To be used with a proxy extraContainer port\n    targetPort: 9093\n\n    ## Port to expose on each node\n    ## Only used if servicePerReplica.type is 'NodePort'\n    ##\n    nodePort: 30904\n\n    ## Loadbalancer source IP ranges\n    ## Only used if servicePerReplica.type is \"LoadBalancer\"\n    loadBalancerSourceRanges: []\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n    ## Service type\n    ##\n    type: ClusterIP\n\n  ## If true, create a serviceMonitor for alertmanager\n  ##\n  serviceMonitor:\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n    selfMonitor: true\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    ## scheme: HTTP scheme to use for scraping. Can be used with `tlsConfig` for example if using istio mTLS.\n    scheme: \"\"\n\n    ## enableHttp2: Whether to enable HTTP2.\n    ## See https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#endpoint\n    enableHttp2: true\n\n    ## tlsConfig: TLS configuration to use when scraping the endpoint. For example if using istio mTLS.\n    ## Of type: https://github.com/coreos/prometheus-operator/blob/main/Documentation/api.md#tlsconfig\n    tlsConfig: {}\n\n    bearerTokenFile:\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional Endpoints\n    ##\n    additionalEndpoints: []\n    # - port: oauth-metrics\n    #   path: /metrics\n\n  ## Settings affecting alertmanagerSpec\n  ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#alertmanagerspec\n  ##\n  alertmanagerSpec:\n    ## Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata\n    ## Metadata Labels and Annotations gets propagated to the Alertmanager pods.\n    ##\n    podMetadata: {}\n\n    ## Image of Alertmanager\n    ##\n    image:\n      registry: quay.io\n      repository: prometheus/alertmanager\n      tag: v0.26.0\n      sha: \"\"\n\n    ## If true then the user will be responsible to provide a secret with alertmanager configuration\n    ## So when true the config part will be ignored (including templateFiles) and the one in the secret will be used\n    ##\n    useExistingSecret: false\n\n    ## Secrets is a list of Secrets in the same namespace as the Alertmanager object, which shall be mounted into the\n    ## Alertmanager Pods. The Secrets are mounted into /etc/alertmanager/secrets/.\n    ##\n    secrets: []\n\n    ## ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods.\n    ## The ConfigMaps are mounted into /etc/alertmanager/configmaps/.\n    ##\n    configMaps: []\n\n    ## ConfigSecret is the name of a Kubernetes Secret in the same namespace as the Alertmanager object, which contains configuration for\n    ## this Alertmanager instance. Defaults to 'alertmanager-' The secret is mounted into /etc/alertmanager/config.\n    ##\n    # configSecret:\n\n    ## WebTLSConfig defines the TLS parameters for HTTPS\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#alertmanagerwebspec\n    web: {}\n\n    ## AlertmanagerConfigs to be selected to merge and configure Alertmanager with.\n    ##\n    alertmanagerConfigSelector: {}\n    ## Example which selects all alertmanagerConfig resources\n    ## with label \"alertconfig\" with values any of \"example-config\" or \"example-config-2\"\n    # alertmanagerConfigSelector:\n    #   matchExpressions:\n    #     - key: alertconfig\n    #       operator: In\n    #       values:\n    #         - example-config\n    #         - example-config-2\n    #\n    ## Example which selects all alertmanagerConfig resources with label \"role\" set to \"example-config\"\n    # alertmanagerConfigSelector:\n    #   matchLabels:\n    #     role: example-config\n\n    ## Namespaces to be selected for AlertmanagerConfig discovery. If nil, only check own namespace.\n    ##\n    alertmanagerConfigNamespaceSelector: {}\n    ## Example which selects all namespaces\n    ## with label \"alertmanagerconfig\" with values any of \"example-namespace\" or \"example-namespace-2\"\n    # alertmanagerConfigNamespaceSelector:\n    #   matchExpressions:\n    #     - key: alertmanagerconfig\n    #       operator: In\n    #       values:\n    #         - example-namespace\n    #         - example-namespace-2\n\n    ## Example which selects all namespaces with label \"alertmanagerconfig\" set to \"enabled\"\n    # alertmanagerConfigNamespaceSelector:\n    #   matchLabels:\n    #     alertmanagerconfig: enabled\n\n    ## AlermanagerConfig to be used as top level configuration\n    ##\n    alertmanagerConfiguration: {}\n    ## Example with select a global alertmanagerconfig\n    # alertmanagerConfiguration:\n    #   name: global-alertmanager-Configuration\n\n    ## Defines the strategy used by AlertmanagerConfig objects to match alerts. eg:\n    ##\n    alertmanagerConfigMatcherStrategy: {}\n    ## Example with use OnNamespace strategy\n    # alertmanagerConfigMatcherStrategy:\n    #   type: OnNamespace\n\n    ## Define Log Format\n    # Use logfmt (default) or json logging\n    logFormat: logfmt\n\n    ## Log level for Alertmanager to be configured with.\n    ##\n    logLevel: info\n\n    ## Size is the expected size of the alertmanager cluster. The controller will eventually make the size of the\n    ## running cluster equal to the expected size.\n    replicas: 1\n\n    ## Time duration Alertmanager shall retain data for. Default is '120h', and must match the regular expression\n    ## [0-9]+(ms|s|m|h) (milliseconds seconds minutes hours).\n    ##\n    retention: 120h\n\n    ## Storage is the definition of how storage will be used by the Alertmanager instances.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/user-guides/storage.md\n    ##\n    storage: {}\n    # volumeClaimTemplate:\n    #   spec:\n    #     storageClassName: gluster\n    #     accessModes: [\"ReadWriteOnce\"]\n    #     resources:\n    #       requests:\n    #         storage: 50Gi\n    #     selector: {}\n\n\n    ## The external URL the Alertmanager instances will be available under. This is necessary to generate correct URLs. This is necessary if Alertmanager is not served from root of a DNS name. string  false\n    ##\n    externalUrl:\n\n    ## The route prefix Alertmanager registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true,\n    ## but the server serves requests under a different route prefix. For example for use with kubectl proxy.\n    ##\n    routePrefix: /\n\n    ## scheme: HTTP scheme to use. Can be used with `tlsConfig` for example if using istio mTLS.\n    scheme: \"\"\n\n    ## tlsConfig: TLS configuration to use when connect to the endpoint. For example if using istio mTLS.\n    ## Of type: https://github.com/coreos/prometheus-operator/blob/main/Documentation/api.md#tlsconfig\n    tlsConfig: {}\n\n    ## If set to true all actions on the underlying managed objects are not going to be performed, except for delete actions.\n    ##\n    paused: false\n\n    ## Define which Nodes the Pods are scheduled on.\n    ## ref: https://kubernetes.io/docs/user-guide/node-selection/\n    ##\n    nodeSelector: {}\n\n    ## Define resources requests and limits for single Pods.\n    ## ref: https://kubernetes.io/docs/user-guide/compute-resources/\n    ##\n    resources: {}\n    # requests:\n    #   memory: 400Mi\n\n    ## Pod anti-affinity can prevent the scheduler from placing Prometheus replicas on the same node.\n    ## The default value \"soft\" means that the scheduler should *prefer* to not schedule two replica pods onto the same node but no guarantee is provided.\n    ## The value \"hard\" means that the scheduler is *required* to not schedule two replica pods onto the same node.\n    ## The value \"\" will disable pod anti-affinity so that no anti-affinity rules will be configured.\n    ##\n    podAntiAffinity: \"\"\n\n    ## If anti-affinity is enabled sets the topologyKey to use for anti-affinity.\n    ## This can be changed to, for example, failure-domain.beta.kubernetes.io/zone\n    ##\n    podAntiAffinityTopologyKey: kubernetes.io/hostname\n\n    ## Assign custom affinity rules to the alertmanager instance\n    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n    ##\n    affinity: {}\n    # nodeAffinity:\n    #   requiredDuringSchedulingIgnoredDuringExecution:\n    #     nodeSelectorTerms:\n    #     - matchExpressions:\n    #       - key: kubernetes.io/e2e-az-name\n    #         operator: In\n    #         values:\n    #         - e2e-az1\n    #         - e2e-az2\n\n    ## If specified, the pod's tolerations.\n    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\n    ##\n    tolerations: []\n    # - key: \"key\"\n    #   operator: \"Equal\"\n    #   value: \"value\"\n    #   effect: \"NoSchedule\"\n\n    ## If specified, the pod's topology spread constraints.\n    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\n    ##\n    topologySpreadConstraints: []\n    # - maxSkew: 1\n    #   topologyKey: topology.kubernetes.io/zone\n    #   whenUnsatisfiable: DoNotSchedule\n    #   labelSelector:\n    #     matchLabels:\n    #       app: alertmanager\n\n    ## SecurityContext holds pod-level security attributes and common container settings.\n    ## This defaults to non root user with uid 1000 and gid 2000. *v1.PodSecurityContext  false\n    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n    ##\n    securityContext:\n      runAsGroup: 2000\n      runAsNonRoot: true\n      runAsUser: 1000\n      fsGroup: 2000\n      seccompProfile:\n        type: RuntimeDefault\n\n    ## ListenLocal makes the Alertmanager server listen on loopback, so that it does not bind against the Pod IP.\n    ## Note this is only for the Alertmanager UI, not the gossip communication.\n    ##\n    listenLocal: false\n\n    ## Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an Alertmanager pod.\n    ##\n    containers: []\n    # containers:\n    # - name: oauth-proxy\n    #   image: quay.io/oauth2-proxy/oauth2-proxy:v7.5.1\n    #   args:\n    #   - --upstream=http://127.0.0.1:9093\n    #   - --http-address=0.0.0.0:8081\n    #   - --metrics-address=0.0.0.0:8082\n    #   - ...\n    #   ports:\n    #   - containerPort: 8081\n    #     name: oauth-proxy\n    #     protocol: TCP\n    #   - containerPort: 8082\n    #     name: oauth-metrics\n    #     protocol: TCP\n    #   resources: {}\n\n    # Additional volumes on the output StatefulSet definition.\n    volumes: []\n\n    # Additional VolumeMounts on the output StatefulSet definition.\n    volumeMounts: []\n\n    ## InitContainers allows injecting additional initContainers. This is meant to allow doing some changes\n    ## (permissions, dir tree) on mounted volumes before starting prometheus\n    initContainers: []\n\n    ## Priority class assigned to the Pods\n    ##\n    priorityClassName: \"\"\n\n    ## AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.\n    ##\n    additionalPeers: []\n\n    ## PortName to use for Alert Manager.\n    ##\n    portName: \"http-web\"\n\n    ## ClusterAdvertiseAddress is the explicit address to advertise in cluster. Needs to be provided for non RFC1918 [1] (public) addresses. [1] RFC1918: https://tools.ietf.org/html/rfc1918\n    ##\n    clusterAdvertiseAddress: false\n\n    ## clusterGossipInterval determines interval between gossip attempts.\n    ## Needs to be specified as GoDuration, a time duration that can be parsed by Go’s time.ParseDuration() (e.g. 45ms, 30s, 1m, 1h20m15s)\n    clusterGossipInterval: \"\"\n\n    ## clusterPeerTimeout determines timeout for cluster peering.\n    ## Needs to be specified as GoDuration, a time duration that can be parsed by Go’s time.ParseDuration() (e.g. 45ms, 30s, 1m, 1h20m15s)\n    clusterPeerTimeout: \"\"\n\n    ## clusterPushpullInterval determines interval between pushpull attempts.\n    ## Needs to be specified as GoDuration, a time duration that can be parsed by Go’s time.ParseDuration() (e.g. 45ms, 30s, 1m, 1h20m15s)\n    clusterPushpullInterval: \"\"\n\n    ## ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica.\n    ## Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.\n    forceEnableClusterMode: false\n\n    ## Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to\n    ## be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).\n    minReadySeconds: 0\n\n    ## Additional configuration which is not covered by the properties above. (passed through tpl)\n    additionalConfig: {}\n\n    ## Additional configuration which is not covered by the properties above.\n    ## Useful, if you need advanced templating inside alertmanagerSpec.\n    ## Otherwise, use alertmanager.alertmanagerSpec.additionalConfig (passed through tpl)\n    additionalConfigString: \"\"\n\n  ## ExtraSecret can be used to store various data in an extra secret\n  ## (use it for example to store hashed basic auth credentials)\n  extraSecret:\n    ## if not set, name will be auto generated\n    # name: \"\"\n    annotations: {}\n    data: {}\n  #   auth: |\n  #     foo:$apr1$OFG3Xybp$ckL0FHDAkoXYIlH9.cysT0\n  #     someoneelse:$apr1$DMZX2Z4q$6SbQIfyuLQd.xmo/P0m2c.\n\n## Using default values from https://github.com/grafana/helm-charts/blob/main/charts/grafana/values.yaml\n##\ngrafana:\n  enabled: true\n  namespaceOverride: \"\"\n\n  ## ForceDeployDatasources Create datasource configmap even if grafana deployment has been disabled\n  ##\n  forceDeployDatasources: false\n\n  ## ForceDeployDashboard Create dashboard configmap even if grafana deployment has been disabled\n  ##\n  forceDeployDashboards: false\n\n  ## Deploy default dashboards\n  ##\n  defaultDashboardsEnabled: true\n\n  ## Timezone for the default dashboards\n  ## Other options are: browser or a specific timezone, i.e. Europe/Luxembourg\n  ##\n  defaultDashboardsTimezone: utc\n\n  adminPassword: prom-operator\n\n  rbac:\n    ## If true, Grafana PSPs will be created\n    ##\n    pspEnabled: false\n\n  ingress:\n    ## If true, Grafana Ingress will be created\n    ##\n    enabled: false\n\n    ## IngressClassName for Grafana Ingress.\n    ## Should be provided if Ingress is enable.\n    ##\n    # ingressClassName: nginx\n\n    ## Annotations for Grafana Ingress\n    ##\n    annotations: {}\n      # kubernetes.io/ingress.class: nginx\n      # kubernetes.io/tls-acme: \"true\"\n\n    ## Labels to be added to the Ingress\n    ##\n    labels: {}\n\n    ## Hostnames.\n    ## Must be provided if Ingress is enable.\n    ##\n    # hosts:\n    #   - grafana.domain.com\n    hosts: []\n\n    ## Path for grafana ingress\n    path: /\n\n    ## TLS configuration for grafana Ingress\n    ## Secret must be manually created in the namespace\n    ##\n    tls: []\n    # - secretName: grafana-general-tls\n    #   hosts:\n    #   - grafana.example.com\n\n  sidecar:\n    dashboards:\n      enabled: true\n      label: grafana_dashboard\n      labelValue: \"1\"\n      # Allow discovery in all namespaces for dashboards\n      searchNamespace: ALL\n\n      ## Annotations for Grafana dashboard configmaps\n      ##\n      annotations: {}\n      multicluster:\n        global:\n          enabled: false\n        etcd:\n          enabled: false\n      provider:\n        allowUiUpdates: false\n    datasources:\n      enabled: true\n      defaultDatasourceEnabled: true\n      isDefaultDatasource: true\n\n      uid: prometheus\n\n      ## URL of prometheus datasource\n      ##\n      # url: http://prometheus-stack-prometheus:9090/\n\n      ## Prometheus request timeout in seconds\n      # timeout: 30\n\n      # If not defined, will use prometheus.prometheusSpec.scrapeInterval or its default\n      # defaultDatasourceScrapeInterval: 15s\n\n      ## Annotations for Grafana datasource configmaps\n      ##\n      annotations: {}\n\n      ## Set method for HTTP to send query to datasource\n      httpMethod: POST\n\n      ## Create datasource for each Pod of Prometheus StatefulSet;\n      ## this uses headless service `prometheus-operated` which is\n      ## created by Prometheus Operator\n      ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/0fee93e12dc7c2ea1218f19ae25ec6b893460590/pkg/prometheus/statefulset.go#L255-L286\n      createPrometheusReplicasDatasources: false\n      label: grafana_datasource\n      labelValue: \"1\"\n\n      ## Field with internal link pointing to existing data source in Grafana.\n      ## Can be provisioned via additionalDataSources\n      exemplarTraceIdDestinations: {}\n        # datasourceUid: Jaeger\n        # traceIdLabelName: trace_id\n      alertmanager:\n        enabled: true\n        uid: alertmanager\n        handleGrafanaManagedAlerts: false\n        implementation: prometheus\n\n  extraConfigmapMounts: []\n  # - name: certs-configmap\n  #   mountPath: /etc/grafana/ssl/\n  #   configMap: certs-configmap\n  #   readOnly: true\n\n  deleteDatasources: []\n  # - name: example-datasource\n  #   orgId: 1\n\n  ## Configure additional grafana datasources (passed through tpl)\n  ## ref: http://docs.grafana.org/administration/provisioning/#datasources\n  additionalDataSources: []\n  # - name: prometheus-sample\n  #   access: proxy\n  #   basicAuth: true\n  #   basicAuthPassword: pass\n  #   basicAuthUser: daco\n  #   editable: false\n  #   jsonData:\n  #       tlsSkipVerify: true\n  #   orgId: 1\n  #   type: prometheus\n  #   url: https://{{ printf \"%s-prometheus.svc\" .Release.Name }}:9090\n  #   version: 1\n\n  ## Passed to grafana subchart and used by servicemonitor below\n  ##\n  service:\n    portName: http-web\n\n  serviceMonitor:\n    # If true, a ServiceMonitor CRD is created for a prometheus operator\n    # https://github.com/coreos/prometheus-operator\n    #\n    enabled: true\n\n    # Path to use for scraping metrics. Might be different if server.root_url is set\n    # in grafana.ini\n    path: \"/metrics\"\n\n    #  namespace: monitoring  (defaults to use the namespace this chart is deployed to)\n\n    # labels for the ServiceMonitor\n    labels: {}\n\n    # Scrape interval. If not set, the Prometheus default scrape interval is used.\n    #\n    interval: \"\"\n    scheme: http\n    tlsConfig: {}\n    scrapeTimeout: 30s\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n## Flag to disable all the kubernetes component scrapers\n##\nkubernetesServiceMonitors:\n  enabled: true\n\n## Component scraping the kube api server\n##\nkubeApiServer:\n  enabled: true\n  tlsConfig:\n    serverName: kubernetes\n    insecureSkipVerify: false\n  serviceMonitor:\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    jobLabel: component\n    selector:\n      matchLabels:\n        component: apiserver\n        provider: kubernetes\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings:\n      # Drop excessively noisy apiserver buckets.\n      - action: drop\n        regex: apiserver_request_duration_seconds_bucket;(0.15|0.2|0.3|0.35|0.4|0.45|0.6|0.7|0.8|0.9|1.25|1.5|1.75|2|3|3.5|4|4.5|6|7|8|9|15|25|40|50)\n        sourceLabels:\n          - __name__\n          - le\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels:\n    #     - __meta_kubernetes_namespace\n    #     - __meta_kubernetes_service_name\n    #     - __meta_kubernetes_endpoint_port_name\n    #   action: keep\n    #   regex: default;kubernetes;https\n    # - targetLabel: __address__\n    #   replacement: kubernetes.default.svc:443\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping the kubelet and kubelet-hosted cAdvisor\n##\nkubelet:\n  enabled: true\n  namespace: kube-system\n\n  serviceMonitor:\n    ## Attach metadata to discovered targets. Requires Prometheus v2.45 for endpoints created by the operator.\n    ##\n    attachMetadata:\n      node: false\n\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## If true, Prometheus use (respect) labels provided by exporter.\n    ##\n    honorLabels: true\n\n    ## If true, Prometheus ingests metrics with timestamp provided by exporter. If false, Prometheus ingests metrics with timestamp of scrape.\n    ##\n    honorTimestamps: true\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    ## Enable scraping the kubelet over https. For requirements to enable this see\n    ## https://github.com/prometheus-operator/prometheus-operator/issues/926\n    ##\n    https: true\n\n    ## Enable scraping /metrics/cadvisor from kubelet's service\n    ##\n    cAdvisor: true\n\n    ## Enable scraping /metrics/probes from kubelet's service\n    ##\n    probes: true\n\n    ## Enable scraping /metrics/resource from kubelet's service\n    ## This is disabled by default because container metrics are already exposed by cAdvisor\n    ##\n    resource: false\n    # From kubernetes 1.18, /metrics/resource/v1alpha1 renamed to /metrics/resource\n    resourcePath: \"/metrics/resource/v1alpha1\"\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    cAdvisorMetricRelabelings:\n      # Drop less useful container CPU metrics.\n      - sourceLabels: [__name__]\n        action: drop\n        regex: 'container_cpu_(cfs_throttled_seconds_total|load_average_10s|system_seconds_total|user_seconds_total)'\n      # Drop less useful container / always zero filesystem metrics.\n      - sourceLabels: [__name__]\n        action: drop\n        regex: 'container_fs_(io_current|io_time_seconds_total|io_time_weighted_seconds_total|reads_merged_total|sector_reads_total|sector_writes_total|writes_merged_total)'\n      # Drop less useful / always zero container memory metrics.\n      - sourceLabels: [__name__]\n        action: drop\n        regex: 'container_memory_(mapped_file|swap)'\n      # Drop less useful container process metrics.\n      - sourceLabels: [__name__]\n        action: drop\n        regex: 'container_(file_descriptors|tasks_state|threads_max)'\n      # Drop container spec metrics that overlap with kube-state-metrics.\n      - sourceLabels: [__name__]\n        action: drop\n        regex: 'container_spec.*'\n      # Drop cgroup metrics with no pod.\n      - sourceLabels: [id, pod]\n        action: drop\n        regex: '.+;'\n    # - sourceLabels: [__name__, image]\n    #   separator: ;\n    #   regex: container_([a-z_]+);\n    #   replacement: $1\n    #   action: drop\n    # - sourceLabels: [__name__]\n    #   separator: ;\n    #   regex: container_(network_tcp_usage_total|network_udp_usage_total|tasks_state|cpu_load_average_10s)\n    #   replacement: $1\n    #   action: drop\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    probesMetricRelabelings: []\n    # - sourceLabels: [__name__, image]\n    #   separator: ;\n    #   regex: container_([a-z_]+);\n    #   replacement: $1\n    #   action: drop\n    # - sourceLabels: [__name__]\n    #   separator: ;\n    #   regex: container_(network_tcp_usage_total|network_udp_usage_total|tasks_state|cpu_load_average_10s)\n    #   replacement: $1\n    #   action: drop\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    ## metrics_path is required to match upstream rules and charts\n    cAdvisorRelabelings:\n      - action: replace\n        sourceLabels: [__metrics_path__]\n        targetLabel: metrics_path\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    probesRelabelings:\n      - action: replace\n        sourceLabels: [__metrics_path__]\n        targetLabel: metrics_path\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    resourceRelabelings:\n      - action: replace\n        sourceLabels: [__metrics_path__]\n        targetLabel: metrics_path\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - sourceLabels: [__name__, image]\n    #   separator: ;\n    #   regex: container_([a-z_]+);\n    #   replacement: $1\n    #   action: drop\n    # - sourceLabels: [__name__]\n    #   separator: ;\n    #   regex: container_(network_tcp_usage_total|network_udp_usage_total|tasks_state|cpu_load_average_10s)\n    #   replacement: $1\n    #   action: drop\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    ## metrics_path is required to match upstream rules and charts\n    relabelings:\n      - action: replace\n        sourceLabels: [__metrics_path__]\n        targetLabel: metrics_path\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping the kube controller manager\n##\nkubeControllerManager:\n  enabled: true\n\n  ## If your kube controller manager is not deployed as a pod, specify IPs it can be found on\n  ##\n  endpoints: []\n  # - 10.141.4.22\n  # - 10.141.4.23\n  # - 10.141.4.24\n\n  ## If using kubeControllerManager.endpoints only the port and targetPort are used\n  ##\n  service:\n    enabled: true\n    ## If null or unset, the value is determined dynamically based on target Kubernetes version due to change\n    ## of default port in Kubernetes 1.22.\n    ##\n    port: null\n    targetPort: null\n    # selector:\n    #   component: kube-controller-manager\n\n  serviceMonitor:\n    enabled: true\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    ## Enable scraping kube-controller-manager over https.\n    ## Requires proper certs (not self-signed) and delegated authentication/authorization checks.\n    ## If null or unset, the value is determined dynamically based on target Kubernetes version.\n    ##\n    https: null\n\n    # Skip TLS certificate validation when scraping\n    insecureSkipVerify: null\n\n    # Name of the server to use when validating TLS certificate\n    serverName: null\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping coreDns. Use either this or kubeDns\n##\ncoreDns:\n  enabled: true\n  service:\n    port: 9153\n    targetPort: 9153\n    # selector:\n    #   k8s-app: kube-dns\n  serviceMonitor:\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping kubeDns. Use either this or coreDns\n##\nkubeDns:\n  enabled: false\n  service:\n    dnsmasq:\n      port: 10054\n      targetPort: 10054\n    skydns:\n      port: 10055\n      targetPort: 10055\n    # selector:\n    #   k8s-app: kube-dns\n  serviceMonitor:\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    dnsmasqMetricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    dnsmasqRelabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping etcd\n##\nkubeEtcd:\n  enabled: true\n\n  ## If your etcd is not deployed as a pod, specify IPs it can be found on\n  ##\n  endpoints: []\n  # - 10.141.4.22\n  # - 10.141.4.23\n  # - 10.141.4.24\n\n  ## Etcd service. If using kubeEtcd.endpoints only the port and targetPort are used\n  ##\n  service:\n    enabled: true\n    port: 2381\n    targetPort: 2381\n    # selector:\n    #   component: etcd\n\n  ## Configure secure access to the etcd cluster by loading a secret into prometheus and\n  ## specifying security configuration below. For example, with a secret named etcd-client-cert\n  ##\n  ## serviceMonitor:\n  ##   scheme: https\n  ##   insecureSkipVerify: false\n  ##   serverName: localhost\n  ##   caFile: /etc/prometheus/secrets/etcd-client-cert/etcd-ca\n  ##   certFile: /etc/prometheus/secrets/etcd-client-cert/etcd-client\n  ##   keyFile: /etc/prometheus/secrets/etcd-client-cert/etcd-client-key\n  ##\n  serviceMonitor:\n    enabled: true\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n    scheme: http\n    insecureSkipVerify: false\n    serverName: \"\"\n    caFile: \"\"\n    certFile: \"\"\n    keyFile: \"\"\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping kube scheduler\n##\nkubeScheduler:\n  enabled: true\n\n  ## If your kube scheduler is not deployed as a pod, specify IPs it can be found on\n  ##\n  endpoints: []\n  # - 10.141.4.22\n  # - 10.141.4.23\n  # - 10.141.4.24\n\n  ## If using kubeScheduler.endpoints only the port and targetPort are used\n  ##\n  service:\n    enabled: true\n    ## If null or unset, the value is determined dynamically based on target Kubernetes version due to change\n    ## of default port in Kubernetes 1.23.\n    ##\n    port: null\n    targetPort: null\n    # selector:\n    #   component: kube-scheduler\n\n  serviceMonitor:\n    enabled: true\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n    ## Enable scraping kube-scheduler over https.\n    ## Requires proper certs (not self-signed) and delegated authentication/authorization checks.\n    ## If null or unset, the value is determined dynamically based on target Kubernetes version.\n    ##\n    https: null\n\n    ## Skip TLS certificate validation when scraping\n    insecureSkipVerify: null\n\n    ## Name of the server to use when validating TLS certificate\n    serverName: null\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping kube proxy\n##\nkubeProxy:\n  enabled: true\n\n  ## If your kube proxy is not deployed as a pod, specify IPs it can be found on\n  ##\n  endpoints: []\n  # - 10.141.4.22\n  # - 10.141.4.23\n  # - 10.141.4.24\n\n  service:\n    enabled: true\n    port: 10249\n    targetPort: 10249\n    # selector:\n    #   k8s-app: kube-proxy\n\n  serviceMonitor:\n    enabled: true\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    ## Enable scraping kube-proxy over https.\n    ## Requires proper certs (not self-signed) and delegated authentication/authorization checks\n    ##\n    https: false\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n    #  foo: bar\n\n## Component scraping kube state metrics\n##\nkubeStateMetrics:\n  enabled: true\n\n## Configuration for kube-state-metrics subchart\n##\nkube-state-metrics:\n  namespaceOverride: \"\"\n  rbac:\n    create: true\n  releaseLabel: true\n  prometheus:\n    monitor:\n      enabled: true\n\n      ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n      ##\n      interval: \"\"\n\n      ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n      ##\n      sampleLimit: 0\n\n      ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n      ##\n      targetLimit: 0\n\n      ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n      ##\n      labelLimit: 0\n\n      ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n      ##\n      labelNameLengthLimit: 0\n\n      ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n      ##\n      labelValueLengthLimit: 0\n\n      ## Scrape Timeout. If not set, the Prometheus default scrape timeout is used.\n      ##\n      scrapeTimeout: \"\"\n\n      ## proxyUrl: URL of a proxy that should be used for scraping.\n      ##\n      proxyUrl: \"\"\n\n      # Keep labels from scraped data, overriding server-side labels\n      ##\n      honorLabels: true\n\n      ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n      ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n      ##\n      metricRelabelings: []\n      # - action: keep\n      #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n      #   sourceLabels: [__name__]\n\n      ## RelabelConfigs to apply to samples before scraping\n      ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n      ##\n      relabelings: []\n      # - sourceLabels: [__meta_kubernetes_pod_node_name]\n      #   separator: ;\n      #   regex: ^(.*)$\n      #   targetLabel: nodename\n      #   replacement: $1\n      #   action: replace\n\n  selfMonitor:\n    enabled: false\n\n## Deploy node exporter as a daemonset to all nodes\n##\nnodeExporter:\n  enabled: true\n  operatingSystems:\n    linux:\n      enabled: true\n    darwin:\n      enabled: true\n\n## Configuration for prometheus-node-exporter subchart\n##\nprometheus-node-exporter:\n  namespaceOverride: \"\"\n  podLabels:\n    ## Add the 'node-exporter' label to be used by serviceMonitor to match standard common usage in rules and grafana dashboards\n    ##\n    jobLabel: node-exporter\n  releaseLabel: true\n  extraArgs:\n    - --collector.filesystem.mount-points-exclude=^/(dev|proc|sys|var/lib/docker/.+|var/lib/kubelet/.+)($|/)\n    - --collector.filesystem.fs-types-exclude=^(autofs|binfmt_misc|bpf|cgroup2?|configfs|debugfs|devpts|devtmpfs|fusectl|hugetlbfs|iso9660|mqueue|nsfs|overlay|proc|procfs|pstore|rpc_pipefs|securityfs|selinuxfs|squashfs|sysfs|tracefs)$\n  service:\n    portName: http-metrics\n  prometheus:\n    monitor:\n      enabled: true\n\n      jobLabel: jobLabel\n\n      ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n      ##\n      interval: \"\"\n\n      ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n      ##\n      sampleLimit: 0\n\n      ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n      ##\n      targetLimit: 0\n\n      ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n      ##\n      labelLimit: 0\n\n      ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n      ##\n      labelNameLengthLimit: 0\n\n      ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n      ##\n      labelValueLengthLimit: 0\n\n      ## How long until a scrape request times out. If not set, the Prometheus default scape timeout is used.\n      ##\n      scrapeTimeout: \"\"\n\n      ## proxyUrl: URL of a proxy that should be used for scraping.\n      ##\n      proxyUrl: \"\"\n\n      ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n      ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n      ##\n      metricRelabelings: []\n      # - sourceLabels: [__name__]\n      #   separator: ;\n      #   regex: ^node_mountstats_nfs_(event|operations|transport)_.+\n      #   replacement: $1\n      #   action: drop\n\n      ## RelabelConfigs to apply to samples before scraping\n      ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n      ##\n      relabelings: []\n      # - sourceLabels: [__meta_kubernetes_pod_node_name]\n      #   separator: ;\n      #   regex: ^(.*)$\n      #   targetLabel: nodename\n      #   replacement: $1\n      #   action: replace\n  rbac:\n    ## If true, create PSPs for node-exporter\n    ##\n    pspEnabled: false\n\n## Manages Prometheus and Alertmanager components\n##\nprometheusOperator:\n  enabled: true\n\n  ## Number of old replicasets to retain ##\n  ## The default value is 10, 0 will garbage-collect old replicasets ##\n  revisionHistoryLimit: 10\n\n  ## Prometheus-Operator v0.39.0 and later support TLS natively.\n  ##\n  tls:\n    enabled: true\n    # Value must match version names from https://golang.org/pkg/crypto/tls/#pkg-constants\n    tlsMinVersion: VersionTLS13\n    # The default webhook port is 10250 in order to work out-of-the-box in GKE private clusters and avoid adding firewall rules.\n    internalPort: 10250\n\n  ## Admission webhook support for PrometheusRules resources added in Prometheus Operator 0.30 can be enabled to prevent incorrectly formatted\n  ## rules from making their way into prometheus and potentially preventing the container from starting\n  admissionWebhooks:\n    ## Valid values: Fail, Ignore, IgnoreOnInstallOnly\n    ## IgnoreOnInstallOnly - If Release.IsInstall returns \"true\", set \"Ignore\" otherwise \"Fail\"\n    failurePolicy: \"\"\n    ## The default timeoutSeconds is 10 and the maximum value is 30.\n    timeoutSeconds: 10\n    enabled: true\n    ## A PEM encoded CA bundle which will be used to validate the webhook's server certificate.\n    ## If unspecified, system trust roots on the apiserver are used.\n    caBundle: \"\"\n    ## If enabled, generate a self-signed certificate, then patch the webhook configurations with the generated data.\n    ## On chart upgrades (or if the secret exists) the cert will not be re-generated. You can use this to provide your own\n    ## certs ahead of time if you wish.\n    ##\n    annotations: {}\n    #   argocd.argoproj.io/hook: PreSync\n    #   argocd.argoproj.io/hook-delete-policy: HookSucceeded\n    patch:\n      enabled: true\n      image:\n        registry: registry.k8s.io\n        repository: ingress-nginx/kube-webhook-certgen\n        tag: v20221220-controller-v1.5.1-58-g787ea74b6\n        sha: \"\"\n        pullPolicy: IfNotPresent\n      resources: {}\n      ## Provide a priority class name to the webhook patching job\n      ##\n      priorityClassName: \"\"\n      annotations: {}\n      #   argocd.argoproj.io/hook: PreSync\n      #   argocd.argoproj.io/hook-delete-policy: HookSucceeded\n      podAnnotations: {}\n      nodeSelector: {}\n      affinity: {}\n      tolerations: []\n\n      ## SecurityContext holds pod-level security attributes and common container settings.\n      ## This defaults to non root user with uid 2000 and gid 2000. *v1.PodSecurityContext  false\n      ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n      ##\n      securityContext:\n        runAsGroup: 2000\n        runAsNonRoot: true\n        runAsUser: 2000\n        seccompProfile:\n          type: RuntimeDefault\n\n    # Security context for create job container\n    createSecretJob:\n      securityContext:\n        allowPrivilegeEscalation: false\n        readOnlyRootFilesystem: true\n        capabilities:\n          drop:\n          - ALL\n\n      # Security context for patch job container\n    patchWebhookJob:\n      securityContext:\n        allowPrivilegeEscalation: false\n        readOnlyRootFilesystem: true\n        capabilities:\n          drop:\n          - ALL\n\n    # Use certmanager to generate webhook certs\n    certManager:\n      enabled: false\n      # self-signed root certificate\n      rootCert:\n        duration: \"\"  # default to be 5y\n      admissionCert:\n        duration: \"\"  # default to be 1y\n      # issuerRef:\n      #   name: \"issuer\"\n      #   kind: \"ClusterIssuer\"\n\n  ## Namespaces to scope the interaction of the Prometheus Operator and the apiserver (allow list).\n  ## This is mutually exclusive with denyNamespaces. Setting this to an empty object will disable the configuration\n  ##\n  namespaces: {}\n    # releaseNamespace: true\n    # additional:\n    # - kube-system\n\n  ## Namespaces not to scope the interaction of the Prometheus Operator (deny list).\n  ##\n  denyNamespaces: []\n\n  ## Filter namespaces to look for prometheus-operator custom resources\n  ##\n  alertmanagerInstanceNamespaces: []\n  alertmanagerConfigNamespaces: []\n  prometheusInstanceNamespaces: []\n  thanosRulerInstanceNamespaces: []\n\n  ## The clusterDomain value will be added to the cluster.peer option of the alertmanager.\n  ## Without this specified option cluster.peer will have value alertmanager-monitoring-alertmanager-0.alertmanager-operated:9094 (default value)\n  ## With this specified option cluster.peer will have value alertmanager-monitoring-alertmanager-0.alertmanager-operated.namespace.svc.cluster-domain:9094\n  ##\n  # clusterDomain: \"cluster.local\"\n\n  networkPolicy:\n    ## Enable creation of NetworkPolicy resources.\n    ##\n    enabled: false\n\n    ## Flavor of the network policy to use.\n    #  Can be:\n    #  * kubernetes for networking.k8s.io/v1/NetworkPolicy\n    #  * cilium     for cilium.io/v2/CiliumNetworkPolicy\n    flavor: kubernetes\n\n    # cilium:\n    #   egress:\n\n    ## match labels used in selector\n    # matchLabels: {}\n\n  ## Service account for Prometheus Operator to use.\n  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\n  ##\n  serviceAccount:\n    create: true\n    name: \"\"\n\n  ## Configuration for Prometheus operator service\n  ##\n  service:\n    annotations: {}\n    labels: {}\n    clusterIP: \"\"\n\n  ## Port to expose on each node\n  ## Only used if service.type is 'NodePort'\n  ##\n    nodePort: 30080\n\n    nodePortTls: 30443\n\n  ## Additional ports to open for Prometheus operator service\n  ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#multi-port-services\n  ##\n    additionalPorts: []\n\n  ## Loadbalancer IP\n  ## Only use if service.type is \"LoadBalancer\"\n  ##\n    loadBalancerIP: \"\"\n    loadBalancerSourceRanges: []\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n  ## Service type\n  ## NodePort, ClusterIP, LoadBalancer\n  ##\n    type: ClusterIP\n\n    ## List of IP addresses at which the Prometheus server service is available\n    ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n    ##\n    externalIPs: []\n\n  # ## Labels to add to the operator deployment\n  # ##\n  labels: {}\n\n  ## Annotations to add to the operator deployment\n  ##\n  annotations: {}\n\n  ## Labels to add to the operator pod\n  ##\n  podLabels: {}\n\n  ## Annotations to add to the operator pod\n  ##\n  podAnnotations: {}\n\n  ## Assign a PriorityClassName to pods if set\n  # priorityClassName: \"\"\n\n  ## Define Log Format\n  # Use logfmt (default) or json logging\n  # logFormat: logfmt\n\n  ## Decrease log verbosity to errors only\n  # logLevel: error\n\n  ## If true, the operator will create and maintain a service for scraping kubelets\n  ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/helm/prometheus-operator/README.md\n  ##\n  kubeletService:\n    enabled: true\n    namespace: kube-system\n    ## Use '{{ template \"kube-prometheus-stack.fullname\" . }}-kubelet' by default\n    name: \"\"\n\n  ## Create a servicemonitor for the operator\n  ##\n  serviceMonitor:\n    ## Labels for ServiceMonitor\n    additionalLabels: {}\n\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## Scrape timeout. If not set, the Prometheus default scrape timeout is used.\n    scrapeTimeout: \"\"\n    selfMonitor: true\n\n    ## Metric relabel configs to apply to samples before ingestion.\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    #   relabel configs to apply to samples before ingestion.\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n  ## Resource limits \u0026 requests\n  ##\n  resources: {}\n  # limits:\n  #   cpu: 200m\n  #   memory: 200Mi\n  # requests:\n  #   cpu: 100m\n  #   memory: 100Mi\n\n  # Required for use in managed kubernetes clusters (such as AWS EKS) with custom CNI (such as calico),\n  # because control-plane managed by AWS cannot communicate with pods' IP CIDR and admission webhooks are not working\n  ##\n  hostNetwork: false\n\n  ## Define which Nodes the Pods are scheduled on.\n  ## ref: https://kubernetes.io/docs/user-guide/node-selection/\n  ##\n  nodeSelector: {}\n\n  ## Tolerations for use with node taints\n  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\n  ##\n  tolerations: []\n  # - key: \"key\"\n  #   operator: \"Equal\"\n  #   value: \"value\"\n  #   effect: \"NoSchedule\"\n\n  ## Assign custom affinity rules to the prometheus operator\n  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n  ##\n  affinity: {}\n    # nodeAffinity:\n    #   requiredDuringSchedulingIgnoredDuringExecution:\n    #     nodeSelectorTerms:\n    #     - matchExpressions:\n    #       - key: kubernetes.io/e2e-az-name\n    #         operator: In\n    #         values:\n    #         - e2e-az1\n    #         - e2e-az2\n  dnsConfig: {}\n    # nameservers:\n    #   - 1.2.3.4\n    # searches:\n    #   - ns1.svc.cluster-domain.example\n    #   - my.dns.search.suffix\n    # options:\n    #   - name: ndots\n    #     value: \"2\"\n  #   - name: edns0\n  securityContext:\n    fsGroup: 65534\n    runAsGroup: 65534\n    runAsNonRoot: true\n    runAsUser: 65534\n    seccompProfile:\n      type: RuntimeDefault\n\n  ## Container-specific security context configuration\n  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n  ##\n  containerSecurityContext:\n    allowPrivilegeEscalation: false\n    readOnlyRootFilesystem: true\n    capabilities:\n      drop:\n      - ALL\n\n  # Enable vertical pod autoscaler support for prometheus-operator\n  verticalPodAutoscaler:\n    enabled: false\n\n    # Recommender responsible for generating recommendation for the object.\n    # List should be empty (then the default recommender will generate the recommendation)\n    # or contain exactly one recommender.\n    # recommenders:\n    # - name: custom-recommender-performance\n\n    # List of resources that the vertical pod autoscaler can control. Defaults to cpu and memory\n    controlledResources: []\n    # Specifies which resource values should be controlled: RequestsOnly or RequestsAndLimits.\n    # controlledValues: RequestsAndLimits\n\n    # Define the max allowed resources for the pod\n    maxAllowed: {}\n    # cpu: 200m\n    # memory: 100Mi\n    # Define the min allowed resources for the pod\n    minAllowed: {}\n    # cpu: 200m\n    # memory: 100Mi\n\n    updatePolicy:\n      # Specifies minimal number of replicas which need to be alive for VPA Updater to attempt pod eviction\n      # minReplicas: 1\n      # Specifies whether recommended updates are applied when a Pod is started and whether recommended updates\n      # are applied during the life of a Pod. Possible values are \"Off\", \"Initial\", \"Recreate\", and \"Auto\".\n      updateMode: Auto\n\n  ## Prometheus-operator image\n  ##\n  image:\n    registry: quay.io\n    repository: prometheus-operator/prometheus-operator\n    # if not set appVersion field from Chart.yaml is used\n    tag: \"\"\n    sha: \"\"\n    pullPolicy: IfNotPresent\n\n  ## Prometheus image to use for prometheuses managed by the operator\n  ##\n  # prometheusDefaultBaseImage: prometheus/prometheus\n\n  ## Prometheus image registry to use for prometheuses managed by the operator\n  ##\n  # prometheusDefaultBaseImageRegistry: quay.io\n\n  ## Alertmanager image to use for alertmanagers managed by the operator\n  ##\n  # alertmanagerDefaultBaseImage: prometheus/alertmanager\n\n  ## Alertmanager image registry to use for alertmanagers managed by the operator\n  ##\n  # alertmanagerDefaultBaseImageRegistry: quay.io\n\n  ## Prometheus-config-reloader\n  ##\n  prometheusConfigReloader:\n    image:\n      registry: quay.io\n      repository: prometheus-operator/prometheus-config-reloader\n      # if not set appVersion field from Chart.yaml is used\n      tag: \"\"\n      sha: \"\"\n\n    # add prometheus config reloader liveness and readiness probe. Default: false\n    enableProbe: false\n\n    # resource config for prometheusConfigReloader\n    resources: {}\n      # requests:\n      #   cpu: 200m\n      #   memory: 50Mi\n      # limits:\n      #   cpu: 200m\n      #   memory: 50Mi\n\n  ## Thanos side-car image when configured\n  ##\n  thanosImage:\n    registry: quay.io\n    repository: thanos/thanos\n    tag: v0.32.5\n    sha: \"\"\n\n  ## Set a Label Selector to filter watched prometheus and prometheusAgent\n  ##\n  prometheusInstanceSelector: \"\"\n\n  ## Set a Label Selector to filter watched alertmanager\n  ##\n  alertmanagerInstanceSelector: \"\"\n\n  ## Set a Label Selector to filter watched thanosRuler\n  thanosRulerInstanceSelector: \"\"\n\n  ## Set a Field Selector to filter watched secrets\n  ##\n  secretFieldSelector: \"type!=kubernetes.io/dockercfg,type!=kubernetes.io/service-account-token,type!=helm.sh/release.v1\"\n\n## Deploy a Prometheus instance\n##\nprometheus:\n  enabled: true\n\n  ## Toggle prometheus into agent mode\n  ## Note many of features described below (e.g. rules, query, alerting, remote read, thanos) will not work in agent mode.\n  ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/designs/prometheus-agent.md\n  ##\n  agentMode: false\n\n  ## Annotations for Prometheus\n  ##\n  annotations: {}\n\n  ## Configure network policy for the prometheus\n  networkPolicy:\n    enabled: false\n\n    ## Flavor of the network policy to use.\n    #  Can be:\n    #  * kubernetes for networking.k8s.io/v1/NetworkPolicy\n    #  * cilium     for cilium.io/v2/CiliumNetworkPolicy\n    flavor: kubernetes\n\n    # cilium:\n    #   endpointSelector:\n    #   egress:\n    #   ingress:\n\n    # egress:\n    # - {}\n    # ingress:\n    # - {}\n    # podSelector:\n    #   matchLabels:\n    #     app: prometheus\n\n  ## Service account for Prometheuses to use.\n  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\n  ##\n  serviceAccount:\n    create: true\n    name: \"\"\n    annotations: {}\n\n  # Service for thanos service discovery on sidecar\n  # Enable this can make Thanos Query can use\n  # Thanos sidecar on prometheus nodes\n  thanosService:\n    enabled: false\n    annotations: {}\n    labels: {}\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n    ## Service type\n    ##\n    type: ClusterIP\n\n    ## gRPC port config\n    portName: grpc\n    port: 10901\n    targetPort: \"grpc\"\n\n    ## HTTP port config (for metrics)\n    httpPortName: http\n    httpPort: 10902\n    targetHttpPort: \"http\"\n\n    ## ClusterIP to assign\n    # Default is to make this a headless service (\"None\")\n    clusterIP: \"None\"\n\n    ## Port to expose on each node, if service type is NodePort\n    ##\n    nodePort: 30901\n    httpNodePort: 30902\n\n  # ServiceMonitor to scrape Sidecar metrics\n  # Needs thanosService to be enabled as well\n  thanosServiceMonitor:\n    enabled: false\n    interval: \"\"\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n\n    ## scheme: HTTP scheme to use for scraping. Can be used with `tlsConfig` for example if using istio mTLS.\n    scheme: \"\"\n\n    ## tlsConfig: TLS configuration to use when scraping the endpoint. For example if using istio mTLS.\n    ## Of type: https://github.com/coreos/prometheus-operator/blob/main/Documentation/api.md#tlsconfig\n    tlsConfig: {}\n\n    bearerTokenFile:\n\n    ## Metric relabel configs to apply to samples before ingestion.\n    metricRelabelings: []\n\n    ## relabel configs to apply to samples before ingestion.\n    relabelings: []\n\n  # Service for external access to sidecar\n  # Enabling this creates a service to expose thanos-sidecar outside the cluster.\n  thanosServiceExternal:\n    enabled: false\n    annotations: {}\n    labels: {}\n    loadBalancerIP: \"\"\n    loadBalancerSourceRanges: []\n\n    ## gRPC port config\n    portName: grpc\n    port: 10901\n    targetPort: \"grpc\"\n\n    ## HTTP port config (for metrics)\n    httpPortName: http\n    httpPort: 10902\n    targetHttpPort: \"http\"\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n    ## Service type\n    ##\n    type: LoadBalancer\n\n    ## Port to expose on each node\n    ##\n    nodePort: 30901\n    httpNodePort: 30902\n\n  ## Configuration for Prometheus service\n  ##\n  service:\n    annotations: {}\n    labels: {}\n    clusterIP: \"\"\n\n    ## Port for Prometheus Service to listen on\n    ##\n    port: 9090\n\n    ## To be used with a proxy extraContainer port\n    targetPort: 9090\n\n    ## List of IP addresses at which the Prometheus server service is available\n    ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n    ##\n    externalIPs: []\n\n    ## Port to expose on each node\n    ## Only used if service.type is 'NodePort'\n    ##\n    nodePort: 30090\n\n    ## Loadbalancer IP\n    ## Only use if service.type is \"LoadBalancer\"\n    loadBalancerIP: \"\"\n    loadBalancerSourceRanges: []\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n    ## Service type\n    ##\n    type: ClusterIP\n\n    ## Additional ports to open for Prometheus service\n    ##\n    additionalPorts: []\n    # additionalPorts:\n    # - name: oauth-proxy\n    #   port: 8081\n    #   targetPort: 8081\n    # - name: oauth-metrics\n    #   port: 8082\n    #   targetPort: 8082\n\n    ## Consider that all endpoints are considered \"ready\" even if the Pods themselves are not\n    ## Ref: https://kubernetes.io/docs/reference/kubernetes-api/service-resources/service-v1/#ServiceSpec\n    publishNotReadyAddresses: false\n\n    sessionAffinity: \"\"\n\n  ## Configuration for creating a separate Service for each statefulset Prometheus replica\n  ##\n  servicePerReplica:\n    enabled: false\n    annotations: {}\n\n    ## Port for Prometheus Service per replica to listen on\n    ##\n    port: 9090\n\n    ## To be used with a proxy extraContainer port\n    targetPort: 9090\n\n    ## Port to expose on each node\n    ## Only used if servicePerReplica.type is 'NodePort'\n    ##\n    nodePort: 30091\n\n    ## Loadbalancer source IP ranges\n    ## Only used if servicePerReplica.type is \"LoadBalancer\"\n    loadBalancerSourceRanges: []\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n    ## Service type\n    ##\n    type: ClusterIP\n\n  ## Configure pod disruption budgets for Prometheus\n  ## ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/#specifying-a-poddisruptionbudget\n  ## This configuration is immutable once created and will require the PDB to be deleted to be changed\n  ## https://github.com/kubernetes/kubernetes/issues/45398\n  ##\n  podDisruptionBudget:\n    enabled: false\n    minAvailable: 1\n    maxUnavailable: \"\"\n\n  # Ingress exposes thanos sidecar outside the cluster\n  thanosIngress:\n    enabled: false\n\n    # For Kubernetes \u003e= 1.18 you should specify the ingress-controller via the field ingressClassName\n    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress\n    # ingressClassName: nginx\n\n    annotations: {}\n    labels: {}\n    servicePort: 10901\n\n    ## Port to expose on each node\n    ## Only used if service.type is 'NodePort'\n    ##\n    nodePort: 30901\n\n    ## Hosts must be provided if Ingress is enabled.\n    ##\n    hosts: []\n      # - thanos-gateway.domain.com\n\n    ## Paths to use for ingress rules\n    ##\n    paths: []\n    # - /\n\n    ## For Kubernetes \u003e= 1.18 you should specify the pathType (determines how Ingress paths should be matched)\n    ## See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#better-path-matching-with-path-types\n    # pathType: ImplementationSpecific\n\n    ## TLS configuration for Thanos Ingress\n    ## Secret must be manually created in the namespace\n    ##\n    tls: []\n    # - secretName: thanos-gateway-tls\n    #   hosts:\n    #   - thanos-gateway.domain.com\n    #\n\n  ## ExtraSecret can be used to store various data in an extra secret\n  ## (use it for example to store hashed basic auth credentials)\n  extraSecret:\n    ## if not set, name will be auto generated\n    # name: \"\"\n    annotations: {}\n    data: {}\n  #   auth: |\n  #     foo:$apr1$OFG3Xybp$ckL0FHDAkoXYIlH9.cysT0\n  #     someoneelse:$apr1$DMZX2Z4q$6SbQIfyuLQd.xmo/P0m2c.\n\n  ingress:\n    enabled: false\n\n    # For Kubernetes \u003e= 1.18 you should specify the ingress-controller via the field ingressClassName\n    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress\n    # ingressClassName: nginx\n\n    annotations: {}\n    labels: {}\n\n    ## Redirect ingress to an additional defined port on the service\n    # servicePort: 8081\n\n    ## Hostnames.\n    ## Must be provided if Ingress is enabled.\n    ##\n    # hosts:\n    #   - prometheus.domain.com\n    hosts: []\n\n    ## Paths to use for ingress rules - one path should match the prometheusSpec.routePrefix\n    ##\n    paths: []\n    # - /\n\n    ## For Kubernetes \u003e= 1.18 you should specify the pathType (determines how Ingress paths should be matched)\n    ## See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#better-path-matching-with-path-types\n    # pathType: ImplementationSpecific\n\n    ## TLS configuration for Prometheus Ingress\n    ## Secret must be manually created in the namespace\n    ##\n    tls: []\n      # - secretName: prometheus-general-tls\n      #   hosts:\n      #     - prometheus.example.com\n\n  ## Configuration for creating an Ingress that will map to each Prometheus replica service\n  ## prometheus.servicePerReplica must be enabled\n  ##\n  ingressPerReplica:\n    enabled: false\n\n    # For Kubernetes \u003e= 1.18 you should specify the ingress-controller via the field ingressClassName\n    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress\n    # ingressClassName: nginx\n\n    annotations: {}\n    labels: {}\n\n    ## Final form of the hostname for each per replica ingress is\n    ## {{ ingressPerReplica.hostPrefix }}-{{ $replicaNumber }}.{{ ingressPerReplica.hostDomain }}\n    ##\n    ## Prefix for the per replica ingress that will have `-$replicaNumber`\n    ## appended to the end\n    hostPrefix: \"\"\n    ## Domain that will be used for the per replica ingress\n    hostDomain: \"\"\n\n    ## Paths to use for ingress rules\n    ##\n    paths: []\n    # - /\n\n    ## For Kubernetes \u003e= 1.18 you should specify the pathType (determines how Ingress paths should be matched)\n    ## See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#better-path-matching-with-path-types\n    # pathType: ImplementationSpecific\n\n    ## Secret name containing the TLS certificate for Prometheus per replica ingress\n    ## Secret must be manually created in the namespace\n    tlsSecretName: \"\"\n\n    ## Separated secret for each per replica Ingress. Can be used together with cert-manager\n    ##\n    tlsSecretPerReplica:\n      enabled: false\n      ## Final form of the secret for each per replica ingress is\n      ## {{ tlsSecretPerReplica.prefix }}-{{ $replicaNumber }}\n      ##\n      prefix: \"prometheus\"\n\n  ## Configure additional options for default pod security policy for Prometheus\n  ## ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/\n  podSecurityPolicy:\n    allowedCapabilities: []\n    allowedHostPaths: []\n    volumes: []\n\n  serviceMonitor:\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n    selfMonitor: true\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## scheme: HTTP scheme to use for scraping. Can be used with `tlsConfig` for example if using istio mTLS.\n    scheme: \"\"\n\n    ## tlsConfig: TLS configuration to use when scraping the endpoint. For example if using istio mTLS.\n    ## Of type: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#tlsconfig\n    tlsConfig: {}\n\n    bearerTokenFile:\n\n    ## Metric relabel configs to apply to samples before ingestion.\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    #   relabel configs to apply to samples before ingestion.\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional Endpoints\n    ##\n    additionalEndpoints: []\n    # - port: oauth-metrics\n    #   path: /metrics\n\n  ## Settings affecting prometheusSpec\n  ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#prometheusspec\n  ##\n  prometheusSpec:\n    ## If true, pass --storage.tsdb.max-block-duration=2h to prometheus. This is already done if using Thanos\n    ##\n    disableCompaction: false\n    ## APIServerConfig\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#apiserverconfig\n    ##\n    apiserverConfig: {}\n\n    ## Allows setting additional arguments for the Prometheus container\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#monitoring.coreos.com/v1.Prometheus\n    additionalArgs: []\n\n    ## Interval between consecutive scrapes.\n    ## Defaults to 30s.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/release-0.44/pkg/prometheus/promcfg.go#L180-L183\n    ##\n    scrapeInterval: \"\"\n\n    ## Number of seconds to wait for target to respond before erroring\n    ##\n    scrapeTimeout: \"\"\n\n    ## Interval between consecutive evaluations.\n    ##\n    evaluationInterval: \"\"\n\n    ## ListenLocal makes the Prometheus server listen on loopback, so that it does not bind against the Pod IP.\n    ##\n    listenLocal: false\n\n    ## EnableAdminAPI enables Prometheus the administrative HTTP API which includes functionality such as deleting time series.\n    ## This is disabled by default.\n    ## ref: https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis\n    ##\n    enableAdminAPI: false\n\n    ## Sets version of Prometheus overriding the Prometheus version as derived\n    ## from the image tag. Useful in cases where the tag does not follow semver v2.\n    version: \"\"\n\n    ## WebTLSConfig defines the TLS parameters for HTTPS\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#webtlsconfig\n    web: {}\n\n    ## Exemplars related settings that are runtime reloadable.\n    ## It requires to enable the exemplar storage feature to be effective.\n    exemplars: \"\"\n      ## Maximum number of exemplars stored in memory for all series.\n      ## If not set, Prometheus uses its default value.\n      ## A value of zero or less than zero disables the storage.\n      # maxSize: 100000\n\n    # EnableFeatures API enables access to Prometheus disabled features.\n    # ref: https://prometheus.io/docs/prometheus/latest/disabled_features/\n    enableFeatures: []\n    # - exemplar-storage\n\n    ## Image of Prometheus.\n    ##\n    image:\n      registry: quay.io\n      repository: prometheus/prometheus\n      tag: v2.47.1\n      sha: \"\"\n\n    ## Tolerations for use with node taints\n    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\n    ##\n    tolerations: []\n    #  - key: \"key\"\n    #    operator: \"Equal\"\n    #    value: \"value\"\n    #    effect: \"NoSchedule\"\n\n    ## If specified, the pod's topology spread constraints.\n    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\n    ##\n    topologySpreadConstraints: []\n    # - maxSkew: 1\n    #   topologyKey: topology.kubernetes.io/zone\n    #   whenUnsatisfiable: DoNotSchedule\n    #   labelSelector:\n    #     matchLabels:\n    #       app: prometheus\n\n    ## Alertmanagers to which alerts will be sent\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#alertmanagerendpoints\n    ##\n    ## Default configuration will connect to the alertmanager deployed as part of this release\n    ##\n    alertingEndpoints: []\n    # - name: \"\"\n    #   namespace: \"\"\n    #   port: http\n    #   scheme: http\n    #   pathPrefix: \"\"\n    #   tlsConfig: {}\n    #   bearerTokenFile: \"\"\n    #   apiVersion: v2\n\n    ## External labels to add to any time series or alerts when communicating with external systems\n    ##\n    externalLabels: {}\n\n    ## enable --web.enable-remote-write-receiver flag on prometheus-server\n    ##\n    enableRemoteWriteReceiver: false\n\n    ## Name of the external label used to denote replica name\n    ##\n    replicaExternalLabelName: \"\"\n\n    ## If true, the Operator won't add the external label used to denote replica name\n    ##\n    replicaExternalLabelNameClear: false\n\n    ## Name of the external label used to denote Prometheus instance name\n    ##\n    prometheusExternalLabelName: \"\"\n\n    ## If true, the Operator won't add the external label used to denote Prometheus instance name\n    ##\n    prometheusExternalLabelNameClear: false\n\n    ## External URL at which Prometheus will be reachable.\n    ##\n    externalUrl: \"\"\n\n    ## Define which Nodes the Pods are scheduled on.\n    ## ref: https://kubernetes.io/docs/user-guide/node-selection/\n    ##\n    nodeSelector: {}\n\n    ## Secrets is a list of Secrets in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods.\n    ## The Secrets are mounted into /etc/prometheus/secrets/. Secrets changes after initial creation of a Prometheus object are not\n    ## reflected in the running Pods. To change the secrets mounted into the Prometheus Pods, the object must be deleted and recreated\n    ## with the new list of secrets.\n    ##\n    secrets: []\n\n    ## ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods.\n    ## The ConfigMaps are mounted into /etc/prometheus/configmaps/.\n    ##\n    configMaps: []\n\n    ## QuerySpec defines the query command line flags when starting Prometheus.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#queryspec\n    ##\n    query: {}\n\n    ## If nil, select own namespace. Namespaces to be selected for PrometheusRules discovery.\n    ruleNamespaceSelector: {}\n    ## Example which selects PrometheusRules in namespaces with label \"prometheus\" set to \"somelabel\"\n    # ruleNamespaceSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## If true, a nil or {} value for prometheus.prometheusSpec.ruleSelector will cause the\n    ## prometheus resource to be created with selectors based on values in the helm deployment,\n    ## which will also match the PrometheusRule resources created\n    ##\n    ruleSelectorNilUsesHelmValues: true\n\n    ## PrometheusRules to be selected for target discovery.\n    ## If {}, select all PrometheusRules\n    ##\n    ruleSelector: {}\n    ## Example which select all PrometheusRules resources\n    ## with label \"prometheus\" with values any of \"example-rules\" or \"example-rules-2\"\n    # ruleSelector:\n    #   matchExpressions:\n    #     - key: prometheus\n    #       operator: In\n    #       values:\n    #         - example-rules\n    #         - example-rules-2\n    #\n    ## Example which select all PrometheusRules resources with label \"role\" set to \"example-rules\"\n    # ruleSelector:\n    #   matchLabels:\n    #     role: example-rules\n\n    ## If true, a nil or {} value for prometheus.prometheusSpec.serviceMonitorSelector will cause the\n    ## prometheus resource to be created with selectors based on values in the helm deployment,\n    ## which will also match the servicemonitors created\n    ##\n    serviceMonitorSelectorNilUsesHelmValues: true\n\n    ## ServiceMonitors to be selected for target discovery.\n    ## If {}, select all ServiceMonitors\n    ##\n    serviceMonitorSelector: {}\n    ## Example which selects ServiceMonitors with label \"prometheus\" set to \"somelabel\"\n    # serviceMonitorSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## Namespaces to be selected for ServiceMonitor discovery.\n    ##\n    serviceMonitorNamespaceSelector: {}\n    ## Example which selects ServiceMonitors in namespaces with label \"prometheus\" set to \"somelabel\"\n    # serviceMonitorNamespaceSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## If true, a nil or {} value for prometheus.prometheusSpec.podMonitorSelector will cause the\n    ## prometheus resource to be created with selectors based on values in the helm deployment,\n    ## which will also match the podmonitors created\n    ##\n    podMonitorSelectorNilUsesHelmValues: true\n\n    ## PodMonitors to be selected for target discovery.\n    ## If {}, select all PodMonitors\n    ##\n    podMonitorSelector: {}\n    ## Example which selects PodMonitors with label \"prometheus\" set to \"somelabel\"\n    # podMonitorSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## If nil, select own namespace. Namespaces to be selected for PodMonitor discovery.\n    podMonitorNamespaceSelector: {}\n    ## Example which selects PodMonitor in namespaces with label \"prometheus\" set to \"somelabel\"\n    # podMonitorNamespaceSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## If true, a nil or {} value for prometheus.prometheusSpec.probeSelector will cause the\n    ## prometheus resource to be created with selectors based on values in the helm deployment,\n    ## which will also match the probes created\n    ##\n    probeSelectorNilUsesHelmValues: true\n\n    ## Probes to be selected for target discovery.\n    ## If {}, select all Probes\n    ##\n    probeSelector: {}\n    ## Example which selects Probes with label \"prometheus\" set to \"somelabel\"\n    # probeSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## If nil, select own namespace. Namespaces to be selected for Probe discovery.\n    probeNamespaceSelector: {}\n    ## Example which selects Probe in namespaces with label \"prometheus\" set to \"somelabel\"\n    # probeNamespaceSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## If true, a nil or {} value for prometheus.prometheusSpec.scrapeConfigSelector will cause the\n    ## prometheus resource to be created with selectors based on values in the helm deployment,\n    ## which will also match the scrapeConfigs created\n    ##\n    scrapeConfigSelectorNilUsesHelmValues: true\n\n    ## scrapeConfigs to be selected for target discovery.\n    ## If {}, select all scrapeConfigs\n    ##\n    scrapeConfigSelector: {}\n    ## Example which selects scrapeConfigs with label \"prometheus\" set to \"somelabel\"\n    # scrapeConfig:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## If nil, select own namespace. Namespaces to be selected for scrapeConfig discovery.\n    scrapeConfigNamespaceSelector: {}\n    ## Example which selects scrapeConfig in namespaces with label \"prometheus\" set to \"somelabel\"\n    # scrapeConfigNamespaceSelector:\n    #   matchLabels:\n    #     prometheus: somelabel\n\n    ## How long to retain metrics\n    ##\n    retention: 10d\n\n    ## Maximum size of metrics\n    ##\n    retentionSize: \"\"\n\n    ## Allow out-of-order/out-of-bounds samples ingested into Prometheus for a specified duration\n    ## See https://prometheus.io/docs/prometheus/latest/configuration/configuration/#tsdb\n    tsdb:\n      outOfOrderTimeWindow: 0s\n\n    ## Enable compression of the write-ahead log using Snappy.\n    ##\n    walCompression: true\n\n    ## If true, the Operator won't process any Prometheus configuration changes\n    ##\n    paused: false\n\n    ## Number of replicas of each shard to deploy for a Prometheus deployment.\n    ## Number of replicas multiplied by shards is the total number of Pods created.\n    ##\n    replicas: 1\n\n    ## EXPERIMENTAL: Number of shards to distribute targets onto.\n    ## Number of replicas multiplied by shards is the total number of Pods created.\n    ## Note that scaling down shards will not reshard data onto remaining instances, it must be manually moved.\n    ## Increasing shards will not reshard data either but it will continue to be available from the same instances.\n    ## To query globally use Thanos sidecar and Thanos querier or remote write data to a central location.\n    ## Sharding is done on the content of the `__address__` target meta-label.\n    ##\n    shards: 1\n\n    ## Log level for Prometheus be configured in\n    ##\n    logLevel: info\n\n    ## Log format for Prometheus be configured in\n    ##\n    logFormat: logfmt\n\n    ## Prefix used to register routes, overriding externalUrl route.\n    ## Useful for proxies that rewrite URLs.\n    ##\n    routePrefix: /\n\n    ## Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata\n    ## Metadata Labels and Annotations gets propagated to the prometheus pods.\n    ##\n    podMetadata: {}\n    # labels:\n    #   app: prometheus\n    #   k8s-app: prometheus\n\n    ## Pod anti-affinity can prevent the scheduler from placing Prometheus replicas on the same node.\n    ## The default value \"soft\" means that the scheduler should *prefer* to not schedule two replica pods onto the same node but no guarantee is provided.\n    ## The value \"hard\" means that the scheduler is *required* to not schedule two replica pods onto the same node.\n    ## The value \"\" will disable pod anti-affinity so that no anti-affinity rules will be configured.\n    podAntiAffinity: \"\"\n\n    ## If anti-affinity is enabled sets the topologyKey to use for anti-affinity.\n    ## This can be changed to, for example, failure-domain.beta.kubernetes.io/zone\n    ##\n    podAntiAffinityTopologyKey: kubernetes.io/hostname\n\n    ## Assign custom affinity rules to the prometheus instance\n    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n    ##\n    affinity: {}\n    # nodeAffinity:\n    #   requiredDuringSchedulingIgnoredDuringExecution:\n    #     nodeSelectorTerms:\n    #     - matchExpressions:\n    #       - key: kubernetes.io/e2e-az-name\n    #         operator: In\n    #         values:\n    #         - e2e-az1\n    #         - e2e-az2\n\n    ## The remote_read spec configuration for Prometheus.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#remotereadspec\n    remoteRead: []\n    # - url: http://remote1/read\n    ## additionalRemoteRead is appended to remoteRead\n    additionalRemoteRead: []\n\n    ## The remote_write spec configuration for Prometheus.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#remotewritespec\n    remoteWrite: []\n    # - url: http://remote1/push\n    ## additionalRemoteWrite is appended to remoteWrite\n    additionalRemoteWrite: []\n\n    ## Enable/Disable Grafana dashboards provisioning for prometheus remote write feature\n    remoteWriteDashboards: false\n\n    ## Resource limits \u0026 requests\n    ##\n    resources: {}\n    # requests:\n    #   memory: 400Mi\n\n    ## Prometheus StorageSpec for persistent data\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/user-guides/storage.md\n    ##\n    storageSpec: {}\n    ## Using PersistentVolumeClaim\n    ##\n    #  volumeClaimTemplate:\n    #    spec:\n    #      storageClassName: gluster\n    #      accessModes: [\"ReadWriteOnce\"]\n    #      resources:\n    #        requests:\n    #          storage: 50Gi\n    #    selector: {}\n\n    ## Using tmpfs volume\n    ##\n    #  emptyDir:\n    #    medium: Memory\n\n    # Additional volumes on the output StatefulSet definition.\n    volumes: []\n\n    # Additional VolumeMounts on the output StatefulSet definition.\n    volumeMounts: []\n\n    ## AdditionalScrapeConfigs allows specifying additional Prometheus scrape configurations. Scrape configurations\n    ## are appended to the configurations generated by the Prometheus Operator. Job configurations must have the form\n    ## as specified in the official Prometheus documentation:\n    ## https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are\n    ## appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility\n    ## to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible\n    ## scrape configs are going to break Prometheus after the upgrade.\n    ## AdditionalScrapeConfigs can be defined as a list or as a templated string.\n    ##\n    ## The scrape configuration example below will find master nodes, provided they have the name .*mst.*, relabel the\n    ## port to 2379 and allow etcd scraping provided it is running on all Kubernetes master nodes\n    ##\n    additionalScrapeConfigs: \n      - job_name: \"istiod\"\n        kubernetes_sd_configs:\n          - role: endpoints\n            namespaces:\n              names:\n                - istio-system\n        scheme: http\n        # tls_config:\n        #   ca_file: /etc/istio-certs/root-cert.pem\n        #   cert_file: /etc/istio-certs/cert-chain.pem\n        #   key_file: /etc/istio-certs/key.pem\n        #   insecure_skip_verify: true\n        relabel_configs:\n          - source_labels:\n              [\n                __meta_kubernetes_service_name,\n                __meta_kubernetes_endpoint_port_name,\n              ]\n            action: keep\n            regex: istiod;http-monitoring\n      - job_name: \"envoy-stats\"\n        metrics_path: /stats/prometheus\n        kubernetes_sd_configs:\n          - role: pod\n        relabel_configs:\n          - source_labels: [__meta_kubernetes_pod_container_port_name]\n            action: keep\n            regex: \".*-envoy-prom\"\n          - source_labels: [__meta_kubernetes_pod_phase]\n            action: drop\n            regex: Succeeded\n        scheme: http\n        # tls_config:\n        #   ca_file: /etc/istio-certs/root-cert.pem\n        #   cert_file: /etc/istio-certs/cert-chain.pem\n        #   key_file: /etc/istio-certs/key.pem\n        #   insecure_skip_verify: true\n    # - job_name: kube-etcd\n    #   kubernetes_sd_configs:\n    #     - role: node\n    #   scheme: https\n    #   tls_config:\n    #     ca_file:   /etc/prometheus/secrets/etcd-client-cert/etcd-ca\n    #     cert_file: /etc/prometheus/secrets/etcd-client-cert/etcd-client\n    #     key_file:  /etc/prometheus/secrets/etcd-client-cert/etcd-client-key\n    #   relabel_configs:\n    #   - action: labelmap\n    #     regex: __meta_kubernetes_node_label_(.+)\n    #   - source_labels: [__address__]\n    #     action: replace\n    #     targetLabel: __address__\n    #     regex: ([^:;]+):(\\d+)\n    #     replacement: 1:2379\n    #   - source_labels: [__meta_kubernetes_node_name]\n    #     action: keep\n    #     regex: .*mst.*\n    #   - source_labels: [__meta_kubernetes_node_name]\n    #     action: replace\n    #     targetLabel: node\n    #     regex: (.*)\n    #     replacement: 1\n    #   metric_relabel_configs:\n    #   - regex: (kubernetes_io_hostname|failure_domain_beta_kubernetes_io_region|beta_kubernetes_io_os|beta_kubernetes_io_arch|beta_kubernetes_io_instance_type|failure_domain_beta_kubernetes_io_zone)\n    #     action: labeldrop\n    #\n    ## If scrape config contains a repetitive section, you may want to use a template.\n    ## In the following example, you can see how to define `gce_sd_configs` for multiple zones\n    # additionalScrapeConfigs: |\n    #  - job_name: \"node-exporter\"\n    #    gce_sd_configs:\n    #    {{range $zone := .Values.gcp_zones}}\n    #    - project: \"project1\"\n    #      zone: \"{{$zone}}\"\n    #      port: 9100\n    #    {{end}}\n    #    relabel_configs:\n    #    ...\n\n\n    ## If additional scrape configurations are already deployed in a single secret file you can use this section.\n    ## Expected values are the secret name and key\n    ## Cannot be used with additionalScrapeConfigs\n    additionalScrapeConfigsSecret: {}\n      # enabled: false\n      # name:\n      # key:\n\n    ## additionalPrometheusSecretsAnnotations allows to add annotations to the kubernetes secret. This can be useful\n    ## when deploying via spinnaker to disable versioning on the secret, strategy.spinnaker.io/versioned: 'false'\n    additionalPrometheusSecretsAnnotations: {}\n\n    ## AdditionalAlertManagerConfigs allows for manual configuration of alertmanager jobs in the form as specified\n    ## in the official Prometheus documentation https://prometheus.io/docs/prometheus/latest/configuration/configuration/#\u003calertmanager_config\u003e.\n    ## AlertManager configurations specified are appended to the configurations generated by the Prometheus Operator.\n    ## As AlertManager configs are appended, the user is responsible to make sure it is valid. Note that using this\n    ## feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release\n    ## notes to ensure that no incompatible AlertManager configs are going to break Prometheus after the upgrade.\n    ##\n    additionalAlertManagerConfigs: []\n    # - consul_sd_configs:\n    #   - server: consul.dev.test:8500\n    #     scheme: http\n    #     datacenter: dev\n    #     tag_separator: ','\n    #     services:\n    #       - metrics-prometheus-alertmanager\n\n    ## If additional alertmanager configurations are already deployed in a single secret, or you want to manage\n    ## them separately from the helm deployment, you can use this section.\n    ## Expected values are the secret name and key\n    ## Cannot be used with additionalAlertManagerConfigs\n    additionalAlertManagerConfigsSecret: {}\n      # name:\n      # key:\n      # optional: false\n\n    ## AdditionalAlertRelabelConfigs allows specifying Prometheus alert relabel configurations. Alert relabel configurations specified are appended\n    ## to the configurations generated by the Prometheus Operator. Alert relabel configurations specified must have the form as specified in the\n    ## official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs.\n    ## As alert relabel configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the\n    ## possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible alert relabel\n    ## configs are going to break Prometheus after the upgrade.\n    ##\n    additionalAlertRelabelConfigs: []\n    # - separator: ;\n    #   regex: prometheus_replica\n    #   replacement: $1\n    #   action: labeldrop\n\n    ## If additional alert relabel configurations are already deployed in a single secret, or you want to manage\n    ## them separately from the helm deployment, you can use this section.\n    ## Expected values are the secret name and key\n    ## Cannot be used with additionalAlertRelabelConfigs\n    additionalAlertRelabelConfigsSecret: {}\n      # name:\n      # key:\n\n    ## SecurityContext holds pod-level security attributes and common container settings.\n    ## This defaults to non root user with uid 1000 and gid 2000.\n    ## https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md\n    ##\n    securityContext:\n      runAsGroup: 2000\n      runAsNonRoot: true\n      runAsUser: 1000\n      fsGroup: 2000\n      seccompProfile:\n        type: RuntimeDefault\n\n    ## Priority class assigned to the Pods\n    ##\n    priorityClassName: \"\"\n\n    ## Thanos configuration allows configuring various aspects of a Prometheus server in a Thanos environment.\n    ## This section is experimental, it may change significantly without deprecation notice in any release.\n    ## This is experimental and may change significantly without backward compatibility in any release.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#thanosspec\n    ##\n    thanos: {}\n      # secretProviderClass:\n      #   provider: gcp\n      #   parameters:\n      #     secrets: |\n      #       - resourceName: \"projects/$PROJECT_ID/secrets/testsecret/versions/latest\"\n      #         fileName: \"objstore.yaml\"\n      ## ObjectStorageConfig configures object storage in Thanos.\n      # objectStorageConfig:\n      #   # use existing secret, if configured, objectStorageConfig.secret will not be used\n      #   existingSecret: {}\n      #     # name: \"\"\n      #     # key: \"\"\n      #   # will render objectStorageConfig secret data and configure it to be used by Thanos custom resource,\n      #   # ignored when prometheusspec.thanos.objectStorageConfig.existingSecret is set\n      #   # https://thanos.io/tip/thanos/storage.md/#s3\n      #   secret: {}\n      #     # type: S3\n      #     # config:\n      #     #   bucket: \"\"\n      #     #   endpoint: \"\"\n      #     #   region: \"\"\n      #     #   access_key: \"\"\n      #     #   secret_key: \"\"\n\n    ## Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to a Prometheus pod.\n    ## if using proxy extraContainer update targetPort with proxy container port\n    containers: []\n    # containers:\n    # - name: oauth-proxy\n    #   image: quay.io/oauth2-proxy/oauth2-proxy:v7.5.1\n    #   args:\n    #   - --upstream=http://127.0.0.1:9090\n    #   - --http-address=0.0.0.0:8081\n    #   - --metrics-address=0.0.0.0:8082\n    #   - ...\n    #   ports:\n    #   - containerPort: 8081\n    #     name: oauth-proxy\n    #     protocol: TCP\n    #   - containerPort: 8082\n    #     name: oauth-metrics\n    #     protocol: TCP\n    #   resources: {}\n\n    ## InitContainers allows injecting additional initContainers. This is meant to allow doing some changes\n    ## (permissions, dir tree) on mounted volumes before starting prometheus\n    initContainers: []\n\n    ## PortName to use for Prometheus.\n    ##\n    portName: \"http-web\"\n\n    ## ArbitraryFSAccessThroughSMs configures whether configuration based on a service monitor can access arbitrary files\n    ## on the file system of the Prometheus container e.g. bearer token files.\n    arbitraryFSAccessThroughSMs: false\n\n    ## OverrideHonorLabels if set to true overrides all user configured honor_labels. If HonorLabels is set in ServiceMonitor\n    ## or PodMonitor to true, this overrides honor_labels to false.\n    overrideHonorLabels: false\n\n    ## OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.\n    overrideHonorTimestamps: false\n\n    ## IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from the podmonitor and servicemonitor\n    ## configs, and they will only discover endpoints within their current namespace. Defaults to false.\n    ignoreNamespaceSelectors: false\n\n    ## EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert and metric that is user created.\n    ## The label value will always be the namespace of the object that is being created.\n    ## Disabled by default\n    enforcedNamespaceLabel: \"\"\n\n    ## PrometheusRulesExcludedFromEnforce - list of prometheus rules to be excluded from enforcing of adding namespace labels.\n    ## Works only if enforcedNamespaceLabel set to true. Make sure both ruleNamespace and ruleName are set for each pair\n    ## Deprecated, use `excludedFromEnforcement` instead\n    prometheusRulesExcludedFromEnforce: []\n\n    ## ExcludedFromEnforcement - list of object references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects\n    ## to be excluded from enforcing a namespace label of origin.\n    ## Works only if enforcedNamespaceLabel set to true.\n    ## See https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#objectreference\n    excludedFromEnforcement: []\n\n    ## QueryLogFile specifies the file to which PromQL queries are logged. Note that this location must be writable,\n    ## and can be persisted using an attached volume. Alternatively, the location can be set to a stdout location such\n    ## as /dev/stdout to log querie information to the default Prometheus log stream. This is only available in versions\n    ## of Prometheus \u003e= 2.16.0. For more details, see the Prometheus docs (https://prometheus.io/docs/guides/query-log/)\n    queryLogFile: false\n\n    ## EnforcedSampleLimit defines global limit on number of scraped samples that will be accepted. This overrides any SampleLimit\n    ## set per ServiceMonitor or/and PodMonitor. It is meant to be used by admins to enforce the SampleLimit to keep overall\n    ## number of samples/series under the desired limit. Note that if SampleLimit is lower that value will be taken instead.\n    enforcedSampleLimit: false\n\n    ## EnforcedTargetLimit defines a global limit on the number of scraped targets. This overrides any TargetLimit set\n    ## per ServiceMonitor or/and PodMonitor. It is meant to be used by admins to enforce the TargetLimit to keep the overall\n    ## number of targets under the desired limit. Note that if TargetLimit is lower, that value will be taken instead, except\n    ## if either value is zero, in which case the non-zero value will be used. If both values are zero, no limit is enforced.\n    enforcedTargetLimit: false\n\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. If more than this number of labels are present\n    ## post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit. Only valid in Prometheus versions\n    ## 2.27.0 and newer.\n    enforcedLabelLimit: false\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. If a label name is longer than this number\n    ## post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit. Only valid in Prometheus versions\n    ## 2.27.0 and newer.\n    enforcedLabelNameLengthLimit: false\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. If a label value is longer than this\n    ## number post metric-relabeling, the entire scrape will be treated as failed. 0 means no limit. Only valid in Prometheus\n    ## versions 2.27.0 and newer.\n    enforcedLabelValueLengthLimit: false\n\n    ## AllowOverlappingBlocks enables vertical compaction and vertical query merge in Prometheus. This is still experimental\n    ## in Prometheus so it may change in any upcoming release.\n    allowOverlappingBlocks: false\n\n    ## Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to\n    ## be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).\n    minReadySeconds: 0\n\n    # Required for use in managed kubernetes clusters (such as AWS EKS) with custom CNI (such as calico),\n    # because control-plane managed by AWS cannot communicate with pods' IP CIDR and admission webhooks are not working\n    # Use the host's network namespace if true. Make sure to understand the security implications if you want to enable it.\n    # When hostNetwork is enabled, this will set dnsPolicy to ClusterFirstWithHostNet automatically.\n    hostNetwork: false\n\n    # HostAlias holds the mapping between IP and hostnames that will be injected\n    # as an entry in the pod’s hosts file.\n    hostAliases: []\n    #  - ip: 10.10.0.100\n    #    hostnames:\n    #      - a1.app.local\n    #      - b1.app.local\n\n    ## TracingConfig configures tracing in Prometheus.\n    ## See https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#prometheustracingconfig\n    tracingConfig: {}\n\n    ## Additional configuration which is not covered by the properties above. (passed through tpl)\n    additionalConfig: {}\n\n    ## Additional configuration which is not covered by the properties above.\n    ## Useful, if you need advanced templating inside alertmanagerSpec.\n    ## Otherwise, use prometheus.prometheusSpec.additionalConfig (passed through tpl)\n    additionalConfigString: \"\"\n\n  additionalRulesForClusterRole: []\n  #  - apiGroups: [ \"\" ]\n  #    resources:\n  #      - nodes/proxy\n  #    verbs: [ \"get\", \"list\", \"watch\" ]\n\n  additionalServiceMonitors: []\n  ## Name of the ServiceMonitor to create\n  ##\n  # - name: \"\"\n\n    ## Additional labels to set used for the ServiceMonitorSelector. Together with standard labels from\n    ## the chart\n    ##\n    # additionalLabels: {}\n\n    ## Service label for use in assembling a job name of the form \u003clabel value\u003e-\u003cport\u003e\n    ## If no label is specified, the service name is used.\n    ##\n    # jobLabel: \"\"\n\n    ## labels to transfer from the kubernetes service to the target\n    ##\n    # targetLabels: []\n\n    ## labels to transfer from the kubernetes pods to the target\n    ##\n    # podTargetLabels: []\n\n    ## Label selector for services to which this ServiceMonitor applies\n    ##\n    # selector: {}\n\n    ## Namespaces from which services are selected\n    ##\n    # namespaceSelector:\n      ## Match any namespace\n      ##\n      # any: false\n\n      ## Explicit list of namespace names to select\n      ##\n      # matchNames: []\n\n    ## Endpoints of the selected service to be monitored\n    ##\n    # endpoints: []\n      ## Name of the endpoint's service port\n      ## Mutually exclusive with targetPort\n      # - port: \"\"\n\n      ## Name or number of the endpoint's target port\n      ## Mutually exclusive with port\n      # - targetPort: \"\"\n\n      ## File containing bearer token to be used when scraping targets\n      ##\n      #   bearerTokenFile: \"\"\n\n      ## Interval at which metrics should be scraped\n      ##\n      #   interval: 30s\n\n      ## HTTP path to scrape for metrics\n      ##\n      #   path: /metrics\n\n      ## HTTP scheme to use for scraping\n      ##\n      #   scheme: http\n\n      ## TLS configuration to use when scraping the endpoint\n      ##\n      #   tlsConfig:\n\n          ## Path to the CA file\n          ##\n          # caFile: \"\"\n\n          ## Path to client certificate file\n          ##\n          # certFile: \"\"\n\n          ## Skip certificate verification\n          ##\n          # insecureSkipVerify: false\n\n          ## Path to client key file\n          ##\n          # keyFile: \"\"\n\n          ## Server name used to verify host name\n          ##\n          # serverName: \"\"\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    # metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    # relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n  additionalPodMonitors: []\n  ## Name of the PodMonitor to create\n  ##\n  # - name: \"\"\n\n    ## Additional labels to set used for the PodMonitorSelector. Together with standard labels from\n    ## the chart\n    ##\n    # additionalLabels: {}\n\n    ## Pod label for use in assembling a job name of the form \u003clabel value\u003e-\u003cport\u003e\n    ## If no label is specified, the pod endpoint name is used.\n    ##\n    # jobLabel: \"\"\n\n    ## Label selector for pods to which this PodMonitor applies\n    ##\n    # selector: {}\n\n    ## PodTargetLabels transfers labels on the Kubernetes Pod onto the target.\n    ##\n    # podTargetLabels: {}\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    # sampleLimit: 0\n\n    ## Namespaces from which pods are selected\n    ##\n    # namespaceSelector:\n      ## Match any namespace\n      ##\n      # any: false\n\n      ## Explicit list of namespace names to select\n      ##\n      # matchNames: []\n\n    ## Endpoints of the selected pods to be monitored\n    ## https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#podmetricsendpoint\n    ##\n    # podMetricsEndpoints: []\n\n## Configuration for thanosRuler\n## ref: https://thanos.io/tip/components/rule.md/\n##\nthanosRuler:\n\n  ## Deploy thanosRuler\n  ##\n  enabled: false\n\n  ## Annotations for ThanosRuler\n  ##\n  annotations: {}\n\n  ## Service account for ThanosRuler to use.\n  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/\n  ##\n  serviceAccount:\n    create: true\n    name: \"\"\n    annotations: {}\n\n  ## Configure pod disruption budgets for ThanosRuler\n  ## ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/#specifying-a-poddisruptionbudget\n  ## This configuration is immutable once created and will require the PDB to be deleted to be changed\n  ## https://github.com/kubernetes/kubernetes/issues/45398\n  ##\n  podDisruptionBudget:\n    enabled: false\n    minAvailable: 1\n    maxUnavailable: \"\"\n\n  ingress:\n    enabled: false\n\n    # For Kubernetes \u003e= 1.18 you should specify the ingress-controller via the field ingressClassName\n    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress\n    # ingressClassName: nginx\n\n    annotations: {}\n\n    labels: {}\n\n    ## Hosts must be provided if Ingress is enabled.\n    ##\n    hosts: []\n      # - thanosruler.domain.com\n\n    ## Paths to use for ingress rules - one path should match the thanosruler.routePrefix\n    ##\n    paths: []\n    # - /\n\n    ## For Kubernetes \u003e= 1.18 you should specify the pathType (determines how Ingress paths should be matched)\n    ## See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#better-path-matching-with-path-types\n    # pathType: ImplementationSpecific\n\n    ## TLS configuration for ThanosRuler Ingress\n    ## Secret must be manually created in the namespace\n    ##\n    tls: []\n    # - secretName: thanosruler-general-tls\n    #   hosts:\n    #   - thanosruler.example.com\n\n  ## Configuration for ThanosRuler service\n  ##\n  service:\n    annotations: {}\n    labels: {}\n    clusterIP: \"\"\n\n    ## Port for ThanosRuler Service to listen on\n    ##\n    port: 10902\n    ## To be used with a proxy extraContainer port\n    ##\n    targetPort: 10902\n    ## Port to expose on each node\n    ## Only used if service.type is 'NodePort'\n    ##\n    nodePort: 30905\n    ## List of IP addresses at which the Prometheus server service is available\n    ## Ref: https://kubernetes.io/docs/user-guide/services/#external-ips\n    ##\n\n    ## Additional ports to open for ThanosRuler service\n    additionalPorts: []\n\n    externalIPs: []\n    loadBalancerIP: \"\"\n    loadBalancerSourceRanges: []\n\n    ## Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints\n    ##\n    externalTrafficPolicy: Cluster\n\n    ## Service type\n    ##\n    type: ClusterIP\n\n  ## If true, create a serviceMonitor for thanosRuler\n  ##\n  serviceMonitor:\n    ## Scrape interval. If not set, the Prometheus default scrape interval is used.\n    ##\n    interval: \"\"\n    selfMonitor: true\n\n    ## Additional labels\n    ##\n    additionalLabels: {}\n\n    ## SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.\n    ##\n    sampleLimit: 0\n\n    ## TargetLimit defines a limit on the number of scraped targets that will be accepted.\n    ##\n    targetLimit: 0\n\n    ## Per-scrape limit on number of labels that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelLimit: 0\n\n    ## Per-scrape limit on length of labels name that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelNameLengthLimit: 0\n\n    ## Per-scrape limit on length of labels value that will be accepted for a sample. Only valid in Prometheus versions 2.27.0 and newer.\n    ##\n    labelValueLengthLimit: 0\n\n    ## proxyUrl: URL of a proxy that should be used for scraping.\n    ##\n    proxyUrl: \"\"\n\n    ## scheme: HTTP scheme to use for scraping. Can be used with `tlsConfig` for example if using istio mTLS.\n    scheme: \"\"\n\n    ## tlsConfig: TLS configuration to use when scraping the endpoint. For example if using istio mTLS.\n    ## Of type: https://github.com/coreos/prometheus-operator/blob/main/Documentation/api.md#tlsconfig\n    tlsConfig: {}\n\n    bearerTokenFile:\n\n    ## MetricRelabelConfigs to apply to samples after scraping, but before ingestion.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    metricRelabelings: []\n    # - action: keep\n    #   regex: 'kube_(daemonset|deployment|pod|namespace|node|statefulset).+'\n    #   sourceLabels: [__name__]\n\n    ## RelabelConfigs to apply to samples before scraping\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#relabelconfig\n    ##\n    relabelings: []\n    # - sourceLabels: [__meta_kubernetes_pod_node_name]\n    #   separator: ;\n    #   regex: ^(.*)$\n    #   targetLabel: nodename\n    #   replacement: $1\n    #   action: replace\n\n    ## Additional Endpoints\n    ##\n    additionalEndpoints: []\n    # - port: oauth-metrics\n    #   path: /metrics\n\n  ## Settings affecting thanosRulerpec\n  ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#thanosrulerspec\n  ##\n  thanosRulerSpec:\n    ## Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata\n    ## Metadata Labels and Annotations gets propagated to the ThanosRuler pods.\n    ##\n    podMetadata: {}\n\n    ## Image of ThanosRuler\n    ##\n    image:\n      registry: quay.io\n      repository: thanos/thanos\n      tag: v0.32.5\n      sha: \"\"\n\n    ## Namespaces to be selected for PrometheusRules discovery.\n    ## If nil, select own namespace. Namespaces to be selected for ServiceMonitor discovery.\n    ## See https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#namespaceselector for usage\n    ##\n    ruleNamespaceSelector: {}\n\n    ## If true, a nil or {} value for thanosRuler.thanosRulerSpec.ruleSelector will cause the\n    ## prometheus resource to be created with selectors based on values in the helm deployment,\n    ## which will also match the PrometheusRule resources created\n    ##\n    ruleSelectorNilUsesHelmValues: true\n\n    ## PrometheusRules to be selected for target discovery.\n    ## If {}, select all PrometheusRules\n    ##\n    ruleSelector: {}\n    ## Example which select all PrometheusRules resources\n    ## with label \"prometheus\" with values any of \"example-rules\" or \"example-rules-2\"\n    # ruleSelector:\n    #   matchExpressions:\n    #     - key: prometheus\n    #       operator: In\n    #       values:\n    #         - example-rules\n    #         - example-rules-2\n    #\n    ## Example which select all PrometheusRules resources with label \"role\" set to \"example-rules\"\n    # ruleSelector:\n    #   matchLabels:\n    #     role: example-rules\n\n    ## Define Log Format\n    # Use logfmt (default) or json logging\n    logFormat: logfmt\n\n    ## Log level for ThanosRuler to be configured with.\n    ##\n    logLevel: info\n\n    ## Size is the expected size of the thanosRuler cluster. The controller will eventually make the size of the\n    ## running cluster equal to the expected size.\n    replicas: 1\n\n    ## Time duration ThanosRuler shall retain data for. Default is '24h', and must match the regular expression\n    ## [0-9]+(ms|s|m|h) (milliseconds seconds minutes hours).\n    ##\n    retention: 24h\n\n    ## Interval between consecutive evaluations.\n    ##\n    evaluationInterval: \"\"\n\n    ## Storage is the definition of how storage will be used by the ThanosRuler instances.\n    ## ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/user-guides/storage.md\n    ##\n    storage: {}\n    # volumeClaimTemplate:\n    #   spec:\n    #     storageClassName: gluster\n    #     accessModes: [\"ReadWriteOnce\"]\n    #     resources:\n    #       requests:\n    #         storage: 50Gi\n    #   selector: {}\n\n    ## AlertmanagerConfig define configuration for connecting to alertmanager.\n    ## Only available with Thanos v0.10.0 and higher. Maps to the alertmanagers.config Thanos Ruler arg.\n    alertmanagersConfig:\n      # use existing secret, if configured, alertmanagersConfig.secret will not be used\n      existingSecret: {}\n        # name: \"\"\n        # key: \"\"\n      # will render render alertmanagersConfig secret data and configure it to be used by Thanos Ruler custom resource, ignored when alertmanagersConfig.existingSecret is set\n      # https://thanos.io/tip/components/rule.md/#alertmanager\n      secret: {}\n        # alertmanagers:\n        # - api_version: v2\n        #   http_config:\n        #     basic_auth:\n        #       username: some_user\n        #       password: some_pass\n        #   static_configs:\n        #     - alertmanager.thanos.io\n        #   scheme: http\n        #   timeout: 10s\n\n    ## DEPRECATED. Define URLs to send alerts to Alertmanager. For Thanos v0.10.0 and higher, alertmanagersConfig should be used instead.\n    ## Note: this field will be ignored if alertmanagersConfig is specified. Maps to the alertmanagers.url Thanos Ruler arg.\n    # alertmanagersUrl:\n\n    ## The external URL the Thanos Ruler instances will be available under. This is necessary to generate correct URLs. This is necessary if Thanos Ruler is not served from root of a DNS name. string false\n    ##\n    externalPrefix:\n\n    ## The route prefix ThanosRuler registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true,\n    ## but the server serves requests under a different route prefix. For example for use with kubectl proxy.\n    ##\n    routePrefix: /\n\n    ## ObjectStorageConfig configures object storage in Thanos\n    objectStorageConfig:\n      # use existing secret, if configured, objectStorageConfig.secret will not be used\n      existingSecret: {}\n        # name: \"\"\n        # key: \"\"\n      # will render objectStorageConfig secret data and configure it to be used by Thanos Ruler custom resource, ignored when objectStorageConfig.existingSecret is set\n      # https://thanos.io/tip/thanos/storage.md/#s3\n      secret: {}\n        # type: S3\n        # config:\n        #   bucket: \"\"\n        #   endpoint: \"\"\n        #   region: \"\"\n        #   access_key: \"\"\n        #   secret_key: \"\"\n\n    ## QueryEndpoints defines Thanos querier endpoints from which to query metrics.\n    ## Maps to the --query flag of thanos ruler.\n    queryEndpoints: []\n\n    ## Define configuration for connecting to thanos query instances. If this is defined, the queryEndpoints field will be ignored.\n    ## Maps to the query.config CLI argument. Only available with thanos v0.11.0 and higher.\n    queryConfig:\n      # use existing secret, if configured, queryConfig.secret will not be used\n      existingSecret: {}\n        # name: \"\"\n        # key: \"\"\n      # render queryConfig secret data and configure it to be used by Thanos Ruler custom resource, ignored when queryConfig.existingSecret is set\n      # https://thanos.io/tip/components/rule.md/#query-api\n      secret: {}\n        # - http_config:\n        #     basic_auth:\n        #       username: some_user\n        #       password: some_pass\n        #   static_configs:\n        #     - URL\n        #   scheme: http\n        #   timeout: 10s\n\n    ## Labels configure the external label pairs to ThanosRuler. A default replica\n    ## label `thanos_ruler_replica` will be always added as a label with the value\n    ## of the pod's name and it will be dropped in the alerts.\n    labels: {}\n\n    ## If set to true all actions on the underlying managed objects are not going to be performed, except for delete actions.\n    ##\n    paused: false\n\n    ## Define which Nodes the Pods are scheduled on.\n    ## ref: https://kubernetes.io/docs/user-guide/node-selection/\n    ##\n    nodeSelector: {}\n\n    ## Define resources requests and limits for single Pods.\n    ## ref: https://kubernetes.io/docs/user-guide/compute-resources/\n    ##\n    resources: {}\n    # requests:\n    #   memory: 400Mi\n\n    ## Pod anti-affinity can prevent the scheduler from placing Prometheus replicas on the same node.\n    ## The default value \"soft\" means that the scheduler should *prefer* to not schedule two replica pods onto the same node but no guarantee is provided.\n    ## The value \"hard\" means that the scheduler is *required* to not schedule two replica pods onto the same node.\n    ## The value \"\" will disable pod anti-affinity so that no anti-affinity rules will be configured.\n    ##\n    podAntiAffinity: \"\"\n\n    ## If anti-affinity is enabled sets the topologyKey to use for anti-affinity.\n    ## This can be changed to, for example, failure-domain.beta.kubernetes.io/zone\n    ##\n    podAntiAffinityTopologyKey: kubernetes.io/hostname\n\n    ## Assign custom affinity rules to the thanosRuler instance\n    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\n    ##\n    affinity: {}\n    # nodeAffinity:\n    #   requiredDuringSchedulingIgnoredDuringExecution:\n    #     nodeSelectorTerms:\n    #     - matchExpressions:\n    #       - key: kubernetes.io/e2e-az-name\n    #         operator: In\n    #         values:\n    #         - e2e-az1\n    #         - e2e-az2\n\n    ## If specified, the pod's tolerations.\n    ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\n    ##\n    tolerations: []\n    # - key: \"key\"\n    #   operator: \"Equal\"\n    #   value: \"value\"\n    #   effect: \"NoSchedule\"\n\n    ## If specified, the pod's topology spread constraints.\n    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\n    ##\n    topologySpreadConstraints: []\n    # - maxSkew: 1\n    #   topologyKey: topology.kubernetes.io/zone\n    #   whenUnsatisfiable: DoNotSchedule\n    #   labelSelector:\n    #     matchLabels:\n    #       app: thanos-ruler\n\n    ## SecurityContext holds pod-level security attributes and common container settings.\n    ## This defaults to non root user with uid 1000 and gid 2000. *v1.PodSecurityContext  false\n    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/\n    ##\n    securityContext:\n      runAsGroup: 2000\n      runAsNonRoot: true\n      runAsUser: 1000\n      fsGroup: 2000\n      seccompProfile:\n        type: RuntimeDefault\n\n    ## ListenLocal makes the ThanosRuler server listen on loopback, so that it does not bind against the Pod IP.\n    ## Note this is only for the ThanosRuler UI, not the gossip communication.\n    ##\n    listenLocal: false\n\n    ## Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an ThanosRuler pod.\n    ##\n    containers: []\n\n    # Additional volumes on the output StatefulSet definition.\n    volumes: []\n\n    # Additional VolumeMounts on the output StatefulSet definition.\n    volumeMounts: []\n\n    ## InitContainers allows injecting additional initContainers. This is meant to allow doing some changes\n    ## (permissions, dir tree) on mounted volumes before starting prometheus\n    initContainers: []\n\n    ## Priority class assigned to the Pods\n    ##\n    priorityClassName: \"\"\n\n    ## PortName to use for ThanosRuler.\n    ##\n    portName: \"web\"\n\n  ## ExtraSecret can be used to store various data in an extra secret\n  ## (use it for example to store hashed basic auth credentials)\n  extraSecret:\n    ## if not set, name will be auto generated\n    # name: \"\"\n    annotations: {}\n    data: {}\n  #   auth: |\n  #     foo:$apr1$OFG3Xybp$ckL0FHDAkoXYIlH9.cysT0\n  #     someoneelse:$apr1$DMZX2Z4q$6SbQIfyuLQd.xmo/P0m2c.\n\n## Setting to true produces cleaner resource names, but requires a data migration because the name of the persistent volume changes. Therefore this should only be set once on initial installation.\n##\ncleanPrometheusOperatorObjectNames: false\n\n## Extra manifests to deploy as an array\nextraManifests: []\n  # - apiVersion: v1\n  #   kind: ConfigMap\n  #   metadata:\n  #   labels:\n  #     name: prometheus-extra\n  #   data:\n  #     extra-data: \"value\"\n"
            ],
            "verify": false,
            "version": "52.1.0",
            "wait": false,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "helm_release",
      "name": "tailscale",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "atomic": false,
            "chart": "kubernetes/conf/tailscale/cmd/k8s-operator/deploy/chart",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "tailscale",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "unstable",
                "chart": "tailscale-operator",
                "name": "tailscale",
                "namespace": "tailscale",
                "revision": 1,
                "values": "{\"apiServerProxyConfig\":{\"mode\":\"true\"},\"operatorConfig\":{\"hostname\":\"tailscale-operator\",\"image\":{\"digest\":\"\",\"repo\":\"tailscale/k8s-operator\",\"tag\":\"\"},\"logging\":\"info\",\"nodeSelector\":{\"kubernetes.io/os\":\"linux\"}},\"proxyConfig\":{\"defaultTags\":\"tag:k8s-operator\",\"firewallMode\":\"auto\",\"image\":{\"digest\":\"\",\"repo\":\"tailscale/tailscale\",\"tag\":\"\"}}}",
                "version": "0.1.0"
              }
            ],
            "name": "tailscale",
            "namespace": "tailscale",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": null,
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_list": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "# Copyright (c) Tailscale Inc \u0026 AUTHORS\n# SPDX-License-Identifier: BSD-3-Clause\n\n# Operator oauth credentials. If set a Kubernetes Secret with the provided\n# values will be created in the operator namespace. If unset a Secret named\n# operator-oauth must be precreated.\n# oauth:\n#   clientId: \"\"\n#   clientSecret: \"\"\n\noperatorConfig:\n  image:\n    repo: tailscale/k8s-operator\n    # Digest will be prioritized over tag. If neither are set appVersion will be\n    # used.\n    tag: \"\"\n    digest: \"\"\n  logging: \"info\"\n  hostname: \"tailscale-operator\"\n  nodeSelector:\n    kubernetes.io/os: linux\n\n\n# proxyConfig contains configuraton that will be applied to any ingress/egress\n# proxies created by the operator.\n# https://tailscale.com/kb/1236/kubernetes-operator/#cluster-ingress\n# https://tailscale.com/kb/1236/kubernetes-operator/#cluster-egress\nproxyConfig:\n  image:\n    repo: tailscale/tailscale\n    # Digest will be prioritized over tag. If neither are set appVersion will be\n    # used.\n    tag: \"\"\n    digest: \"\"\n  # ACL tag that operator will tag proxies with. Operator must be made owner of\n  # these tags\n  # https://tailscale.com/kb/1236/kubernetes-operator/?q=operator#setting-up-the-kubernetes-operator\n  defaultTags: tag:k8s-operator\n  firewallMode: auto\n\n# apiServerProxyConfig allows to configure whether the operator should expose\n# Kubernetes API server.\n# https://tailscale.com/kb/1236/kubernetes-operator/#accessing-the-kubernetes-control-plane-using-an-api-server-proxy\napiServerProxyConfig:\n  mode: \"true\" # \"true\", \"false\", \"noauth\""
            ],
            "verify": false,
            "version": "0.1.0",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "helm_release",
      "name": "vault",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "atomic": false,
            "chart": "vault",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "vault",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "1.15.1",
                "chart": "vault",
                "name": "vault",
                "namespace": "vault",
                "revision": 1,
                "values": "{\"csi\":{\"agent\":{\"enabled\":true,\"extraArgs\":[],\"image\":{\"pullPolicy\":\"IfNotPresent\",\"repository\":\"hashicorp/vault\",\"tag\":\"1.15.1\"},\"logFormat\":\"standard\",\"logLevel\":\"info\",\"resources\":{}},\"daemonSet\":{\"annotations\":{},\"extraLabels\":{},\"kubeletRootDir\":\"/var/lib/kubelet\",\"providersDir\":\"/etc/kubernetes/secrets-store-csi-providers\",\"securityContext\":{\"container\":{},\"pod\":{}},\"updateStrategy\":{\"maxUnavailable\":\"\",\"type\":\"RollingUpdate\"}},\"debug\":false,\"enabled\":false,\"extraArgs\":[],\"hmacSecretName\":\"\",\"image\":{\"pullPolicy\":\"IfNotPresent\",\"repository\":\"hashicorp/vault-csi-provider\",\"tag\":\"1.4.1\"},\"livenessProbe\":{\"failureThreshold\":2,\"initialDelaySeconds\":5,\"periodSeconds\":5,\"successThreshold\":1,\"timeoutSeconds\":3},\"pod\":{\"affinity\":{},\"annotations\":{},\"extraLabels\":{},\"nodeSelector\":{},\"tolerations\":[]},\"priorityClassName\":\"\",\"readinessProbe\":{\"failureThreshold\":2,\"initialDelaySeconds\":5,\"periodSeconds\":5,\"successThreshold\":1,\"timeoutSeconds\":3},\"resources\":{},\"serviceAccount\":{\"annotations\":{},\"extraLabels\":{}},\"volumeMounts\":null,\"volumes\":null},\"global\":{\"enabled\":true,\"externalVaultAddr\":\"\",\"imagePullSecrets\":[],\"namespace\":\"\",\"openshift\":false,\"psp\":{\"annotations\":\"seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default,runtime/default\\napparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default\\nseccomp.security.alpha.kubernetes.io/defaultProfileName:  runtime/default\\napparmor.security.beta.kubernetes.io/defaultProfileName:  runtime/default\\n\",\"enable\":false},\"serverTelemetry\":{\"prometheusOperator\":false},\"tlsDisable\":true},\"injector\":{\"affinity\":\"podAntiAffinity:\\n  requiredDuringSchedulingIgnoredDuringExecution:\\n    - labelSelector:\\n        matchLabels:\\n          app.kubernetes.io/name: {{ template \\\"vault.name\\\" . }}-agent-injector\\n          app.kubernetes.io/instance: \\\"{{ .Release.Name }}\\\"\\n          component: webhook\\n      topologyKey: kubernetes.io/hostname\\n\",\"agentDefaults\":{\"cpuLimit\":\"500m\",\"cpuRequest\":\"250m\",\"memLimit\":\"128Mi\",\"memRequest\":\"64Mi\",\"template\":\"map\",\"templateConfig\":{\"exitOnRetryFailure\":true,\"staticSecretRenderInterval\":\"\"}},\"agentImage\":{\"repository\":\"hashicorp/vault\",\"tag\":\"1.15.1\"},\"annotations\":{},\"authPath\":\"auth/kubernetes\",\"certs\":{\"caBundle\":\"\",\"certName\":\"tls.crt\",\"keyName\":\"tls.key\",\"secretName\":null},\"enabled\":\"-\",\"externalVaultAddr\":\"\",\"extraEnvironmentVars\":{},\"extraLabels\":{},\"failurePolicy\":\"Ignore\",\"hostNetwork\":false,\"image\":{\"pullPolicy\":\"IfNotPresent\",\"repository\":\"hashicorp/vault-k8s\",\"tag\":\"1.3.1\"},\"leaderElector\":{\"enabled\":true},\"livenessProbe\":{\"failureThreshold\":2,\"initialDelaySeconds\":5,\"periodSeconds\":2,\"successThreshold\":1,\"timeoutSeconds\":5},\"logFormat\":\"standard\",\"logLevel\":\"info\",\"metrics\":{\"enabled\":false},\"namespaceSelector\":{},\"nodeSelector\":{},\"objectSelector\":{},\"podDisruptionBudget\":{},\"port\":8080,\"priorityClassName\":\"\",\"readinessProbe\":{\"failureThreshold\":2,\"initialDelaySeconds\":5,\"periodSeconds\":2,\"successThreshold\":1,\"timeoutSeconds\":5},\"replicas\":1,\"resources\":{},\"revokeOnShutdown\":false,\"securityContext\":{\"container\":{},\"pod\":{}},\"service\":{\"annotations\":{}},\"serviceAccount\":{\"annotations\":{}},\"startupProbe\":{\"failureThreshold\":12,\"initialDelaySeconds\":5,\"periodSeconds\":5,\"successThreshold\":1,\"timeoutSeconds\":5},\"strategy\":{},\"tolerations\":[],\"topologySpreadConstraints\":[],\"webhook\":{\"annotations\":{},\"failurePolicy\":\"Ignore\",\"matchPolicy\":\"Exact\",\"namespaceSelector\":{},\"objectSelector\":\"matchExpressions:\\n- key: app.kubernetes.io/name\\n  operator: NotIn\\n  values:\\n  - {{ template \\\"vault.name\\\" . }}-agent-injector\\n\",\"timeoutSeconds\":30},\"webhookAnnotations\":{}},\"server\":{\"affinity\":\"podAntiAffinity:\\n  requiredDuringSchedulingIgnoredDuringExecution:\\n    - labelSelector:\\n        matchLabels:\\n          app.kubernetes.io/name: {{ template \\\"vault.name\\\" . }}\\n          app.kubernetes.io/instance: \\\"{{ .Release.Name }}\\\"\\n          component: server\\n      topologyKey: kubernetes.io/hostname\\n\",\"annotations\":{},\"auditStorage\":{\"accessMode\":\"ReadWriteOnce\",\"annotations\":{},\"enabled\":false,\"mountPath\":\"/vault/audit\",\"size\":\"10Gi\",\"storageClass\":null},\"authDelegator\":{\"enabled\":true},\"dataStorage\":{\"accessMode\":\"ReadWriteOnce\",\"annotations\":{},\"enabled\":true,\"mountPath\":\"/vault/data\",\"size\":\"10Gi\",\"storageClass\":\"openebs-jiva-csi-default\"},\"dev\":{\"devRootToken\":\"root\",\"enabled\":false},\"enabled\":\"-\",\"enterpriseLicense\":{\"secretKey\":\"license\",\"secretName\":\"\"},\"extraArgs\":\"\",\"extraContainers\":null,\"extraEnvironmentVars\":{},\"extraInitContainers\":null,\"extraLabels\":{},\"extraPorts\":null,\"extraSecretEnvironmentVars\":[],\"extraVolumes\":[],\"ha\":{\"apiAddr\":null,\"clusterAddr\":null,\"config\":\"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  tls_disable = 1\\n  address = \\\"[::]:8200\\\"\\n  cluster_address = \\\"[::]:8201\\\"\\n}\\nstorage \\\"consul\\\" {\\n  path = \\\"vault\\\"\\n  address = \\\"HOST_IP:8500\\\"\\n}\\n\\nservice_registration \\\"kubernetes\\\" {}\\n\\n# Example configuration for using auto-unseal, using Google Cloud KMS. The\\n# GKMS keys must already exist, and the cluster must have a service account\\n# that is authorized to access GCP KMS.\\n#seal \\\"gcpckms\\\" {\\n#   project     = \\\"vault-helm-dev-246514\\\"\\n#   region      = \\\"global\\\"\\n#   key_ring    = \\\"vault-helm-unseal-kr\\\"\\n#   crypto_key  = \\\"vault-helm-unseal-key\\\"\\n#}\\n\\n# Example configuration for enabling Prometheus metrics.\\n# If you are using Prometheus Operator you can enable a ServiceMonitor resource below.\\n# You may wish to enable unauthenticated metrics in the listener block above.\\n#telemetry {\\n#  prometheus_retention_time = \\\"30s\\\"\\n#  disable_hostname = true\\n#}\\n\",\"disruptionBudget\":{\"enabled\":true,\"maxUnavailable\":null},\"enabled\":false,\"raft\":{\"config\":\"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  tls_disable = 1\\n  address = \\\"[::]:8200\\\"\\n  cluster_address = \\\"[::]:8201\\\"\\n  # Enable unauthenticated metrics access (necessary for Prometheus Operator)\\n  #telemetry {\\n  #  unauthenticated_metrics_access = \\\"true\\\"\\n  #}\\n}\\n\\nstorage \\\"raft\\\" {\\n  path = \\\"/vault/data\\\"\\n}\\n\\nservice_registration \\\"kubernetes\\\" {}\\n\",\"enabled\":false,\"setNodeId\":false},\"replicas\":3},\"hostAliases\":[],\"hostNetwork\":false,\"image\":{\"pullPolicy\":\"IfNotPresent\",\"repository\":\"hashicorp/vault\",\"tag\":\"1.15.1\"},\"ingress\":{\"activeService\":true,\"annotations\":{},\"enabled\":false,\"extraPaths\":[],\"hosts\":[{\"host\":\"chart-example.local\",\"paths\":[]}],\"ingressClassName\":\"\",\"labels\":{},\"pathType\":\"Prefix\",\"tls\":[]},\"livenessProbe\":{\"enabled\":false,\"failureThreshold\":2,\"initialDelaySeconds\":60,\"path\":\"/v1/sys/health?standbyok=true\",\"periodSeconds\":5,\"port\":8200,\"successThreshold\":1,\"timeoutSeconds\":3},\"logFormat\":\"\",\"logLevel\":\"\",\"networkPolicy\":{\"egress\":[],\"enabled\":false},\"nodeSelector\":{},\"postStart\":[],\"preStopSleepSeconds\":5,\"priorityClassName\":\"\",\"readinessProbe\":{\"enabled\":true,\"failureThreshold\":2,\"initialDelaySeconds\":5,\"periodSeconds\":5,\"port\":8200,\"successThreshold\":1,\"timeoutSeconds\":3},\"resources\":{},\"route\":{\"activeService\":true,\"annotations\":{},\"enabled\":false,\"host\":\"chart-example.local\",\"labels\":{},\"tls\":{\"termination\":\"passthrough\"}},\"service\":{\"active\":{\"annotations\":{},\"enabled\":true},\"annotations\":{},\"enabled\":true,\"externalTrafficPolicy\":\"Cluster\",\"instanceSelector\":{\"enabled\":true},\"ipFamilies\":[],\"ipFamilyPolicy\":\"\",\"port\":8200,\"publishNotReadyAddresses\":true,\"standby\":{\"annotations\":{},\"enabled\":true},\"targetPort\":8200},\"serviceAccount\":{\"annotations\":{},\"create\":true,\"createSecret\":false,\"extraLabels\":{},\"name\":\"\",\"serviceDiscovery\":{\"enabled\":true}},\"shareProcessNamespace\":false,\"standalone\":{\"config\":\"ui = true\\n\\nlistener \\\"tcp\\\" {\\n  tls_disable = 1\\n  address = \\\"[::]:8200\\\"\\n  cluster_address = \\\"[::]:8201\\\"\\n  # Enable unauthenticated metrics access (necessary for Prometheus Operator)\\n  #telemetry {\\n  #  unauthenticated_metrics_access = \\\"true\\\"\\n  #}\\n}\\nstorage \\\"file\\\" {\\n  path = \\\"/vault/data\\\"\\n}\\n\\n# Example configuration for using auto-unseal, using Google Cloud KMS. The\\n# GKMS keys must already exist, and the cluster must have a service account\\n# that is authorized to access GCP KMS.\\n#seal \\\"gcpckms\\\" {\\n#   project     = \\\"vault-helm-dev\\\"\\n#   region      = \\\"global\\\"\\n#   key_ring    = \\\"vault-helm-unseal-kr\\\"\\n#   crypto_key  = \\\"vault-helm-unseal-key\\\"\\n#}\\n\\n# Example configuration for enabling Prometheus metrics in your config.\\n#telemetry {\\n#  prometheus_retention_time = \\\"30s\\\"\\n#  disable_hostname = true\\n#}\\n\",\"enabled\":\"-\"},\"statefulSet\":{\"annotations\":{},\"securityContext\":{\"container\":{},\"pod\":{}}},\"terminationGracePeriodSeconds\":10,\"tolerations\":[],\"topologySpreadConstraints\":[],\"updateStrategyType\":\"OnDelete\",\"volumeMounts\":null,\"volumes\":null},\"serverTelemetry\":{\"prometheusRules\":{\"enabled\":false,\"rules\":[],\"selectors\":{}},\"serviceMonitor\":{\"enabled\":false,\"interval\":\"30s\",\"scrapeTimeout\":\"10s\",\"selectors\":{}}},\"ui\":{\"activeVaultPodOnly\":false,\"annotations\":{},\"enabled\":false,\"externalPort\":8200,\"externalTrafficPolicy\":\"Cluster\",\"publishNotReadyAddresses\":true,\"serviceIPFamilies\":[],\"serviceIPFamilyPolicy\":\"\",\"serviceNodePort\":null,\"serviceType\":\"ClusterIP\",\"targetPort\":8200}}",
                "version": "0.26.0"
              }
            ],
            "name": "vault",
            "namespace": "vault",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://helm.releases.hashicorp.com",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_list": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "# Copyright (c) HashiCorp, Inc.\n# SPDX-License-Identifier: MPL-2.0\n\n# Available parameters and their default values for the Vault chart.\n\nglobal:\n  # enabled is the master enabled switch. Setting this to true or false\n  # will enable or disable all the components within this chart by default.\n  enabled: true\n\n  # The namespace to deploy to. Defaults to the `helm` installation namespace.\n  namespace: \"\"\n\n  # Image pull secret to use for registry authentication.\n  # Alternatively, the value may be specified as an array of strings.\n  imagePullSecrets: []\n  # imagePullSecrets:\n  #   - name: image-pull-secret\n\n  # TLS for end-to-end encrypted transport\n  tlsDisable: true\n\n  # External vault server address for the injector and CSI provider to use.\n  # Setting this will disable deployment of a vault server.\n  externalVaultAddr: \"\"\n\n  # If deploying to OpenShift\n  openshift: false\n\n  # Create PodSecurityPolicy for pods\n  psp:\n    enable: false\n    # Annotation for PodSecurityPolicy.\n    # This is a multi-line templated string map, and can also be set as YAML.\n    annotations: |\n      seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default,runtime/default\n      apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default\n      seccomp.security.alpha.kubernetes.io/defaultProfileName:  runtime/default\n      apparmor.security.beta.kubernetes.io/defaultProfileName:  runtime/default\n\n  serverTelemetry:\n    # Enable integration with the Prometheus Operator\n    # See the top level serverTelemetry section below before enabling this feature.\n    prometheusOperator: false\n\ninjector:\n  # True if you want to enable vault agent injection.\n  # @default: global.enabled\n  enabled: \"-\"\n\n  replicas: 1\n\n  # Configures the port the injector should listen on\n  port: 8080\n\n  # If multiple replicas are specified, by default a leader will be determined\n  # so that only one injector attempts to create TLS certificates.\n  leaderElector:\n    enabled: true\n\n  # If true, will enable a node exporter metrics endpoint at /metrics.\n  metrics:\n    enabled: false\n\n  # Deprecated: Please use global.externalVaultAddr instead.\n  externalVaultAddr: \"\"\n\n  # image sets the repo and tag of the vault-k8s image to use for the injector.\n  image:\n    repository: \"hashicorp/vault-k8s\"\n    tag: \"1.3.1\"\n    pullPolicy: IfNotPresent\n\n  # agentImage sets the repo and tag of the Vault image to use for the Vault Agent\n  # containers.  This should be set to the official Vault image.  Vault 1.3.1+ is\n  # required.\n  agentImage:\n    repository: \"hashicorp/vault\"\n    tag: \"1.15.1\"\n\n  # The default values for the injected Vault Agent containers.\n  agentDefaults:\n    # For more information on configuring resources, see the K8s documentation:\n    # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n    cpuLimit: \"500m\"\n    cpuRequest: \"250m\"\n    memLimit: \"128Mi\"\n    memRequest: \"64Mi\"\n    # ephemeralLimit: \"128Mi\"\n    # ephemeralRequest: \"64Mi\"\n\n    # Default template type for secrets when no custom template is specified.\n    # Possible values include: \"json\" and \"map\".\n    template: \"map\"\n\n    # Default values within Agent's template_config stanza.\n    templateConfig:\n      exitOnRetryFailure: true\n      staticSecretRenderInterval: \"\"\n\n  # Used to define custom livenessProbe settings\n  livenessProbe:\n    # When a probe fails, Kubernetes will try failureThreshold times before giving up\n    failureThreshold: 2\n    # Number of seconds after the container has started before probe initiates\n    initialDelaySeconds: 5\n    # How often (in seconds) to perform the probe\n    periodSeconds: 2\n    # Minimum consecutive successes for the probe to be considered successful after having failed\n    successThreshold: 1\n    # Number of seconds after which the probe times out.\n    timeoutSeconds: 5\n  # Used to define custom readinessProbe settings\n  readinessProbe:\n    # When a probe fails, Kubernetes will try failureThreshold times before giving up\n    failureThreshold: 2\n    # Number of seconds after the container has started before probe initiates\n    initialDelaySeconds: 5\n    # How often (in seconds) to perform the probe\n    periodSeconds: 2\n    # Minimum consecutive successes for the probe to be considered successful after having failed\n    successThreshold: 1\n    # Number of seconds after which the probe times out.\n    timeoutSeconds: 5\n  # Used to define custom startupProbe settings\n  startupProbe:\n    # When a probe fails, Kubernetes will try failureThreshold times before giving up\n    failureThreshold: 12\n    # Number of seconds after the container has started before probe initiates\n    initialDelaySeconds: 5\n    # How often (in seconds) to perform the probe\n    periodSeconds: 5\n    # Minimum consecutive successes for the probe to be considered successful after having failed\n    successThreshold: 1\n    # Number of seconds after which the probe times out.\n    timeoutSeconds: 5\n\n  # Mount Path of the Vault Kubernetes Auth Method.\n  authPath: \"auth/kubernetes\"\n\n  # Configures the log verbosity of the injector.\n  # Supported log levels include: trace, debug, info, warn, error\n  logLevel: \"info\"\n\n  # Configures the log format of the injector. Supported log formats: \"standard\", \"json\".\n  logFormat: \"standard\"\n\n  # Configures all Vault Agent sidecars to revoke their token when shutting down\n  revokeOnShutdown: false\n\n  webhook:\n    # Configures failurePolicy of the webhook. The \"unspecified\" default behaviour depends on the\n    # API Version of the WebHook.\n    # To block pod creation while the webhook is unavailable, set the policy to `Fail` below.\n    # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy\n    #\n    failurePolicy: Ignore\n\n    # matchPolicy specifies the approach to accepting changes based on the rules of\n    # the MutatingWebhookConfiguration.\n    # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-matchpolicy\n    # for more details.\n    #\n    matchPolicy: Exact\n\n    # timeoutSeconds is the amount of seconds before the webhook request will be ignored\n    # or fails.\n    # If it is ignored or fails depends on the failurePolicy\n    # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#timeouts\n    # for more details.\n    #\n    timeoutSeconds: 30\n\n    # namespaceSelector is the selector for restricting the webhook to only\n    # specific namespaces.\n    # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector\n    # for more details.\n    # Example:\n    # namespaceSelector:\n    #    matchLabels:\n    #      sidecar-injector: enabled\n    namespaceSelector: {}\n\n    # objectSelector is the selector for restricting the webhook to only\n    # specific labels.\n    # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector\n    # for more details.\n    # Example:\n    # objectSelector:\n    #    matchLabels:\n    #      vault-sidecar-injector: enabled\n    objectSelector: |\n      matchExpressions:\n      - key: app.kubernetes.io/name\n        operator: NotIn\n        values:\n        - {{ template \"vault.name\" . }}-agent-injector\n\n    # Extra annotations to attach to the webhook\n    annotations: {}\n\n  # Deprecated: please use 'webhook.failurePolicy' instead\n  # Configures failurePolicy of the webhook. The \"unspecified\" default behaviour depends on the\n  # API Version of the WebHook.\n  # To block pod creation while webhook is unavailable, set the policy to `Fail` below.\n  # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#failure-policy\n  #\n  failurePolicy: Ignore\n\n  # Deprecated: please use 'webhook.namespaceSelector' instead\n  # namespaceSelector is the selector for restricting the webhook to only\n  # specific namespaces.\n  # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-namespaceselector\n  # for more details.\n  # Example:\n  # namespaceSelector:\n  #    matchLabels:\n  #      sidecar-injector: enabled\n  namespaceSelector: {}\n\n  # Deprecated: please use 'webhook.objectSelector' instead\n  # objectSelector is the selector for restricting the webhook to only\n  # specific labels.\n  # See https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-objectselector\n  # for more details.\n  # Example:\n  # objectSelector:\n  #    matchLabels:\n  #      vault-sidecar-injector: enabled\n  objectSelector: {}\n\n  # Deprecated: please use 'webhook.annotations' instead\n  # Extra annotations to attach to the webhook\n  webhookAnnotations: {}\n\n  certs:\n    # secretName is the name of the secret that has the TLS certificate and\n    # private key to serve the injector webhook. If this is null, then the\n    # injector will default to its automatic management mode that will assign\n    # a service account to the injector to generate its own certificates.\n    secretName: null\n\n    # caBundle is a base64-encoded PEM-encoded certificate bundle for the CA\n    # that signed the TLS certificate that the webhook serves. This must be set\n    # if secretName is non-null unless an external service like cert-manager is\n    # keeping the caBundle updated.\n    caBundle: \"\"\n\n    # certName and keyName are the names of the files within the secret for\n    # the TLS cert and private key, respectively. These have reasonable\n    # defaults but can be customized if necessary.\n    certName: tls.crt\n    keyName: tls.key\n\n  # Security context for the pod template and the injector container\n  # The default pod securityContext is:\n  #   runAsNonRoot: true\n  #   runAsGroup: {{ .Values.injector.gid | default 1000 }}\n  #   runAsUser: {{ .Values.injector.uid | default 100 }}\n  #   fsGroup: {{ .Values.injector.gid | default 1000 }}\n  # and for container is\n  #    allowPrivilegeEscalation: false\n  #    capabilities:\n  #      drop:\n  #        - ALL\n  securityContext:\n    pod: {}\n    container: {}\n\n  resources: {}\n  # resources:\n  #   requests:\n  #     memory: 256Mi\n  #     cpu: 250m\n  #   limits:\n  #     memory: 256Mi\n  #     cpu: 250m\n\n  # extraEnvironmentVars is a list of extra environment variables to set in the\n  # injector deployment.\n  extraEnvironmentVars: {}\n    # KUBERNETES_SERVICE_HOST: kubernetes.default.svc\n\n  # Affinity Settings for injector pods\n  # This can either be a multi-line string or YAML matching the PodSpec's affinity field.\n  # Commenting out or setting as empty the affinity variable, will allow\n  # deployment of multiple replicas to single node services such as Minikube.\n  affinity: |\n    podAntiAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n        - labelSelector:\n            matchLabels:\n              app.kubernetes.io/name: {{ template \"vault.name\" . }}-agent-injector\n              app.kubernetes.io/instance: \"{{ .Release.Name }}\"\n              component: webhook\n          topologyKey: kubernetes.io/hostname\n\n  # Topology settings for injector pods\n  # ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\n  # This should be either a multi-line string or YAML matching the topologySpreadConstraints array\n  # in a PodSpec.\n  topologySpreadConstraints: []\n\n  # Toleration Settings for injector pods\n  # This should be either a multi-line string or YAML matching the Toleration array\n  # in a PodSpec.\n  tolerations: []\n\n  # nodeSelector labels for server pod assignment, formatted as a multi-line string or YAML map.\n  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector\n  # Example:\n  # nodeSelector:\n  #   beta.kubernetes.io/arch: amd64\n  nodeSelector: {}\n\n  # Priority class for injector pods\n  priorityClassName: \"\"\n\n  # Extra annotations to attach to the injector pods\n  # This can either be YAML or a YAML-formatted multi-line templated string map\n  # of the annotations to apply to the injector pods\n  annotations: {}\n\n  # Extra labels to attach to the agent-injector\n  # This should be a YAML map of the labels to apply to the injector\n  extraLabels: {}\n\n  # Should the injector pods run on the host network (useful when using\n  # an alternate CNI in EKS)\n  hostNetwork: false\n\n  # Injector service specific config\n  service:\n    # Extra annotations to attach to the injector service\n    annotations: {}\n\n  # Injector serviceAccount specific config\n  serviceAccount:\n    # Extra annotations to attach to the injector serviceAccount\n    annotations: {}\n\n  # A disruption budget limits the number of pods of a replicated application\n  # that are down simultaneously from voluntary disruptions\n  podDisruptionBudget: {}\n  # podDisruptionBudget:\n  #   maxUnavailable: 1\n\n  # strategy for updating the deployment. This can be a multi-line string or a\n  # YAML map.\n  strategy: {}\n  # strategy: |\n  #   rollingUpdate:\n  #     maxSurge: 25%\n  #     maxUnavailable: 25%\n  #   type: RollingUpdate\n\nserver:\n  # If true, or \"-\" with global.enabled true, Vault server will be installed.\n  # See vault.mode in _helpers.tpl for implementation details.\n  enabled: \"-\"\n\n  # [Enterprise Only] This value refers to a Kubernetes secret that you have\n  # created that contains your enterprise license. If you are not using an\n  # enterprise image or if you plan to introduce the license key via another\n  # route, then leave secretName blank (\"\") or set it to null.\n  # Requires Vault Enterprise 1.8 or later.\n  enterpriseLicense:\n    # The name of the Kubernetes secret that holds the enterprise license. The\n    # secret must be in the same namespace that Vault is installed into.\n    secretName: \"\"\n    # The key within the Kubernetes secret that holds the enterprise license.\n    secretKey: \"license\"\n\n  # Resource requests, limits, etc. for the server cluster placement. This\n  # should map directly to the value of the resources field for a PodSpec.\n  # By default no direct resource request is made.\n\n  image:\n    repository: \"hashicorp/vault\"\n    tag: \"1.15.1\"\n    # Overrides the default Image Pull Policy\n    pullPolicy: IfNotPresent\n\n  # Configure the Update Strategy Type for the StatefulSet\n  # See https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies\n  updateStrategyType: \"OnDelete\"\n\n  # Configure the logging verbosity for the Vault server.\n  # Supported log levels include: trace, debug, info, warn, error\n  logLevel: \"\"\n\n  # Configure the logging format for the Vault server.\n  # Supported log formats include: standard, json\n  logFormat: \"\"\n\n  resources: {}\n  # resources:\n  #   requests:\n  #     memory: 256Mi\n  #     cpu: 250m\n  #   limits:\n  #     memory: 256Mi\n  #     cpu: 250m\n\n  # Ingress allows ingress services to be created to allow external access\n  # from Kubernetes to access Vault pods.\n  # If deployment is on OpenShift, the following block is ignored.\n  # In order to expose the service, use the route section below\n  ingress:\n    enabled: false\n    labels: {}\n      # traffic: external\n    annotations: {}\n      # |\n      # kubernetes.io/ingress.class: nginx\n      # kubernetes.io/tls-acme: \"true\"\n      #   or\n      # kubernetes.io/ingress.class: nginx\n      # kubernetes.io/tls-acme: \"true\"\n\n    # Optionally use ingressClassName instead of deprecated annotation.\n    # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#deprecated-annotation\n    ingressClassName: \"\"\n\n    # As of Kubernetes 1.19, all Ingress Paths must have a pathType configured. The default value below should be sufficient in most cases.\n    # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types for other possible values.\n    pathType: Prefix\n\n    # When HA mode is enabled and K8s service registration is being used,\n    # configure the ingress to point to the Vault active service.\n    activeService: true\n    hosts:\n      - host: chart-example.local\n        paths: []\n    ## Extra paths to prepend to the host configuration. This is useful when working with annotation based services.\n    extraPaths: []\n    # - path: /*\n    #   backend:\n    #     service:\n    #       name: ssl-redirect\n    #       port:\n    #         number: use-annotation\n    tls: []\n    #  - secretName: chart-example-tls\n    #    hosts:\n    #      - chart-example.local\n\n  # hostAliases is a list of aliases to be added to /etc/hosts. Specified as a YAML list.\n  hostAliases: []\n  # - ip: 127.0.0.1\n  #   hostnames:\n  #     - chart-example.local\n\n  # OpenShift only - create a route to expose the service\n  # By default the created route will be of type passthrough\n  route:\n    enabled: false\n\n    # When HA mode is enabled and K8s service registration is being used,\n    # configure the route to point to the Vault active service.\n    activeService: true\n\n    labels: {}\n    annotations: {}\n    host: chart-example.local\n    # tls will be passed directly to the route's TLS config, which\n    # can be used to configure other termination methods that terminate\n    # TLS at the router\n    tls:\n      termination: passthrough\n\n  # authDelegator enables a cluster role binding to be attached to the service\n  # account.  This cluster role binding can be used to setup Kubernetes auth\n  # method. See https://developer.hashicorp.com/vault/docs/auth/kubernetes\n  authDelegator:\n    enabled: true\n\n  # extraInitContainers is a list of init containers. Specified as a YAML list.\n  # This is useful if you need to run a script to provision TLS certificates or\n  # write out configuration files in a dynamic way.\n  extraInitContainers: null\n    # # This example installs a plugin pulled from github into the /usr/local/libexec/vault/oauthapp folder,\n    # # which is defined in the volumes value.\n    # - name: oauthapp\n    #   image: \"alpine\"\n    #   command: [sh, -c]\n    #   args:\n    #     - cd /tmp \u0026\u0026\n    #       wget https://github.com/puppetlabs/vault-plugin-secrets-oauthapp/releases/download/v1.2.0/vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64.tar.xz -O oauthapp.xz \u0026\u0026\n    #       tar -xf oauthapp.xz \u0026\u0026\n    #       mv vault-plugin-secrets-oauthapp-v1.2.0-linux-amd64 /usr/local/libexec/vault/oauthapp \u0026\u0026\n    #       chmod +x /usr/local/libexec/vault/oauthapp\n    #   volumeMounts:\n    #     - name: plugins\n    #       mountPath: /usr/local/libexec/vault\n\n  # extraContainers is a list of sidecar containers. Specified as a YAML list.\n  extraContainers: null\n\n  # shareProcessNamespace enables process namespace sharing between Vault and the extraContainers\n  # This is useful if Vault must be signaled, e.g. to send a SIGHUP for a log rotation\n  shareProcessNamespace: false\n\n  # extraArgs is a string containing additional Vault server arguments.\n  extraArgs: \"\"\n\n  # extraPorts is a list of extra ports. Specified as a YAML list.\n  # This is useful if you need to add additional ports to the statefulset in dynamic way.\n  extraPorts: null\n    # - containerPort: 8300\n    #   name: http-monitoring\n\n  # Used to define custom readinessProbe settings\n  readinessProbe:\n    enabled: true\n    # If you need to use a http path instead of the default exec\n    # path: /v1/sys/health?standbyok=true\n\n    # Port number on which readinessProbe will be checked.\n    port: 8200\n    # When a probe fails, Kubernetes will try failureThreshold times before giving up\n    failureThreshold: 2\n    # Number of seconds after the container has started before probe initiates\n    initialDelaySeconds: 5\n    # How often (in seconds) to perform the probe\n    periodSeconds: 5\n    # Minimum consecutive successes for the probe to be considered successful after having failed\n    successThreshold: 1\n    # Number of seconds after which the probe times out.\n    timeoutSeconds: 3\n  # Used to enable a livenessProbe for the pods\n  livenessProbe:\n    enabled: false\n    path: \"/v1/sys/health?standbyok=true\"\n    # Port number on which livenessProbe will be checked.\n    port: 8200\n    # When a probe fails, Kubernetes will try failureThreshold times before giving up\n    failureThreshold: 2\n    # Number of seconds after the container has started before probe initiates\n    initialDelaySeconds: 60\n    # How often (in seconds) to perform the probe\n    periodSeconds: 5\n    # Minimum consecutive successes for the probe to be considered successful after having failed\n    successThreshold: 1\n    # Number of seconds after which the probe times out.\n    timeoutSeconds: 3\n\n  # Optional duration in seconds the pod needs to terminate gracefully.\n  # See: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/\n  terminationGracePeriodSeconds: 10\n\n  # Used to set the sleep time during the preStop step\n  preStopSleepSeconds: 5\n\n  # Used to define commands to run after the pod is ready.\n  # This can be used to automate processes such as initialization\n  # or boostrapping auth methods.\n  postStart: []\n  # - /bin/sh\n  # - -c\n  # - /vault/userconfig/myscript/run.sh\n\n  # extraEnvironmentVars is a list of extra environment variables to set with the stateful set. These could be\n  # used to include variables required for auto-unseal.\n  extraEnvironmentVars: {}\n    # GOOGLE_REGION: global\n    # GOOGLE_PROJECT: myproject\n    # GOOGLE_APPLICATION_CREDENTIALS: /vault/userconfig/myproject/myproject-creds.json\n\n  # extraSecretEnvironmentVars is a list of extra environment variables to set with the stateful set.\n  # These variables take value from existing Secret objects.\n  extraSecretEnvironmentVars: []\n    # - envName: AWS_SECRET_ACCESS_KEY\n    #   secretName: vault\n    #   secretKey: AWS_SECRET_ACCESS_KEY\n\n  # Deprecated: please use 'volumes' instead.\n  # extraVolumes is a list of extra volumes to mount. These will be exposed\n  # to Vault in the path `/vault/userconfig/\u003cname\u003e/`. The value below is\n  # an array of objects, examples are shown below.\n  extraVolumes: []\n    # - type: secret (or \"configMap\")\n    #   name: my-secret\n    #   path: null # default is `/vault/userconfig`\n\n  # volumes is a list of volumes made available to all containers. These are rendered\n  # via toYaml rather than pre-processed like the extraVolumes value.\n  # The purpose is to make it easy to share volumes between containers.\n  volumes: null\n  #   - name: plugins\n  #     emptyDir: {}\n\n  # volumeMounts is a list of volumeMounts for the main server container. These are rendered\n  # via toYaml rather than pre-processed like the extraVolumes value.\n  # The purpose is to make it easy to share volumes between containers.\n  volumeMounts: null\n  #   - mountPath: /usr/local/libexec/vault\n  #     name: plugins\n  #     readOnly: true\n\n  # Affinity Settings\n  # Commenting out or setting as empty the affinity variable, will allow\n  # deployment to single node services such as Minikube\n  # This should be either a multi-line string or YAML matching the PodSpec's affinity field.\n  affinity: |\n    podAntiAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n        - labelSelector:\n            matchLabels:\n              app.kubernetes.io/name: {{ template \"vault.name\" . }}\n              app.kubernetes.io/instance: \"{{ .Release.Name }}\"\n              component: server\n          topologyKey: kubernetes.io/hostname\n\n  # Topology settings for server pods\n  # ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\n  # This should be either a multi-line string or YAML matching the topologySpreadConstraints array\n  # in a PodSpec.\n  topologySpreadConstraints: []\n\n  # Toleration Settings for server pods\n  # This should be either a multi-line string or YAML matching the Toleration array\n  # in a PodSpec.\n  tolerations: []\n\n  # nodeSelector labels for server pod assignment, formatted as a multi-line string or YAML map.\n  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector\n  # Example:\n  # nodeSelector:\n  #   beta.kubernetes.io/arch: amd64\n  nodeSelector: {}\n\n  # Enables network policy for server pods\n  networkPolicy:\n    enabled: false\n    egress: []\n    # egress:\n    # - to:\n    #   - ipBlock:\n    #       cidr: 10.0.0.0/24\n    #   ports:\n    #   - protocol: TCP\n    #     port: 443\n\n  # Priority class for server pods\n  priorityClassName: \"\"\n\n  # Extra labels to attach to the server pods\n  # This should be a YAML map of the labels to apply to the server pods\n  extraLabels: {}\n\n  # Extra annotations to attach to the server pods\n  # This can either be YAML or a YAML-formatted multi-line templated string map\n  # of the annotations to apply to the server pods\n  annotations: {}\n\n  # Enables a headless service to be used by the Vault Statefulset\n  service:\n    enabled: true\n    # Enable or disable the vault-active service, which selects Vault pods that\n    # have labeled themselves as the cluster leader with `vault-active: \"true\"`.\n    active:\n      enabled: true\n      # Extra annotations for the service definition. This can either be YAML or a\n      # YAML-formatted multi-line templated string map of the annotations to apply\n      # to the active service.\n      annotations: {}\n    # Enable or disable the vault-standby service, which selects Vault pods that\n    # have labeled themselves as a cluster follower with `vault-active: \"false\"`.\n    standby:\n      enabled: true\n      # Extra annotations for the service definition. This can either be YAML or a\n      # YAML-formatted multi-line templated string map of the annotations to apply\n      # to the standby service.\n      annotations: {}\n    # If enabled, the service selectors will include `app.kubernetes.io/instance: {{ .Release.Name }}`\n    # When disabled, services may select Vault pods not deployed from the chart.\n    # Does not affect the headless vault-internal service with `ClusterIP: None`\n    instanceSelector:\n      enabled: true\n    # clusterIP controls whether a Cluster IP address is attached to the\n    # Vault service within Kubernetes.  By default, the Vault service will\n    # be given a Cluster IP address, set to None to disable.  When disabled\n    # Kubernetes will create a \"headless\" service.  Headless services can be\n    # used to communicate with pods directly through DNS instead of a round-robin\n    # load balancer.\n    # clusterIP: None\n\n    # Configures the service type for the main Vault service.  Can be ClusterIP\n    # or NodePort.\n    #type: ClusterIP\n\n    # The IP family and IP families options are to set the behaviour in a dual-stack environment.\n    # Omitting these values will let the service fall back to whatever the CNI dictates the defaults\n    # should be.\n    # These are only supported for kubernetes versions \u003e=1.23.0\n    #\n    # Configures the service's supported IP family policy, can be either:\n    #     SingleStack: Single-stack service. The control plane allocates a cluster IP for the Service, using the first configured service cluster IP range.\n    #     PreferDualStack: Allocates IPv4 and IPv6 cluster IPs for the Service.\n    #     RequireDualStack: Allocates Service .spec.ClusterIPs from both IPv4 and IPv6 address ranges.\n    ipFamilyPolicy: \"\"\n    \n    # Sets the families that should be supported and the order in which they should be applied to ClusterIP as well.\n    # Can be IPv4 and/or IPv6.\n    ipFamilies: []\n\n    # Do not wait for pods to be ready before including them in the services'\n    # targets. Does not apply to the headless service, which is used for\n    # cluster-internal communication.\n    publishNotReadyAddresses: true\n\n    # The externalTrafficPolicy can be set to either Cluster or Local\n    # and is only valid for LoadBalancer and NodePort service types.\n    # The default value is Cluster.\n    # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy\n    externalTrafficPolicy: Cluster\n\n    # If type is set to \"NodePort\", a specific nodePort value can be configured,\n    # will be random if left blank.\n    #nodePort: 30000\n\n    # When HA mode is enabled\n    # If type is set to \"NodePort\", a specific nodePort value can be configured,\n    # will be random if left blank.\n    #activeNodePort: 30001\n\n    # When HA mode is enabled\n    # If type is set to \"NodePort\", a specific nodePort value can be configured,\n    # will be random if left blank.\n    #standbyNodePort: 30002\n\n    # Port on which Vault server is listening\n    port: 8200\n    # Target port to which the service should be mapped to\n    targetPort: 8200\n    # Extra annotations for the service definition. This can either be YAML or a\n    # YAML-formatted multi-line templated string map of the annotations to apply\n    # to the service.\n    annotations: {}\n\n  # This configures the Vault Statefulset to create a PVC for data\n  # storage when using the file or raft backend storage engines.\n  # See https://developer.hashicorp.com/vault/docs/configuration/storage to know more\n  dataStorage:\n    enabled: true\n    # Size of the PVC created\n    size: 10Gi\n    # Location where the PVC will be mounted.\n    mountPath: \"/vault/data\"\n    # Name of the storage class to use.  If null it will use the\n    # configured default Storage Class.\n    storageClass: openebs-jiva-csi-default\n    # Access Mode of the storage device being used for the PVC\n    accessMode: ReadWriteOnce\n    # Annotations to apply to the PVC\n    annotations: {}\n\n  # This configures the Vault Statefulset to create a PVC for audit\n  # logs.  Once Vault is deployed, initialized, and unsealed, Vault must\n  # be configured to use this for audit logs.  This will be mounted to\n  # /vault/audit\n  # See https://developer.hashicorp.com/vault/docs/audit to know more\n  auditStorage:\n    enabled: false\n    # Size of the PVC created\n    size: 10Gi\n    # Location where the PVC will be mounted.\n    mountPath: \"/vault/audit\"\n    # Name of the storage class to use.  If null it will use the\n    # configured default Storage Class.\n    storageClass: null\n    # Access Mode of the storage device being used for the PVC\n    accessMode: ReadWriteOnce\n    # Annotations to apply to the PVC\n    annotations: {}\n\n  # Run Vault in \"dev\" mode. This requires no further setup, no state management,\n  # and no initialization. This is useful for experimenting with Vault without\n  # needing to unseal, store keys, et. al. All data is lost on restart - do not\n  # use dev mode for anything other than experimenting.\n  # See https://developer.hashicorp.com/vault/docs/concepts/dev-server to know more\n  dev:\n    enabled: false\n\n    # Set VAULT_DEV_ROOT_TOKEN_ID value\n    devRootToken: \"root\"\n\n  # Run Vault in \"standalone\" mode. This is the default mode that will deploy if\n  # no arguments are given to helm. This requires a PVC for data storage to use\n  # the \"file\" backend.  This mode is not highly available and should not be scaled\n  # past a single replica.\n  standalone:\n    enabled: \"-\"\n\n    # config is a raw string of default configuration when using a Stateful\n    # deployment. Default is to use a PersistentVolumeClaim mounted at /vault/data\n    # and store data there. This is only used when using a Replica count of 1, and\n    # using a stateful set. This should be HCL.\n\n    # Note: Configuration files are stored in ConfigMaps so sensitive data\n    # such as passwords should be either mounted through extraSecretEnvironmentVars\n    # or through a Kube secret.  For more information see:\n    # https://developer.hashicorp.com/vault/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations\n    config: |\n      ui = true\n\n      listener \"tcp\" {\n        tls_disable = 1\n        address = \"[::]:8200\"\n        cluster_address = \"[::]:8201\"\n        # Enable unauthenticated metrics access (necessary for Prometheus Operator)\n        #telemetry {\n        #  unauthenticated_metrics_access = \"true\"\n        #}\n      }\n      storage \"file\" {\n        path = \"/vault/data\"\n      }\n\n      # Example configuration for using auto-unseal, using Google Cloud KMS. The\n      # GKMS keys must already exist, and the cluster must have a service account\n      # that is authorized to access GCP KMS.\n      #seal \"gcpckms\" {\n      #   project     = \"vault-helm-dev\"\n      #   region      = \"global\"\n      #   key_ring    = \"vault-helm-unseal-kr\"\n      #   crypto_key  = \"vault-helm-unseal-key\"\n      #}\n\n      # Example configuration for enabling Prometheus metrics in your config.\n      #telemetry {\n      #  prometheus_retention_time = \"30s\"\n      #  disable_hostname = true\n      #}\n\n  # Run Vault in \"HA\" mode. There are no storage requirements unless the audit log\n  # persistence is required.  In HA mode Vault will configure itself to use Consul\n  # for its storage backend.  The default configuration provided will work the Consul\n  # Helm project by default.  It is possible to manually configure Vault to use a\n  # different HA backend.\n  ha:\n    enabled: false\n    replicas: 3\n\n    # Set the api_addr configuration for Vault HA\n    # See https://developer.hashicorp.com/vault/docs/configuration#api_addr\n    # If set to null, this will be set to the Pod IP Address\n    apiAddr: null\n\n    # Set the cluster_addr confuguration for Vault HA\n    # See https://developer.hashicorp.com/vault/docs/configuration#cluster_addr\n    # If set to null, this will be set to https://$(HOSTNAME).{{ template \"vault.fullname\" . }}-internal:8201\n    clusterAddr: null\n\n    # Enables Vault's integrated Raft storage.  Unlike the typical HA modes where\n    # Vault's persistence is external (such as Consul), enabling Raft mode will create\n    # persistent volumes for Vault to store data according to the configuration under server.dataStorage.\n    # The Vault cluster will coordinate leader elections and failovers internally.\n    raft:\n\n      # Enables Raft integrated storage\n      enabled: false\n      # Set the Node Raft ID to the name of the pod\n      setNodeId: false\n\n      # Note: Configuration files are stored in ConfigMaps so sensitive data\n      # such as passwords should be either mounted through extraSecretEnvironmentVars\n      # or through a Kube secret.  For more information see:\n      # https://developer.hashicorp.com/vault/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations\n      config: |\n        ui = true\n\n        listener \"tcp\" {\n          tls_disable = 1\n          address = \"[::]:8200\"\n          cluster_address = \"[::]:8201\"\n          # Enable unauthenticated metrics access (necessary for Prometheus Operator)\n          #telemetry {\n          #  unauthenticated_metrics_access = \"true\"\n          #}\n        }\n\n        storage \"raft\" {\n          path = \"/vault/data\"\n        }\n\n        service_registration \"kubernetes\" {}\n\n    # config is a raw string of default configuration when using a Stateful\n    # deployment. Default is to use a Consul for its HA storage backend.\n    # This should be HCL.\n\n    # Note: Configuration files are stored in ConfigMaps so sensitive data\n    # such as passwords should be either mounted through extraSecretEnvironmentVars\n    # or through a Kube secret.  For more information see:\n    # https://developer.hashicorp.com/vault/docs/platform/k8s/helm/run#protecting-sensitive-vault-configurations\n    config: |\n      ui = true\n\n      listener \"tcp\" {\n        tls_disable = 1\n        address = \"[::]:8200\"\n        cluster_address = \"[::]:8201\"\n      }\n      storage \"consul\" {\n        path = \"vault\"\n        address = \"HOST_IP:8500\"\n      }\n\n      service_registration \"kubernetes\" {}\n\n      # Example configuration for using auto-unseal, using Google Cloud KMS. The\n      # GKMS keys must already exist, and the cluster must have a service account\n      # that is authorized to access GCP KMS.\n      #seal \"gcpckms\" {\n      #   project     = \"vault-helm-dev-246514\"\n      #   region      = \"global\"\n      #   key_ring    = \"vault-helm-unseal-kr\"\n      #   crypto_key  = \"vault-helm-unseal-key\"\n      #}\n\n      # Example configuration for enabling Prometheus metrics.\n      # If you are using Prometheus Operator you can enable a ServiceMonitor resource below.\n      # You may wish to enable unauthenticated metrics in the listener block above.\n      #telemetry {\n      #  prometheus_retention_time = \"30s\"\n      #  disable_hostname = true\n      #}\n\n    # A disruption budget limits the number of pods of a replicated application\n    # that are down simultaneously from voluntary disruptions\n    disruptionBudget:\n      enabled: true\n\n    # maxUnavailable will default to (n/2)-1 where n is the number of\n    # replicas. If you'd like a custom value, you can specify an override here.\n      maxUnavailable: null\n\n  # Definition of the serviceAccount used to run Vault.\n  # These options are also used when using an external Vault server to validate\n  # Kubernetes tokens.\n  serviceAccount:\n    # Specifies whether a service account should be created\n    create: true\n    # The name of the service account to use.\n    # If not set and create is true, a name is generated using the fullname template\n    name: \"\"\n    # Create a Secret API object to store a non-expiring token for the service account.\n    # Prior to v1.24.0, Kubernetes used to generate this secret for each service account by default.\n    # Kubernetes now recommends using short-lived tokens from the TokenRequest API or projected volumes instead if possible.\n    # For more details, see https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets\n    # serviceAccount.create must be equal to 'true' in order to use this feature.\n    createSecret: false\n    # Extra annotations for the serviceAccount definition. This can either be\n    # YAML or a YAML-formatted multi-line templated string map of the\n    # annotations to apply to the serviceAccount.\n    annotations: {}\n    # Extra labels to attach to the serviceAccount\n    # This should be a YAML map of the labels to apply to the serviceAccount\n    extraLabels: {}\n    # Enable or disable a service account role binding with the permissions required for\n    # Vault's Kubernetes service_registration config option.\n    # See https://developer.hashicorp.com/vault/docs/configuration/service-registration/kubernetes\n    serviceDiscovery:\n      enabled: true\n\n  # Settings for the statefulSet used to run Vault.\n  statefulSet:\n    # Extra annotations for the statefulSet. This can either be YAML or a\n    # YAML-formatted multi-line templated string map of the annotations to apply\n    # to the statefulSet.\n    annotations: {}\n\n    # Set the pod and container security contexts.\n    # If not set, these will default to, and for *not* OpenShift:\n    # pod:\n    #   runAsNonRoot: true\n    #   runAsGroup: {{ .Values.server.gid | default 1000 }}\n    #   runAsUser: {{ .Values.server.uid | default 100 }}\n    #   fsGroup: {{ .Values.server.gid | default 1000 }}\n    # container:\n    #   allowPrivilegeEscalation: false\n    #\n    # If not set, these will default to, and for OpenShift:\n    # pod: {}\n    # container: {}\n    securityContext:\n      pod: {}\n      container: {}\n\n  # Should the server pods run on the host network\n  hostNetwork: false\n\n# Vault UI\nui:\n  # True if you want to create a Service entry for the Vault UI.\n  #\n  # serviceType can be used to control the type of service created. For\n  # example, setting this to \"LoadBalancer\" will create an external load\n  # balancer (for supported K8S installations) to access the UI.\n  enabled: false\n  publishNotReadyAddresses: true\n  # The service should only contain selectors for active Vault pod\n  activeVaultPodOnly: false\n  serviceType: \"ClusterIP\"\n  serviceNodePort: null\n  externalPort: 8200\n  targetPort: 8200\n\n  # The IP family and IP families options are to set the behaviour in a dual-stack environment.\n  # Omitting these values will let the service fall back to whatever the CNI dictates the defaults\n  # should be.\n  # These are only supported for kubernetes versions \u003e=1.23.0\n  #\n  # Configures the service's supported IP family, can be either:\n  #     SingleStack: Single-stack service. The control plane allocates a cluster IP for the Service, using the first configured service cluster IP range.\n  #     PreferDualStack: Allocates IPv4 and IPv6 cluster IPs for the Service.\n  #     RequireDualStack: Allocates Service .spec.ClusterIPs from both IPv4 and IPv6 address ranges.\n  serviceIPFamilyPolicy: \"\"\n\n  # Sets the families that should be supported and the order in which they should be applied to ClusterIP as well\n  # Can be IPv4 and/or IPv6.\n  serviceIPFamilies: []\n\n  # The externalTrafficPolicy can be set to either Cluster or Local\n  # and is only valid for LoadBalancer and NodePort service types.\n  # The default value is Cluster.\n  # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy\n  externalTrafficPolicy: Cluster\n\n  #loadBalancerSourceRanges:\n  #   - 10.0.0.0/16\n  #   - 1.78.23.3/32\n\n  # loadBalancerIP:\n\n  # Extra annotations to attach to the ui service\n  # This can either be YAML or a YAML-formatted multi-line templated string map\n  # of the annotations to apply to the ui service\n  annotations: {}\n\n# secrets-store-csi-driver-provider-vault\ncsi:\n  # True if you want to install a secrets-store-csi-driver-provider-vault daemonset.\n  #\n  # Requires installing the secrets-store-csi-driver separately, see:\n  # https://github.com/kubernetes-sigs/secrets-store-csi-driver#install-the-secrets-store-csi-driver\n  #\n  # With the driver and provider installed, you can mount Vault secrets into volumes\n  # similar to the Vault Agent injector, and you can also sync those secrets into\n  # Kubernetes secrets.\n  enabled: false\n\n  image:\n    repository: \"hashicorp/vault-csi-provider\"\n    tag: \"1.4.1\"\n    pullPolicy: IfNotPresent\n\n  # volumes is a list of volumes made available to all containers. These are rendered\n  # via toYaml rather than pre-processed like the extraVolumes value.\n  # The purpose is to make it easy to share volumes between containers.\n  volumes: null\n  # - name: tls\n  #   secret:\n  #     secretName: vault-tls\n\n  # volumeMounts is a list of volumeMounts for the main server container. These are rendered\n  # via toYaml rather than pre-processed like the extraVolumes value.\n  # The purpose is to make it easy to share volumes between containers.\n  volumeMounts: null\n  # - name: tls\n  #   mountPath: \"/vault/tls\"\n  #   readOnly: true\n\n  resources: {}\n  # resources:\n  #   requests:\n  #     cpu: 50m\n  #     memory: 128Mi\n  #   limits:\n  #     cpu: 50m\n  #     memory: 128Mi\n\n  # Override the default secret name for the CSI Provider's HMAC key used for\n  # generating secret versions.\n  hmacSecretName: \"\"\n\n  # Settings for the daemonSet used to run the provider.\n  daemonSet:\n    updateStrategy:\n      type: RollingUpdate\n      maxUnavailable: \"\"\n    # Extra annotations for the daemonSet. This can either be YAML or a\n    # YAML-formatted multi-line templated string map of the annotations to apply\n    # to the daemonSet.\n    annotations: {}\n    # Provider host path (must match the CSI provider's path)\n    providersDir: \"/etc/kubernetes/secrets-store-csi-providers\"\n    # Kubelet host path\n    kubeletRootDir: \"/var/lib/kubelet\"\n    # Extra labels to attach to the vault-csi-provider daemonSet\n    # This should be a YAML map of the labels to apply to the csi provider daemonSet\n    extraLabels: {}\n    # security context for the pod template and container in the csi provider daemonSet\n    securityContext:\n      pod: {}\n      container: {}\n\n  pod:\n    # Extra annotations for the provider pods. This can either be YAML or a\n    # YAML-formatted multi-line templated string map of the annotations to apply\n    # to the pod.\n    annotations: {}\n\n    # Toleration Settings for provider pods\n    # This should be either a multi-line string or YAML matching the Toleration array\n    # in a PodSpec.\n    tolerations: []\n\n    # nodeSelector labels for csi pod assignment, formatted as a multi-line string or YAML map.\n    # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector\n    # Example:\n    # nodeSelector:\n    #   beta.kubernetes.io/arch: amd64\n    nodeSelector: {}\n\n    # Affinity Settings\n    # This should be either a multi-line string or YAML matching the PodSpec's affinity field.\n    affinity: {}\n\n    # Extra labels to attach to the vault-csi-provider pod\n    # This should be a YAML map of the labels to apply to the csi provider pod\n    extraLabels: {}\n\n  agent:\n    enabled: true\n    extraArgs: []\n\n    image:\n      repository: \"hashicorp/vault\"\n      tag: \"1.15.1\"\n      pullPolicy: IfNotPresent\n\n    logFormat: standard\n    logLevel: info\n\n    resources: {}\n    # resources:\n    #   requests:\n    #     memory: 256Mi\n    #     cpu: 250m\n    #   limits:\n    #     memory: 256Mi\n    #     cpu: 250m\n\n  # Priority class for csi pods\n  priorityClassName: \"\"\n\n  serviceAccount:\n    # Extra annotations for the serviceAccount definition. This can either be\n    # YAML or a YAML-formatted multi-line templated string map of the\n    # annotations to apply to the serviceAccount.\n    annotations: {}\n\n    # Extra labels to attach to the vault-csi-provider serviceAccount\n    # This should be a YAML map of the labels to apply to the csi provider serviceAccount\n    extraLabels: {}\n\n  # Used to configure readinessProbe for the pods.\n  readinessProbe:\n    # When a probe fails, Kubernetes will try failureThreshold times before giving up\n    failureThreshold: 2\n    # Number of seconds after the container has started before probe initiates\n    initialDelaySeconds: 5\n    # How often (in seconds) to perform the probe\n    periodSeconds: 5\n    # Minimum consecutive successes for the probe to be considered successful after having failed\n    successThreshold: 1\n    # Number of seconds after which the probe times out.\n    timeoutSeconds: 3\n  # Used to configure livenessProbe for the pods.\n  livenessProbe:\n    # When a probe fails, Kubernetes will try failureThreshold times before giving up\n    failureThreshold: 2\n    # Number of seconds after the container has started before probe initiates\n    initialDelaySeconds: 5\n    # How often (in seconds) to perform the probe\n    periodSeconds: 5\n    # Minimum consecutive successes for the probe to be considered successful after having failed\n    successThreshold: 1\n    # Number of seconds after which the probe times out.\n    timeoutSeconds: 3\n\n  # Enables debug logging.\n  debug: false\n\n  # Pass arbitrary additional arguments to vault-csi-provider.\n  # See https://developer.hashicorp.com/vault/docs/platform/k8s/csi/configurations#command-line-arguments\n  # for the available command line flags.\n  extraArgs: []\n\n# Vault is able to collect and publish various runtime metrics.\n# Enabling this feature requires setting adding `telemetry{}` stanza to\n# the Vault configuration. There are a few examples included in the `config` sections above.\n#\n# For more information see:\n# https://developer.hashicorp.com/vault/docs/configuration/telemetry\n# https://developer.hashicorp.com/vault/docs/internals/telemetry\nserverTelemetry:\n  # Enable support for the Prometheus Operator. Currently, this chart does not support\n  # authenticating to Vault's metrics endpoint, so the following `telemetry{}` must be included\n  # in the `listener \"tcp\"{}` stanza\n  #  telemetry {\n  #    unauthenticated_metrics_access = \"true\"\n  #  }\n  #\n  # See the `standalone.config` for a more complete example of this.\n  #\n  # In addition, a top level `telemetry{}` stanza must also be included in the Vault configuration:\n  #\n  # example:\n  #  telemetry {\n  #    prometheus_retention_time = \"30s\"\n  #    disable_hostname = true\n  #  }\n  #\n  # Configuration for monitoring the Vault server.\n  serviceMonitor:\n    # The Prometheus operator *must* be installed before enabling this feature,\n    # if not the chart will fail to install due to missing CustomResourceDefinitions\n    # provided by the operator.\n    #\n    # Instructions on how to install the Helm chart can be found here:\n    #  https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack\n    # More information can be found here:\n    #  https://github.com/prometheus-operator/prometheus-operator\n    #  https://github.com/prometheus-operator/kube-prometheus\n\n    # Enable deployment of the Vault Server ServiceMonitor CustomResource.\n    enabled: false\n\n    # Selector labels to add to the ServiceMonitor.\n    # When empty, defaults to:\n    #  release: prometheus\n    selectors: {}\n\n    # Interval at which Prometheus scrapes metrics\n    interval: 30s\n\n    # Timeout for Prometheus scrapes\n    scrapeTimeout: 10s\n\n  prometheusRules:\n      # The Prometheus operator *must* be installed before enabling this feature,\n      # if not the chart will fail to install due to missing CustomResourceDefinitions\n      # provided by the operator.\n\n      # Deploy the PrometheusRule custom resource for AlertManager based alerts.\n      # Requires that AlertManager is properly deployed.\n      enabled: false\n\n      # Selector labels to add to the PrometheusRules.\n      # When empty, defaults to:\n      #  release: prometheus\n      selectors: {}\n\n      # Some example rules.\n      rules: []\n      #  - alert: vault-HighResponseTime\n      #    annotations:\n      #      message: The response time of Vault is over 500ms on average over the last 5 minutes.\n      #    expr: vault_core_handle_request{quantile=\"0.5\", namespace=\"mynamespace\"} \u003e 500\n      #    for: 5m\n      #    labels:\n      #      severity: warning\n      #  - alert: vault-HighResponseTime\n      #    annotations:\n      #      message: The response time of Vault is over 1s on average over the last 5 minutes.\n      #    expr: vault_core_handle_request{quantile=\"0.5\", namespace=\"mynamespace\"} \u003e 1000\n      #    for: 5m\n      #    labels:\n      #      severity: critical"
            ],
            "verify": false,
            "version": "0.26.0",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "helm_release",
      "name": "vault_secrets_operator",
      "provider": "provider[\"registry.terraform.io/hashicorp/helm\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "atomic": false,
            "chart": "vault-secrets-operator",
            "cleanup_on_fail": false,
            "create_namespace": false,
            "dependency_update": false,
            "description": null,
            "devel": null,
            "disable_crd_hooks": false,
            "disable_openapi_validation": false,
            "disable_webhooks": false,
            "force_update": false,
            "id": "vault-secrets-operator",
            "keyring": null,
            "lint": false,
            "manifest": null,
            "max_history": 0,
            "metadata": [
              {
                "app_version": "0.3.4",
                "chart": "vault-secrets-operator",
                "name": "vault-secrets-operator",
                "namespace": "vault",
                "revision": 1,
                "values": "{\"controller\":{\"affinity\":{},\"annotations\":{},\"controllerConfigMapYaml\":{\"health\":{\"healthProbeBindAddress\":\":8081\"},\"leaderElection\":{\"leaderElect\":true,\"resourceName\":\"b0d477c0.hashicorp.com\"},\"metrics\":{\"bindAddress\":\"127.0.0.1:8080\"},\"webhook\":{\"port\":9443}},\"extraLabels\":{},\"hostAliases\":[],\"imagePullSecrets\":[],\"kubeRbacProxy\":{\"image\":{\"repository\":\"gcr.io/kubebuilder/kube-rbac-proxy\",\"tag\":\"v0.14.4\"},\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"128Mi\"},\"requests\":{\"cpu\":\"5m\",\"memory\":\"64Mi\"}}},\"kubernetesClusterDomain\":\"cluster.local\",\"manager\":{\"clientCache\":{\"cacheSize\":null,\"persistenceModel\":\"\",\"storageEncryption\":{\"appRole\":{\"roleId\":\"\",\"secretRef\":\"\"},\"aws\":{\"headerValue\":\"\",\"iamEndpoint\":\"\",\"irsaServiceAccount\":\"\",\"region\":\"\",\"role\":\"\",\"secretRef\":\"\",\"sessionName\":\"\",\"stsEndpoint\":\"\"},\"enabled\":false,\"headers\":{},\"jwt\":{\"role\":\"\",\"secretRef\":\"\",\"serviceAccount\":\"default\",\"tokenAudiences\":[]},\"keyName\":\"\",\"kubernetes\":{\"role\":\"\",\"serviceAccount\":null,\"tokenAudiences\":[]},\"method\":\"kubernetes\",\"mount\":\"kubernetes\",\"namespace\":\"\",\"params\":{},\"transitMount\":\"\",\"vaultConnectionRef\":\"default\"}},\"extraArgs\":[],\"extraEnv\":[],\"image\":{\"repository\":\"hashicorp/vault-secrets-operator\",\"tag\":\"0.3.4\"},\"maxConcurrentReconciles\":null,\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"128Mi\"},\"requests\":{\"cpu\":\"10m\",\"memory\":\"64Mi\"}}},\"nodeSelector\":{},\"podSecurityContext\":{\"runAsNonRoot\":true},\"preDeleteHookTimeoutSeconds\":120,\"replicas\":1,\"securityContext\":{\"allowPrivilegeEscalation\":false},\"terminationGracePeriodSeconds\":120,\"tolerations\":[]},\"defaultAuthMethod\":{\"appRole\":{\"roleId\":\"\",\"secretRef\":\"\"},\"aws\":{\"headerValue\":\"\",\"iamEndpoint\":\"\",\"irsaServiceAccount\":\"\",\"region\":\"\",\"role\":\"\",\"secretRef\":\"\",\"sessionName\":\"\",\"stsEndpoint\":\"\"},\"enabled\":false,\"headers\":{},\"jwt\":{\"role\":\"\",\"secretRef\":\"\",\"serviceAccount\":\"default\",\"tokenAudiences\":[]},\"kubernetes\":{\"role\":\"\",\"serviceAccount\":\"default\",\"tokenAudiences\":[]},\"method\":\"kubernetes\",\"mount\":\"kubernetes\",\"namespace\":\"\",\"params\":{}},\"defaultVaultConnection\":{\"address\":\"\",\"caCertSecret\":\"\",\"enabled\":false,\"headers\":{},\"skipTLSVerify\":false,\"tlsServerName\":\"\"},\"metricsService\":{\"ports\":[{\"name\":\"https\",\"port\":8443,\"protocol\":\"TCP\",\"targetPort\":\"https\"}],\"type\":\"ClusterIP\"},\"telemetry\":{\"serviceMonitor\":{\"bearerTokenFile\":\"/var/run/secrets/kubernetes.io/serviceaccount/token\",\"enabled\":false,\"interval\":\"30s\",\"path\":\"/metrics\",\"port\":\"https\",\"scheme\":\"https\",\"scrapeTimeout\":\"10s\",\"selectors\":{}}},\"tests\":{\"enabled\":true}}",
                "version": "0.3.4"
              }
            ],
            "name": "vault-secrets-operator",
            "namespace": "vault",
            "pass_credentials": false,
            "postrender": [],
            "recreate_pods": false,
            "render_subchart_notes": true,
            "replace": false,
            "repository": "https://helm.releases.hashicorp.com",
            "repository_ca_file": null,
            "repository_cert_file": null,
            "repository_key_file": null,
            "repository_password": null,
            "repository_username": null,
            "reset_values": false,
            "reuse_values": false,
            "set": [],
            "set_list": [],
            "set_sensitive": [],
            "skip_crds": false,
            "status": "deployed",
            "timeout": 300,
            "values": [
              "# Copyright (c) HashiCorp, Inc.\n# SPDX-License-Identifier: BUSL-1.1\n\n# Top level configuration for the vault secrets operator deployment.\n# This consists of a controller and a kube rbac proxy container.\ncontroller:\n\n  # Set the number of replicas for the operator.\n  # @type: integer\n  replicas: 1\n\n  # Host Aliases settings for vault-secrets-operator pod.\n  # The value is an array of PodSpec HostAlias maps.\n  # ref: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/\n  # Example:\n  # hostAliases:\n  #   - ip: 192.168.1.100\n  #     hostnames:\n  #     - vault.example.com\n  # @type: array\u003cmap\u003e\n  hostAliases: []\n\n  # nodeSelector labels for vault-secrets-operator pod assignment.\n  # @type: map\n  # ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector\n  # Example:\n  # nodeSelector:\n  #   beta.kubernetes.io/arch: amd64\n  nodeSelector: {}\n  # Toleration Settings for vault-secrets-operator pod.\n  # The value is an array of PodSpec Toleration maps.\n  # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/\n  # @type: array\u003cmap\u003e\n  # Example:\n  # tolerations:\n  #  - key: \"key1\"\n  #    operator: \"Equal\"\n  #    value: \"value1\"\n  #    effect: \"NoSchedule\"\n  tolerations: []\n\n  # Affinity settings for vault-secrets-operator pod.\n  # The value is a map of PodSpec Affinity maps.\n  # ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity\n  # Example:\n  # affinity:\n  #   nodeAffinity:\n  #     requiredDuringSchedulingIgnoredDuringExecution:\n  #       nodeSelectorTerms:\n  #       - matchExpressions:\n  #         - key: topology.kubernetes.io/zone\n  #           operator: In\n  #           values:\n  #           - antarctica-east1\n  #           - antarctica-west1\n  affinity: {}\n\n  # Settings related to the kubeRbacProxy container. This container is an HTTP proxy for the\n  # controller manager which performs RBAC authorization against the Kubernetes API using SubjectAccessReviews.\n  kubeRbacProxy:\n    # Image sets the repo and tag of the kube-rbac-proxy image to use for the controller.\n    image:\n      repository: gcr.io/kubebuilder/kube-rbac-proxy\n      tag: v0.14.4\n\n    # Configures the default resources for the kube rbac proxy container.\n    # For more information on configuring resources, see the K8s documentation:\n    # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n    # @recurse: true\n    # @type: map\n    resources:\n      limits:\n        cpu: 500m\n        memory: 128Mi\n      requests:\n        cpu: 5m\n        memory: 64Mi\n\n  # Image pull secret to use for private container registry authentication which will be applied to the controllers\n  # service account. Alternatively, the value may be specified as an array of strings.\n  # Example:\n  # ```yaml\n  # imagePullSecrets:\n  #   - name: pull-secret-name-1\n  #   - name: pull-secret-name-2\n  # ```\n  # Refer to https://kubernetes.io/docs/concepts/containers/images/#using-a-private-registry.\n  # @type: array\u003cmap\u003e\n  imagePullSecrets: []\n\n  # Extra labels to attach to the deployment. This should be formatted as a YAML object (map)\n  extraLabels: {}\n\n  # This value defines additional annotations for the deployment. This should be formatted as a YAML object (map)\n  annotations: {}\n\n  # Settings related to the vault-secrets-operator container.\n  manager:\n\n    # Image sets the repo and tag of the vault-secrets-operator image to use for the controller.\n    image:\n      repository: hashicorp/vault-secrets-operator\n      tag: 0.3.4\n\n    # Configures the client cache which is used by the controller to cache (and potentially persist) vault tokens that\n    # are the result of using the VaultAuthMethod. This enables re-use of Vault Tokens\n    # throughout their TTLs as well as the ability to renew.\n    # Persistence is only useful in the context of Dynamic Secrets, so \"none\" is an okay default.\n    clientCache:\n      # Defines the `-client-cache-persistence-model` which caches+persists vault tokens.\n      # Valid values are:\n      # \"none\" - in-memory client cache is used, no tokens are persisted.\n      # \"direct-unencrypted\" - in-memory client cache is persisted, unencrypted. This is NOT recommended for any production workload.\n      # \"direct-encrypted\" - in-memory client cache is persisted encrypted using the Vault Transit engine.\n      # Note: It is strongly encouraged to not use the setting of \"direct-unencrypted\" in\n      # production due to the potential of vault tokens being leaked as they would then be stored\n      # in clear text.\n      #\n      # default: \"none\"\n      # @type: string\n      persistenceModel: \"\"\n\n      # Defines the size of the in-memory LRU cache *in entries*, that is used by the client cache controller.\n      # Larger numbers will increase memory usage by the controller, lower numbers will cause more frequent evictions\n      # of the client cache which can result in additional Vault client counts.\n      #\n      # default: 10000\n      # @type: integer\n      cacheSize:\n\n      # StorageEncryption provides the necessary configuration to encrypt the client storage\n      # cache within Kubernetes objects using (required) Vault Transit Engine.\n      # This should only be configured when client cache persistence with encryption is enabled and\n      # will deploy an additional VaultAuthMethod to be used by the Vault Transit Engine.\n      # E.g. when `controller.manager.clientCache.persistenceModel=direct-encrypted`\n      # Supported Vault authentication methods for the Transit Auth method are: jwt, appRole,\n      # aws, and kubernetes.\n      # Typically, there should only ever be one VaultAuth configured with\n      # StorageEncryption in the Cluster.\n      storageEncryption:\n        # toggles the deployment of the Transit VaultAuthMethod CR.\n        # @type: boolean\n        enabled: false\n\n        # Vault Connection Ref to be used by the Transit VaultAuthMethod.\n        # Default setting will use the default VaultConnectionRef, which must also be configured.\n        # @type: string\n        vaultConnectionRef: default\n\n        # KeyName to use for encrypt/decrypt operations via Vault Transit.\n        # @type: string\n        keyName: \"\"\n\n        # Mount path for the Transit VaultAuthMethod.\n        # @type: string\n        transitMount: \"\"\n\n        # Vault namespace for the Transit VaultAuthMethod CR.\n        # @type: string\n        namespace: \"\"\n\n        # Vault Auth method to be used with the Transit VaultAuthMethod CR.\n        # @type: string\n        method: kubernetes\n\n        # Mount path for the Transit VaultAuthMethod.\n        # @type: string\n        mount: kubernetes\n\n        # Vault Kubernetes auth method specific configuration\n        kubernetes:\n          # Vault Auth Role to use\n          # This is a required field and must be setup in Vault prior to deploying the helm chart\n          # if `defaultAuthMethod.enabled=true`\n          # @type: string\n          role: \"\"\n\n          # Kubernetes ServiceAccount associated with the Transit Vault Auth Role\n          # Defaults to using the Operator's service-account.\n          # @type: string\n          serviceAccount:\n\n          # Token Audience should match the audience of the vault kubernetes auth role.\n          # @type: array\u003cstring\u003e\n          tokenAudiences: []\n\n        # Vault JWT auth method specific configuration\n        jwt:\n          # Vault Auth Role to use\n          # This is a required field and must be setup in Vault prior to deploying the helm chart\n          # if using JWT for the Transit VaultAuthMethod.\n          # @type: string\n          role: \"\"\n\n          # One of the following is required prior to deploying the helm chart\n          # - K8s secret that contains the JWT\n          # - K8s service account if a service account JWT is used as a Vault JWT auth token and\n          # needs generating by VSO.\n\n          # Name of Kubernetes Secret that has the Vault JWT auth token.\n          # The Kubernetes Secret must contain a key named `jwt` which references the JWT token, and\n          # must exist in the namespace of any consuming VaultSecret CR. This is a required field if\n          # a JWT token is provided.\n          # @type: string\n          secretRef: \"\"\n\n          # Kubernetes ServiceAccount to generate a service account JWT\n          # @type: string\n          serviceAccount: \"default\"\n\n          # Token Audience should match the bound_audiences or the `aud` list in bound_claims if\n          # applicable of the Vault JWT auth role.\n          # @type: array\u003cstring\u003e\n          tokenAudiences: []\n\n        # AppRole auth method specific configuration\n        appRole:\n          # AppRole Role's RoleID to use for authenticating to Vault.\n          # This is a required field when using appRole and must be setup in Vault prior to deploying\n          # the helm chart.\n          # @type: string\n          roleId: \"\"\n          # Name of Kubernetes Secret that has the AppRole Role's SecretID used to authenticate with\n          # Vault. The Kubernetes Secret must contain a key named `id` which references the AppRole\n          # Role's SecretID, and must exist in the namespace of any consuming VaultSecret CR.\n          # This is a required field when using appRole and must be setup in Vault prior to\n          # deploying the helm chart.\n          # @type: string\n          secretRef: \"\"\n\n        # AWS auth method specific configuration\n        aws:\n          # Vault Auth Role to use\n          # This is a required field and must be setup in Vault prior to deploying the helm chart\n          # if using the AWS for the Transit auth method.\n          # @type: string\n          role: \"\"\n\n          # AWS region to use for signing the authentication request\n          # Optional, but most commonly will be the EKS cluster region.\n          # @type: string\n          region: \"\"\n\n          # Vault header value to include in the STS signing request\n          # @type: string\n          headerValue: \"\"\n\n          # The role session name to use when creating a WebIdentity provider\n          # @type: string\n          sessionName: \"\"\n\n          # The STS endpoint to use; if not set will use the default\n          # @type: string\n          stsEndpoint: \"\"\n\n          # The IAM endpoint to use; if not set will use the default\n          # @type: string\n          iamEndpoint: \"\"\n\n          # The name of a Kubernetes Secret which holds credentials for AWS. Supported keys\n          # include `access_key_id`, `secret_access_key`, `session_token`\n          # @type: string\n          secretRef: \"\"\n\n          # Name of a Kubernetes service account that is configured with IAM Roles\n          # for Service Accounts (IRSA). Should be annotated with \"eks.amazonaws.com/role-arn\".\n          # @type: string\n          irsaServiceAccount: \"\"\n\n        # Params to use when authenticating to Vault using this auth method.\n        # params:\n        #   param-something1: \"foo\"\n        # @type: map\n        params: {}\n\n        # Headers to be included in all Vault requests.\n        # headers:\n        #   X-vault-something1: \"foo\"\n        # @type:  map\n        headers: {}\n\n    # Defines the maximum number of concurrent reconciles by the controller.\n    # NOTE: Currently this is only used by the reconciliation logic of dynamic secrets.\n    #\n    # default: 100\n    # @type: integer\n    maxConcurrentReconciles:\n\n    # Defines additional environment variables to be added to the\n    # vault-secrets-opearator manager container.\n    # extraEnv:\n    #   - name: HTTP_PROXY\n    #     value: http://proxy.example.com\n    # @type: array\u003cmap\u003e\n    extraEnv: []\n\n    # Defines additional commandline arguments to be passed to the\n    # vault-secrets-operator manager container.\n    # extraArgs:\n    # - -zap-log-level=5\n    # @type: array\n    extraArgs: []\n\n    # Configures the default resources for the vault-secrets-operator container.\n    # For more information on configuring resources, see the K8s documentation:\n    # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n    # @recurse: true\n    # @type: map\n    resources:\n      limits:\n        cpu: 500m\n        memory: 128Mi\n      requests:\n        cpu: 10m\n        memory: 64Mi\n\n  # Configures the Pod Security Context\n  # https://kubernetes.io/docs/tasks/configure-pod-container/security-context\n  podSecurityContext:\n    runAsNonRoot: true\n\n  # Configures the Container Security Context\n  # https://kubernetes.io/docs/tasks/configure-pod-container/security-context\n  securityContext:\n    allowPrivilegeEscalation: false\n\n  # Sets the configuration settings used by the controller. Any custom changes will be reflected in the\n  # data field of the configmap.\n  # For more information on configuring resources, see the K8s documentation:\n  # https://kubernetes.io/docs/concepts/configuration/configmap/\n  # @recurse: true\n  # @type: map\n  controllerConfigMapYaml:\n    health:\n      healthProbeBindAddress: :8081\n    leaderElection:\n      leaderElect: true\n      resourceName: b0d477c0.hashicorp.com\n    metrics:\n      bindAddress: 127.0.0.1:8080\n    webhook:\n      port: 9443\n\n  # Configures the environment variable KUBERNETES_CLUSTER_DOMAIN used by KubeDNS.\n  # @type: string\n  kubernetesClusterDomain: cluster.local\n\n  # Duration in seconds the pod needs to terminate gracefully.\n  # See: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/\n  terminationGracePeriodSeconds: 120\n\n  # Timeout in seconds for the pre-delete hook\n  preDeleteHookTimeoutSeconds: 120\n\n# Configure the metrics service ports used by the metrics service.\n# Set the configuration fo the metricsService port.\n# @recurse: true\n# @type: map\nmetricsService:\n  # Set the port settings for the metrics service.\n  # For more information on configuring resources, see the K8s documentation:\n  # https://kubernetes.io/docs/concepts/services-networking/service/\n  # @type: map\n  ports:\n  - name: https\n    port: 8443\n    protocol: TCP\n    targetPort: https\n  type: ClusterIP\n\n# Configures the default VaultConnection CR which will be used by resources\n# if they do not specify a VaultConnection reference. The name is 'default' and will\n# always be installed in the same namespace as the operator.\n# NOTE:\n# * It is strongly recommended to deploy the vault secrets operator in a secure Vault environment\n#   which includes a configuration utilizing TLS and installing Vault into its own restricted namespace.\ndefaultVaultConnection:\n  # toggles the deployment of the VaultAuthMethod CR\n  # @type: boolean\n  enabled: false\n\n  # Address of the Vault Server\n  # @type: string\n  # Example: http://vault.default.svc.cluster.local:8200\n  address: \"\"\n\n  # CACertSecret is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.\n  # Note: This secret must exist prior to deploying the CR.\n  # @type: string\n  caCertSecret: \"\"\n\n  # TLSServerName to use as the SNI host for TLS connections.\n  # @type: string\n  tlsServerName: \"\"\n\n  # SkipTLSVerify for TLS connections.\n  # @type: boolean\n  skipTLSVerify: false\n\n  # Headers to be included in all Vault requests.\n  # headers:\n  #   X-vault-something: \"foo\"\n  # @type: map\n  headers: {}\n\n\n# Configures and deploys the default VaultAuthMethod CR which will be used by resources\n# if they do not specify a VaultAuthMethod reference. The name is 'default' and will\n# always be installed in the same namespace as the operator.\n# NOTE:\n# * It is strongly recommended to deploy the vault secrets operator in a secure Vault environment\n#   which includes a configuration utilizing TLS and installing Vault into its own restricted namespace.\ndefaultAuthMethod:\n  # toggles the deployment of the VaultAuthMethod CR\n  # @type: boolean\n  enabled: false\n\n  # Vault namespace for the VaultAuthMethod CR\n  # @type: string\n  namespace: \"\"\n\n  # Vault Auth method to be used with the VaultAuthMethod CR\n  # @type: string\n  method: kubernetes\n\n  # Mount path for the Vault Auth Method.\n  # @type: string\n  mount: kubernetes\n\n  # Vault Kubernetes auth method specific configuration\n  kubernetes:\n    # Vault Auth Role to use\n    # This is a required field and must be setup in Vault prior to deploying the helm chart\n    # if `defaultAuthMethod.enabled=true`\n    # @type: string\n    role: \"\"\n\n    # Kubernetes ServiceAccount associated with the default Vault Auth Role\n    # @type: string\n    serviceAccount: default\n\n    # Token Audience should match the audience of the vault kubernetes auth role.\n    # @type: array\u003cstring\u003e\n    tokenAudiences: []\n\n  # Vault JWT auth method specific configuration\n  jwt:\n    # Vault Auth Role to use\n    # This is a required field and must be setup in Vault prior to deploying the helm chart\n    # if using the JWT for the default auth method.\n    # @type: string\n    role: \"\"\n\n    # One of the following is required prior to deploying the helm chart\n    # - K8s secret that contains the JWT\n    # - K8s service account if a service account JWT is used as a Vault JWT auth token and needs generating by VSO\n\n    # Name of Kubernetes Secret that has the Vault JWT auth token.\n    # The Kubernetes Secret must contain a key named `jwt` which references the JWT token, and must exist in the namespace\n    # of any consuming VaultSecret CR. This is a required field if a JWT token is provided.\n    # @type: string\n    secretRef: \"\"\n\n    # Kubernetes ServiceAccount to generate a service account JWT\n    # @type: string\n    serviceAccount: \"default\"\n\n    # Token Audience should match the bound_audiences or the `aud` list in bound_claims if applicable\n    # of the Vault JWT auth role.\n    # @type: array\u003cstring\u003e\n    tokenAudiences: []\n\n  # AppRole auth method specific configuration\n  appRole:\n    # AppRole Role's RoleID to use for authenticating to Vault.\n    # This is a required field when using appRole and must be setup in Vault prior to deploying the\n    # helm chart.\n    # @type: string\n    roleId: \"\"\n    # Name of Kubernetes Secret that has the AppRole Role's SecretID used to authenticate with Vault.\n    # The Kubernetes Secret must contain a key named `id` which references the AppRole Role's\n    # SecretID, and must exist in the namespace of any consuming VaultSecret CR.\n    # This is a required field when using appRole and must be setup in Vault prior to deploying the\n    # helm chart.\n    # @type: string\n    secretRef: \"\"\n\n  # AWS auth method specific configuration\n  aws:\n    # Vault Auth Role to use\n    # This is a required field and must be setup in Vault prior to deploying the helm chart\n    # if using the AWS for the default auth method.\n    # @type: string\n    role: \"\"\n\n    # AWS region to use for signing the authentication request\n    # Optional, but most commonly will be the region where the EKS cluster is running\n    # @type: string\n    region: \"\"\n\n    # Vault header value to include in the STS signing request\n    # @type: string\n    headerValue: \"\"\n\n    # The role session name to use when creating a WebIdentity provider\n    # @type: string\n    sessionName: \"\"\n\n    # The STS endpoint to use; if not set will use the default\n    # @type: string\n    stsEndpoint: \"\"\n\n    # The IAM endpoint to use; if not set will use the default\n    # @type: string\n    iamEndpoint: \"\"\n\n    # The name of a Kubernetes Secret which holds credentials for AWS. Supported keys include\n    # `access_key_id`, `secret_access_key`, `session_token`\n    # @type: string\n    secretRef: \"\"\n\n    # Name of a Kubernetes service account that is configured with IAM Roles\n    # for Service Accounts (IRSA). Should be annotated with \"eks.amazonaws.com/role-arn\".\n    # @type: string\n    irsaServiceAccount: \"\"\n\n  # Params to use when authenticating to Vault\n  # params:\n  #   param-something1: \"foo\"\n  # @type: map\n  params: {}\n\n  # Headers to be included in all Vault requests.\n  # headers:\n  #   X-vault-something1: \"foo\"\n  # @type: map\n  headers: {}\n\n# Configures a Prometheus ServiceMonitor\ntelemetry:\n  serviceMonitor:\n    # The Prometheus operator *must* be installed before enabling this feature,\n    # if not the chart will fail to install due to missing CustomResourceDefinitions\n    # provided by the operator.\n    #\n    # Instructions on how to install the Helm chart can be found here:\n    #  https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack\n    # More information can be found here:\n    #  https://github.com/prometheus-operator/prometheus-operator\n    #  https://github.com/prometheus-operator/kube-prometheus\n\n    # Enable deployment of the Vault Secrets Operator ServiceMonitor CustomResource.\n    # @type: boolean\n    enabled: false\n\n    # Selector labels to add to the ServiceMonitor.\n    # When empty, defaults to:\n    #  release: prometheus\n    # @type: string\n    selectors: {}\n\n    # Scheme of the service Prometheus scrapes metrics from. This must match the scheme of the metrics service of VSO\n    # @type: string\n    scheme: https\n\n    # Port at which Prometheus scrapes metrics. This must match the port of the metrics service of VSO\n    # @type: string\n    port: https\n\n    # Path at which Prometheus scrapes metrics\n    # @type: string\n    path: /metrics\n\n    # File Prometheus reads bearer token from for scraping metrics\n    # @type: string\n    bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token\n\n    # Interval at which Prometheus scrapes metrics\n    # @type: string\n    interval: 30s\n\n    # Timeout for Prometheus scrapes\n    # @type: string\n    scrapeTimeout: 10s\n\n## Used by unit tests, and will not be rendered except when using `helm template`, this can be safely ignored.\ntests:\n  # @type: boolean\n  enabled: true"
            ],
            "verify": false,
            "version": "0.3.4",
            "wait": true,
            "wait_for_jobs": false
          },
          "sensitive_attributes": [],
          "private": "eyJzY2hlbWFfdmVyc2lvbiI6IjEifQ=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_cluster_role",
      "name": "vault_authorizer",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "aggregation_rule": [],
            "id": "vault-authorizer",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "vault-authorizer",
                "resource_version": "1913",
                "uid": "be3bae81-0888-45c0-a229-d7a54ce3cacd"
              }
            ],
            "rule": [
              {
                "api_groups": [
                  ""
                ],
                "non_resource_urls": [],
                "resource_names": [],
                "resources": [
                  "namespaces"
                ],
                "verbs": [
                  "get"
                ]
              },
              {
                "api_groups": [
                  ""
                ],
                "non_resource_urls": [],
                "resource_names": [],
                "resources": [
                  "serviceaccounts",
                  "serviceaccounts/token"
                ],
                "verbs": [
                  "create",
                  "update",
                  "delete"
                ]
              },
              {
                "api_groups": [
                  "rbac.authorization.k8s.io"
                ],
                "non_resource_urls": [],
                "resource_names": [],
                "resources": [
                  "rolebindings",
                  "clusterrolebindings"
                ],
                "verbs": [
                  "create",
                  "update",
                  "delete"
                ]
              },
              {
                "api_groups": [
                  "rbac.authorization.k8s.io"
                ],
                "non_resource_urls": [],
                "resource_names": [],
                "resources": [
                  "roles",
                  "clusterroles"
                ],
                "verbs": [
                  "bind",
                  "escalate",
                  "create",
                  "update",
                  "delete"
                ]
              }
            ]
          },
          "sensitive_attributes": [],
          "private": "bnVsbA==",
          "dependencies": [
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_cluster_role_binding",
      "name": "vault-token-creator-binding",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "vault-token-creator-binding",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "vault-token-creator-binding",
                "resource_version": "1922",
                "uid": "9e3bd2bd-98dd-449d-86dc-e327330c6b6b"
              }
            ],
            "role_ref": [
              {
                "api_group": "rbac.authorization.k8s.io",
                "kind": "ClusterRole",
                "name": "vault-authorizer"
              }
            ],
            "subject": [
              {
                "api_group": "",
                "kind": "ServiceAccount",
                "name": "vault",
                "namespace": "vault"
              }
            ]
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_config_map",
      "name": "vault_agent_config",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "binary_data": {},
            "data": {
              "config-init.hcl": "exit_after_auth = true\npid_file        = \"/home/vault/.pid\"\n\nauto_auth = {\n  method = {\n    config = {\n      role = \"internal-app\"\n    }\n    type = \"kubernetes\"\n  }\n  sink = {\n    config = {\n      path = \"/vault/secrets/.token\"\n    }\n    type = \"file\"\n  }\n}\n\ntemplate = {\n  contents         = \u003c\u003cEOF\n        {{- with secret \"aws/creds/vault-ecr\" -}}\n        [default]\n        aws_access_key_id = {{ .Data.access_key }}\n        aws_secret_access_key = {{ .Data.secret_key }}\n        aws_session_token = {{ .Data.security_token }}\n        region = ca-central-1\n        output = json\n        {{- end }}\n        EOF\n  destination      = \"/vault/secrets/aws/credentials\"\n  create_dest_dirs = true\n}\n\nvault = {\n  address = \"https://vault.vault.svc.cluster.local:8200\"\n}\n",
              "config.hcl": "exit_after_auth = false\npid_file        = \"/home/vault/.pid\"\n\nauto_auth = {\n  method = {\n    config = {\n      role = \"internal-app\"\n    }\n    type = \"kubernetes\"\n  }\n  sink = {\n    config = {\n      path = \"/vault/secrets/.token\"\n    }\n    type = \"file\"\n  }\n}\n\ntemplate = {\n  contents         = \u003c\u003cEOF\n        {{- with secret \"aws/creds/vault-ecr\" -}}\n        [default]\n        aws_access_key_id = {{ .Data.access_key }}\n        aws_secret_access_key = {{ .Data.secret_key }}\n        aws_session_token = {{ .Data.security_token }}\n        region = ca-central-1\n        output = json\n        {{- end }}\n        EOF\n  destination      = \"/vault/secrets/aws/credentials\"\n  create_dest_dirs = true\n}\n\nvault = {\n  address = \"https://vault.vault.svc.cluster.local:8200\"\n}\n"
            },
            "id": "vault/vault-ecr-role",
            "immutable": false,
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "vault-ecr-role",
                "namespace": "vault",
                "resource_version": "1919",
                "uid": "570be6eb-99d4-4c3d-a7fb-062ea03816aa"
              }
            ]
          },
          "sensitive_attributes": [],
          "private": "bnVsbA=="
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_cron_job_v1",
      "name": "vault_ecr_token",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "vault/vault-ecr-refresh",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 1,
                "labels": {},
                "name": "vault-ecr-refresh",
                "namespace": "vault",
                "resource_version": "8956",
                "uid": "97a8dab7-48f6-4edd-811a-6de29d8d7d31"
              }
            ],
            "spec": [
              {
                "concurrency_policy": "Allow",
                "failed_jobs_history_limit": 5,
                "job_template": [
                  {
                    "metadata": [
                      {
                        "annotations": {},
                        "generate_name": "",
                        "generation": 0,
                        "labels": {
                          "app": "vault-ecr-refresh"
                        },
                        "name": "",
                        "resource_version": "",
                        "uid": ""
                      }
                    ],
                    "spec": [
                      {
                        "active_deadline_seconds": 0,
                        "backoff_limit": 6,
                        "completion_mode": "",
                        "completions": 1,
                        "manual_selector": false,
                        "parallelism": 1,
                        "selector": [],
                        "template": [
                          {
                            "metadata": [
                              {
                                "annotations": {
                                  "vault.hashicorp.com/agent-cache-enable": "true",
                                  "vault.hashicorp.com/agent-configmap": "vault-ecr-role",
                                  "vault.hashicorp.com/agent-inject": "true",
                                  "vault.hashicorp.com/agent-pre-populate-only": "true"
                                },
                                "generate_name": "",
                                "generation": 0,
                                "labels": {
                                  "app": "vault-ecr-refresh"
                                },
                                "name": "",
                                "resource_version": "",
                                "uid": ""
                              }
                            ],
                            "spec": [
                              {
                                "active_deadline_seconds": 0,
                                "affinity": [],
                                "automount_service_account_token": true,
                                "container": [
                                  {
                                    "args": [],
                                    "command": [
                                      "bash",
                                      "-c",
                                      "#!/bin/bash\n\nyum install -y jq\n\n# Getting the ecr auth token\necrAuth=$(echo \"AWS:$(aws ecr get-login-password --region ca-central-1)\" | base64 -w0)\n\n# Parsing into a format for the dockerconfigjson\ndockerAuth=$(jq -nc --arg ecrAuth \"$ecrAuth\" --arg repo \"$ECR_REPO\" '{\"auths\":{($repo):{\"auth\":$ecrAuth}}}')\n\n# get the mounted service account token\ntoken=\"$(cat /vault/secrets/.token)\" #TODO: FIX GET VALID TOKEN\n\n# update the secret using curl\ncurl \\\n    --header \"X-Vault-Token: $token\" \\\n    --header \"Content-Type: application/merge-patch+json\" \\\n    --request PATCH \\\n    --data '{\"data\":{\".dockerconfigjson\":'\"$dockerAuth\"'}}' \\\n    \"$VAULT_ADDR/v1/secret/data/ecr-auth\"\n"
                                    ],
                                    "env": [
                                      {
                                        "name": "AWS_SHARED_CREDENTIALS_FILE",
                                        "value": "/vault/secrets/aws/credentials",
                                        "value_from": []
                                      },
                                      {
                                        "name": "VAULT_ADDR",
                                        "value": "http://vault.vault.svc.cluster.local:8200",
                                        "value_from": []
                                      },
                                      {
                                        "name": "ECR_REPO",
                                        "value": "405934267152.dkr.ecr.ca-central-1.amazonaws.com",
                                        "value_from": []
                                      }
                                    ],
                                    "env_from": [],
                                    "image": "amazon/aws-cli",
                                    "image_pull_policy": "Always",
                                    "lifecycle": [],
                                    "liveness_probe": [],
                                    "name": "ecr-refresher",
                                    "port": [],
                                    "readiness_probe": [],
                                    "resources": [
                                      {
                                        "limits": {},
                                        "requests": {}
                                      }
                                    ],
                                    "security_context": [],
                                    "startup_probe": [],
                                    "stdin": false,
                                    "stdin_once": false,
                                    "termination_message_path": "/dev/termination-log",
                                    "termination_message_policy": "File",
                                    "tty": false,
                                    "volume_mount": [],
                                    "working_dir": ""
                                  }
                                ],
                                "dns_config": [],
                                "dns_policy": "ClusterFirst",
                                "enable_service_links": true,
                                "host_aliases": [],
                                "host_ipc": false,
                                "host_network": false,
                                "host_pid": false,
                                "hostname": "",
                                "image_pull_secrets": [],
                                "init_container": [],
                                "node_name": "",
                                "node_selector": {},
                                "priority_class_name": "",
                                "readiness_gate": [],
                                "restart_policy": "Never",
                                "runtime_class_name": "",
                                "scheduler_name": "default-scheduler",
                                "security_context": [],
                                "service_account_name": "internal-app",
                                "share_process_namespace": false,
                                "subdomain": "",
                                "termination_grace_period_seconds": 30,
                                "toleration": [],
                                "topology_spread_constraint": [],
                                "volume": []
                              }
                            ]
                          }
                        ],
                        "ttl_seconds_after_finished": ""
                      }
                    ]
                  }
                ],
                "schedule": "0 * * * *",
                "starting_deadline_seconds": 0,
                "successful_jobs_history_limit": 1,
                "suspend": false,
                "timezone": ""
              }
            ],
            "timeouts": null
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjo2MDAwMDAwMDAwMH19"
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_job_v1",
      "name": "vault_init",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "id": "vault/vault-init",
            "metadata": [
              {
                "annotations": null,
                "generate_name": "",
                "generation": 0,
                "labels": {
                  "app": "vault-init"
                },
                "name": "vault-init",
                "namespace": "vault",
                "resource_version": "",
                "uid": ""
              }
            ],
            "spec": [
              {
                "active_deadline_seconds": 0,
                "backoff_limit": 2,
                "completion_mode": "",
                "completions": 1,
                "manual_selector": false,
                "parallelism": 1,
                "selector": [],
                "template": [
                  {
                    "metadata": [
                      {
                        "annotations": null,
                        "generate_name": "",
                        "generation": 0,
                        "labels": {
                          "app": "vault-init"
                        },
                        "name": "",
                        "resource_version": "",
                        "uid": ""
                      }
                    ],
                    "spec": [
                      {
                        "active_deadline_seconds": 0,
                        "affinity": [],
                        "automount_service_account_token": true,
                        "container": [
                          {
                            "args": null,
                            "command": [
                              "sh",
                              "-c",
                              "#!/bin/bash\n\napk add curl jq\n\n# nc -zvw10 $1 $2 \u0026\u0026 exit 1 || echo \"continue.\"\n\nINIT_RESPONSE=$(vault operator init -key-shares=1 -key-threshold=1 -format=json)\n\nif [[ -z \"$INIT_RESPONSE\" ]]; then\n    exit 0\nfi\n\nUNSEAL_KEY=$(echo \"$INIT_RESPONSE\" | jq -r .unseal_keys_b64[0])\nROOT_TOKEN=$(echo \"$INIT_RESPONSE\" | jq -r .root_token)\n\nHCP_API_TOKEN=$(curl --location 'https://auth.hashicorp.com/oauth/token' \\\n    --header 'content-type: application/json' \\\n    --data '{\n         \"audience\": \"https://api.hashicorp.cloud\",\n         \"grant_type\": \"client_credentials\",\n         \"client_id\": \"'$HCP_CLIENT_ID'\",\n         \"client_secret\": \"'$HCP_CLIENT_SECRET'\"\n     }' | jq -r .access_token)\n\ncurl -XPOST https://api.cloud.hashicorp.com/secrets/2023-06-13/organizations/$HCP_ORG_ID/projects/$HCP_PROJECT_ID/apps/$HCP_APP_NAME/kv \\\n    --data '{\"name\":\"root\",\"value\":\"'\"$ROOT_TOKEN\"'\"}' \\\n    --header \"Authorization: Bearer $HCP_API_TOKEN\"\n\ncurl -XPOST https://api.cloud.hashicorp.com/secrets/2023-06-13/organizations/$HCP_ORG_ID/projects/$HCP_PROJECT_ID/apps/$HCP_APP_NAME/kv \\\n    --data '{\"name\":\"unseal_key\",\"value\":\"'\"$UNSEAL_KEY\"'\"}' \\\n    --header \"Authorization: Bearer $HCP_API_TOKEN\"\n\nvault operator unseal $UNSEAL_KEY\n"
                            ],
                            "env": [
                              {
                                "name": "VAULT_ADDR",
                                "value": "http://vault.vault.svc.cluster.local:8200",
                                "value_from": []
                              },
                              {
                                "name": "HCP_APP_NAME",
                                "value": "proxmox",
                                "value_from": []
                              },
                              {
                                "name": "HCP_ORG_ID",
                                "value": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
                                "value_from": []
                              },
                              {
                                "name": "HCP_PROJECT_ID",
                                "value": "903fb074-79fb-4a64-9a67-70d2717666bf",
                                "value_from": []
                              },
                              {
                                "name": "HCP_CLIENT_ID",
                                "value": "",
                                "value_from": [
                                  {
                                    "config_map_key_ref": [],
                                    "field_ref": [],
                                    "resource_field_ref": [],
                                    "secret_key_ref": [
                                      {
                                        "key": "clientID",
                                        "name": "default",
                                        "optional": false
                                      }
                                    ]
                                  }
                                ]
                              },
                              {
                                "name": "HCP_CLIENT_SECRET",
                                "value": "",
                                "value_from": [
                                  {
                                    "config_map_key_ref": [],
                                    "field_ref": [],
                                    "resource_field_ref": [],
                                    "secret_key_ref": [
                                      {
                                        "key": "clientSecret",
                                        "name": "default",
                                        "optional": false
                                      }
                                    ]
                                  }
                                ]
                              }
                            ],
                            "env_from": [],
                            "image": "hashicorp/vault:1.15.1",
                            "image_pull_policy": "",
                            "lifecycle": [],
                            "liveness_probe": [],
                            "name": "vault-init",
                            "port": [],
                            "readiness_probe": [],
                            "resources": [],
                            "security_context": [],
                            "startup_probe": [],
                            "stdin": false,
                            "stdin_once": false,
                            "termination_message_path": "/dev/termination-log",
                            "termination_message_policy": "",
                            "tty": false,
                            "volume_mount": [],
                            "working_dir": ""
                          }
                        ],
                        "dns_config": [],
                        "dns_policy": "ClusterFirst",
                        "enable_service_links": true,
                        "host_aliases": [],
                        "host_ipc": false,
                        "host_network": false,
                        "host_pid": false,
                        "hostname": "",
                        "image_pull_secrets": [],
                        "init_container": [],
                        "node_name": "",
                        "node_selector": null,
                        "priority_class_name": "",
                        "readiness_gate": [],
                        "restart_policy": "Never",
                        "runtime_class_name": "",
                        "scheduler_name": "",
                        "security_context": [],
                        "service_account_name": "",
                        "share_process_namespace": false,
                        "subdomain": "",
                        "termination_grace_period_seconds": 30,
                        "toleration": [],
                        "topology_spread_constraint": [],
                        "volume": []
                      }
                    ]
                  }
                ],
                "ttl_seconds_after_finished": ""
              }
            ],
            "timeouts": null,
            "wait_for_completion": true
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMCwiZGVsZXRlIjo2MDAwMDAwMDAwMCwidXBkYXRlIjo2MDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9"
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_manifest",
      "name": "external_secret",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "computed_fields": null,
            "field_manager": [],
            "manifest": {
              "value": {
                "apiVersion": "external-secrets.io/v1beta1",
                "kind": "ExternalSecret",
                "metadata": {
                  "name": "vault-ecr",
                  "namespace": "vault"
                },
                "spec": {
                  "data": [
                    {
                      "remoteRef": {
                        "key": "vault-ecr",
                        "property": ".dockerconfigjson"
                      },
                      "secretKey": ".dockerconfigjson"
                    }
                  ],
                  "secretStoreRef": {
                    "kind": "SecretStore",
                    "name": "vault-backend"
                  },
                  "target": {
                    "name": "regcred",
                    "template": {
                      "engineVersion": "v2",
                      "mergePolicy": "Replace",
                      "type": "kubernetes.io/dockerconfigjson"
                    }
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "name": "string",
                      "namespace": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "data": [
                        "tuple",
                        [
                          [
                            "object",
                            {
                              "remoteRef": [
                                "object",
                                {
                                  "key": "string",
                                  "property": "string"
                                }
                              ],
                              "secretKey": "string"
                            }
                          ]
                        ]
                      ],
                      "secretStoreRef": [
                        "object",
                        {
                          "kind": "string",
                          "name": "string"
                        }
                      ],
                      "target": [
                        "object",
                        {
                          "name": "string",
                          "template": [
                            "object",
                            {
                              "engineVersion": "string",
                              "mergePolicy": "string",
                              "type": "string"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "object": {
              "value": {
                "apiVersion": "external-secrets.io/v1beta1",
                "kind": "ExternalSecret",
                "metadata": {
                  "annotations": null,
                  "creationTimestamp": null,
                  "deletionGracePeriodSeconds": null,
                  "deletionTimestamp": null,
                  "finalizers": null,
                  "generateName": null,
                  "generation": null,
                  "labels": null,
                  "managedFields": null,
                  "name": "vault-ecr",
                  "namespace": "vault",
                  "ownerReferences": null,
                  "resourceVersion": null,
                  "selfLink": null,
                  "uid": null
                },
                "spec": {
                  "data": [
                    {
                      "remoteRef": {
                        "conversionStrategy": "Default",
                        "decodingStrategy": "None",
                        "key": "vault-ecr",
                        "metadataPolicy": null,
                        "property": ".dockerconfigjson",
                        "version": null
                      },
                      "secretKey": ".dockerconfigjson",
                      "sourceRef": {
                        "generatorRef": {
                          "apiVersion": null,
                          "kind": null,
                          "name": null
                        },
                        "storeRef": {
                          "kind": null,
                          "name": null
                        }
                      }
                    }
                  ],
                  "dataFrom": null,
                  "refreshInterval": "1h",
                  "secretStoreRef": {
                    "kind": "SecretStore",
                    "name": "vault-backend"
                  },
                  "target": {
                    "creationPolicy": "Owner",
                    "deletionPolicy": "Retain",
                    "immutable": null,
                    "name": "regcred",
                    "template": {
                      "data": null,
                      "engineVersion": "v2",
                      "mergePolicy": "Replace",
                      "metadata": {
                        "annotations": null,
                        "labels": null
                      },
                      "templateFrom": null,
                      "type": "kubernetes.io/dockerconfigjson"
                    }
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "annotations": [
                        "map",
                        "string"
                      ],
                      "creationTimestamp": "string",
                      "deletionGracePeriodSeconds": "number",
                      "deletionTimestamp": "string",
                      "finalizers": [
                        "list",
                        "string"
                      ],
                      "generateName": "string",
                      "generation": "number",
                      "labels": [
                        "map",
                        "string"
                      ],
                      "managedFields": [
                        "tuple",
                        [
                          [
                            "object",
                            {
                              "apiVersion": "string",
                              "fieldsType": "string",
                              "fieldsV1": "dynamic",
                              "manager": "string",
                              "operation": "string",
                              "subresource": "string",
                              "time": "string"
                            }
                          ]
                        ]
                      ],
                      "name": "string",
                      "namespace": "string",
                      "ownerReferences": [
                        "list",
                        [
                          "object",
                          {
                            "apiVersion": "string",
                            "blockOwnerDeletion": "bool",
                            "controller": "bool",
                            "kind": "string",
                            "name": "string",
                            "uid": "string"
                          }
                        ]
                      ],
                      "resourceVersion": "string",
                      "selfLink": "string",
                      "uid": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "data": [
                        "list",
                        [
                          "object",
                          {
                            "remoteRef": [
                              "object",
                              {
                                "conversionStrategy": "string",
                                "decodingStrategy": "string",
                                "key": "string",
                                "metadataPolicy": "string",
                                "property": "string",
                                "version": "string"
                              }
                            ],
                            "secretKey": "string",
                            "sourceRef": [
                              "object",
                              {
                                "generatorRef": [
                                  "object",
                                  {
                                    "apiVersion": "string",
                                    "kind": "string",
                                    "name": "string"
                                  }
                                ],
                                "storeRef": [
                                  "object",
                                  {
                                    "kind": "string",
                                    "name": "string"
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      ],
                      "dataFrom": [
                        "list",
                        [
                          "object",
                          {
                            "extract": [
                              "object",
                              {
                                "conversionStrategy": "string",
                                "decodingStrategy": "string",
                                "key": "string",
                                "metadataPolicy": "string",
                                "property": "string",
                                "version": "string"
                              }
                            ],
                            "find": [
                              "object",
                              {
                                "conversionStrategy": "string",
                                "decodingStrategy": "string",
                                "name": [
                                  "object",
                                  {
                                    "regexp": "string"
                                  }
                                ],
                                "path": "string",
                                "tags": [
                                  "map",
                                  "string"
                                ]
                              }
                            ],
                            "rewrite": [
                              "list",
                              [
                                "object",
                                {
                                  "regexp": [
                                    "object",
                                    {
                                      "source": "string",
                                      "target": "string"
                                    }
                                  ]
                                }
                              ]
                            ],
                            "sourceRef": [
                              "object",
                              {
                                "generatorRef": [
                                  "object",
                                  {
                                    "apiVersion": "string",
                                    "kind": "string",
                                    "name": "string"
                                  }
                                ],
                                "storeRef": [
                                  "object",
                                  {
                                    "kind": "string",
                                    "name": "string"
                                  }
                                ]
                              }
                            ]
                          }
                        ]
                      ],
                      "refreshInterval": "string",
                      "secretStoreRef": [
                        "object",
                        {
                          "kind": "string",
                          "name": "string"
                        }
                      ],
                      "target": [
                        "object",
                        {
                          "creationPolicy": "string",
                          "deletionPolicy": "string",
                          "immutable": "bool",
                          "name": "string",
                          "template": [
                            "object",
                            {
                              "data": [
                                "map",
                                "string"
                              ],
                              "engineVersion": "string",
                              "mergePolicy": "string",
                              "metadata": [
                                "object",
                                {
                                  "annotations": [
                                    "map",
                                    "string"
                                  ],
                                  "labels": [
                                    "map",
                                    "string"
                                  ]
                                }
                              ],
                              "templateFrom": [
                                "list",
                                [
                                  "object",
                                  {
                                    "configMap": [
                                      "object",
                                      {
                                        "items": [
                                          "list",
                                          [
                                            "object",
                                            {
                                              "key": "string",
                                              "templateAs": "string"
                                            }
                                          ]
                                        ],
                                        "name": "string"
                                      }
                                    ],
                                    "literal": "string",
                                    "secret": [
                                      "object",
                                      {
                                        "items": [
                                          "list",
                                          [
                                            "object",
                                            {
                                              "key": "string",
                                              "templateAs": "string"
                                            }
                                          ]
                                        ],
                                        "name": "string"
                                      }
                                    ],
                                    "target": "string"
                                  }
                                ]
                              ],
                              "type": "string"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "timeouts": [],
            "wait": [],
            "wait_for": null
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_manifest",
      "name": "hcp_vault_auth",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "computed_fields": null,
            "field_manager": [],
            "manifest": {
              "value": {
                "apiVersion": "secrets.hashicorp.com/v1beta1",
                "kind": "HCPAuth",
                "metadata": {
                  "name": "default",
                  "namespace": "vault"
                },
                "spec": {
                  "allowedNamespaces": [
                    "*"
                  ],
                  "organizationID": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
                  "projectID": "903fb074-79fb-4a64-9a67-70d2717666bf",
                  "servicePrincipal": {
                    "secretRef": "default"
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "name": "string",
                      "namespace": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "allowedNamespaces": [
                        "tuple",
                        [
                          "string"
                        ]
                      ],
                      "organizationID": "string",
                      "projectID": "string",
                      "servicePrincipal": [
                        "object",
                        {
                          "secretRef": "string"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "object": {
              "value": {
                "apiVersion": "secrets.hashicorp.com/v1beta1",
                "kind": "HCPAuth",
                "metadata": {
                  "annotations": null,
                  "creationTimestamp": null,
                  "deletionGracePeriodSeconds": null,
                  "deletionTimestamp": null,
                  "finalizers": null,
                  "generateName": null,
                  "generation": null,
                  "labels": null,
                  "managedFields": null,
                  "name": "default",
                  "namespace": "vault",
                  "ownerReferences": null,
                  "resourceVersion": null,
                  "selfLink": null,
                  "uid": null
                },
                "spec": {
                  "allowedNamespaces": [
                    "*"
                  ],
                  "method": "servicePrincipal",
                  "organizationID": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
                  "projectID": "903fb074-79fb-4a64-9a67-70d2717666bf",
                  "servicePrincipal": {
                    "secretRef": "default"
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "annotations": [
                        "map",
                        "string"
                      ],
                      "creationTimestamp": "string",
                      "deletionGracePeriodSeconds": "number",
                      "deletionTimestamp": "string",
                      "finalizers": [
                        "list",
                        "string"
                      ],
                      "generateName": "string",
                      "generation": "number",
                      "labels": [
                        "map",
                        "string"
                      ],
                      "managedFields": [
                        "tuple",
                        [
                          [
                            "object",
                            {
                              "apiVersion": "string",
                              "fieldsType": "string",
                              "fieldsV1": "dynamic",
                              "manager": "string",
                              "operation": "string",
                              "subresource": "string",
                              "time": "string"
                            }
                          ]
                        ]
                      ],
                      "name": "string",
                      "namespace": "string",
                      "ownerReferences": [
                        "list",
                        [
                          "object",
                          {
                            "apiVersion": "string",
                            "blockOwnerDeletion": "bool",
                            "controller": "bool",
                            "kind": "string",
                            "name": "string",
                            "uid": "string"
                          }
                        ]
                      ],
                      "resourceVersion": "string",
                      "selfLink": "string",
                      "uid": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "allowedNamespaces": [
                        "list",
                        "string"
                      ],
                      "method": "string",
                      "organizationID": "string",
                      "projectID": "string",
                      "servicePrincipal": [
                        "object",
                        {
                          "secretRef": "string"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "timeouts": [],
            "wait": [],
            "wait_for": null
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_manifest",
      "name": "hcp_vault_tailscale_auth",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "computed_fields": null,
            "field_manager": [],
            "manifest": {
              "value": {
                "apiVersion": "secrets.hashicorp.com/v1beta1",
                "kind": "HCPAuth",
                "metadata": {
                  "name": "default",
                  "namespace": "tailscale"
                },
                "spec": {
                  "allowedNamespaces": [
                    "*"
                  ],
                  "organizationID": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
                  "projectID": "903fb074-79fb-4a64-9a67-70d2717666bf",
                  "servicePrincipal": {
                    "secretRef": "vault-tailscale-auth"
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "name": "string",
                      "namespace": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "allowedNamespaces": [
                        "tuple",
                        [
                          "string"
                        ]
                      ],
                      "organizationID": "string",
                      "projectID": "string",
                      "servicePrincipal": [
                        "object",
                        {
                          "secretRef": "string"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "object": {
              "value": {
                "apiVersion": "secrets.hashicorp.com/v1beta1",
                "kind": "HCPAuth",
                "metadata": {
                  "annotations": null,
                  "creationTimestamp": null,
                  "deletionGracePeriodSeconds": null,
                  "deletionTimestamp": null,
                  "finalizers": null,
                  "generateName": null,
                  "generation": null,
                  "labels": null,
                  "managedFields": null,
                  "name": "default",
                  "namespace": "tailscale",
                  "ownerReferences": null,
                  "resourceVersion": null,
                  "selfLink": null,
                  "uid": null
                },
                "spec": {
                  "allowedNamespaces": [
                    "*"
                  ],
                  "method": "servicePrincipal",
                  "organizationID": "dcbec3aa-c1af-41d7-b0c6-ece7078c6678",
                  "projectID": "903fb074-79fb-4a64-9a67-70d2717666bf",
                  "servicePrincipal": {
                    "secretRef": "vault-tailscale-auth"
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "annotations": [
                        "map",
                        "string"
                      ],
                      "creationTimestamp": "string",
                      "deletionGracePeriodSeconds": "number",
                      "deletionTimestamp": "string",
                      "finalizers": [
                        "list",
                        "string"
                      ],
                      "generateName": "string",
                      "generation": "number",
                      "labels": [
                        "map",
                        "string"
                      ],
                      "managedFields": [
                        "tuple",
                        [
                          [
                            "object",
                            {
                              "apiVersion": "string",
                              "fieldsType": "string",
                              "fieldsV1": "dynamic",
                              "manager": "string",
                              "operation": "string",
                              "subresource": "string",
                              "time": "string"
                            }
                          ]
                        ]
                      ],
                      "name": "string",
                      "namespace": "string",
                      "ownerReferences": [
                        "list",
                        [
                          "object",
                          {
                            "apiVersion": "string",
                            "blockOwnerDeletion": "bool",
                            "controller": "bool",
                            "kind": "string",
                            "name": "string",
                            "uid": "string"
                          }
                        ]
                      ],
                      "resourceVersion": "string",
                      "selfLink": "string",
                      "uid": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "allowedNamespaces": [
                        "list",
                        "string"
                      ],
                      "method": "string",
                      "organizationID": "string",
                      "projectID": "string",
                      "servicePrincipal": [
                        "object",
                        {
                          "secretRef": "string"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "timeouts": [],
            "wait": [],
            "wait_for": null
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_manifest",
      "name": "tailscale_keys",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "computed_fields": null,
            "field_manager": [],
            "manifest": {
              "value": {
                "apiVersion": "secrets.hashicorp.com/v1beta1",
                "kind": "HCPVaultSecretsApp",
                "metadata": {
                  "name": "tailscale-keys",
                  "namespace": "tailscale"
                },
                "spec": {
                  "appName": "tailscale",
                  "destination": {
                    "create": true,
                    "labels": {
                      "hvs": "true"
                    },
                    "name": "operator-oauth"
                  },
                  "hcpAuthRef": "default",
                  "refreshAfter": "1h"
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "name": "string",
                      "namespace": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "appName": "string",
                      "destination": [
                        "object",
                        {
                          "create": "bool",
                          "labels": [
                            "object",
                            {
                              "hvs": "string"
                            }
                          ],
                          "name": "string"
                        }
                      ],
                      "hcpAuthRef": "string",
                      "refreshAfter": "string"
                    }
                  ]
                }
              ]
            },
            "object": {
              "value": {
                "apiVersion": "secrets.hashicorp.com/v1beta1",
                "kind": "HCPVaultSecretsApp",
                "metadata": {
                  "annotations": null,
                  "creationTimestamp": null,
                  "deletionGracePeriodSeconds": null,
                  "deletionTimestamp": null,
                  "finalizers": null,
                  "generateName": null,
                  "generation": null,
                  "labels": null,
                  "managedFields": null,
                  "name": "tailscale-keys",
                  "namespace": "tailscale",
                  "ownerReferences": null,
                  "resourceVersion": null,
                  "selfLink": null,
                  "uid": null
                },
                "spec": {
                  "appName": "tailscale",
                  "destination": {
                    "annotations": null,
                    "create": true,
                    "labels": {
                      "hvs": "true"
                    },
                    "name": "operator-oauth",
                    "type": null
                  },
                  "hcpAuthRef": "default",
                  "refreshAfter": "1h",
                  "rolloutRestartTargets": null
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "annotations": [
                        "map",
                        "string"
                      ],
                      "creationTimestamp": "string",
                      "deletionGracePeriodSeconds": "number",
                      "deletionTimestamp": "string",
                      "finalizers": [
                        "list",
                        "string"
                      ],
                      "generateName": "string",
                      "generation": "number",
                      "labels": [
                        "map",
                        "string"
                      ],
                      "managedFields": [
                        "tuple",
                        [
                          [
                            "object",
                            {
                              "apiVersion": "string",
                              "fieldsType": "string",
                              "fieldsV1": "dynamic",
                              "manager": "string",
                              "operation": "string",
                              "subresource": "string",
                              "time": "string"
                            }
                          ]
                        ]
                      ],
                      "name": "string",
                      "namespace": "string",
                      "ownerReferences": [
                        "list",
                        [
                          "object",
                          {
                            "apiVersion": "string",
                            "blockOwnerDeletion": "bool",
                            "controller": "bool",
                            "kind": "string",
                            "name": "string",
                            "uid": "string"
                          }
                        ]
                      ],
                      "resourceVersion": "string",
                      "selfLink": "string",
                      "uid": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "appName": "string",
                      "destination": [
                        "object",
                        {
                          "annotations": [
                            "map",
                            "string"
                          ],
                          "create": "bool",
                          "labels": [
                            "map",
                            "string"
                          ],
                          "name": "string",
                          "type": "string"
                        }
                      ],
                      "hcpAuthRef": "string",
                      "refreshAfter": "string",
                      "rolloutRestartTargets": [
                        "list",
                        [
                          "object",
                          {
                            "kind": "string",
                            "name": "string"
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            },
            "timeouts": [],
            "wait": [],
            "wait_for": null
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_manifest",
      "name": "vault_backend",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "computed_fields": null,
            "field_manager": [],
            "manifest": {
              "value": {
                "apiVersion": "external-secrets.io/v1beta1",
                "kind": "SecretStore",
                "metadata": {
                  "name": "vault-backend",
                  "namespace": "vault"
                },
                "spec": {
                  "provider": {
                    "vault": {
                      "auth": {
                        "kubernetes": {
                          "mountPath": "kubernetes",
                          "role": "external-secrets"
                        }
                      },
                      "path": "secret",
                      "server": "http://vault.vault.svc.cluster.local:8200",
                      "version": "v2"
                    }
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "name": "string",
                      "namespace": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "provider": [
                        "object",
                        {
                          "vault": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "kubernetes": [
                                    "object",
                                    {
                                      "mountPath": "string",
                                      "role": "string"
                                    }
                                  ]
                                }
                              ],
                              "path": "string",
                              "server": "string",
                              "version": "string"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "object": {
              "value": {
                "apiVersion": "external-secrets.io/v1beta1",
                "kind": "SecretStore",
                "metadata": {
                  "annotations": null,
                  "creationTimestamp": null,
                  "deletionGracePeriodSeconds": null,
                  "deletionTimestamp": null,
                  "finalizers": null,
                  "generateName": null,
                  "generation": null,
                  "labels": null,
                  "managedFields": null,
                  "name": "vault-backend",
                  "namespace": "vault",
                  "ownerReferences": null,
                  "resourceVersion": null,
                  "selfLink": null,
                  "uid": null
                },
                "spec": {
                  "conditions": null,
                  "controller": null,
                  "provider": {
                    "akeyless": {
                      "akeylessGWApiURL": null,
                      "authSecretRef": {
                        "kubernetesAuth": {
                          "accessID": null,
                          "k8sConfName": null,
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "serviceAccountRef": {
                            "audiences": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "secretRef": {
                          "accessID": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "accessType": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "accessTypeParam": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "caBundle": null,
                      "caProvider": {
                        "key": null,
                        "name": null,
                        "namespace": null,
                        "type": null
                      }
                    },
                    "alibaba": {
                      "auth": {
                        "rrsa": {
                          "oidcProviderArn": null,
                          "oidcTokenFilePath": null,
                          "roleArn": null,
                          "sessionName": null
                        },
                        "secretRef": {
                          "accessKeyIDSecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "accessKeySecretSecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "regionID": null
                    },
                    "aws": {
                      "additionalRoles": null,
                      "auth": {
                        "jwt": {
                          "serviceAccountRef": {
                            "audiences": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "secretRef": {
                          "accessKeyIDSecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "secretAccessKeySecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "sessionTokenSecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "externalID": null,
                      "region": null,
                      "role": null,
                      "service": null,
                      "sessionTags": null,
                      "transitiveTagKeys": null
                    },
                    "azurekv": {
                      "authSecretRef": {
                        "clientId": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        },
                        "clientSecret": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        }
                      },
                      "authType": null,
                      "environmentType": null,
                      "identityId": null,
                      "serviceAccountRef": {
                        "audiences": null,
                        "name": null,
                        "namespace": null
                      },
                      "tenantId": null,
                      "vaultUrl": null
                    },
                    "conjur": {
                      "auth": {
                        "apikey": {
                          "account": null,
                          "apiKeyRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "userRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "jwt": {
                          "account": null,
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "serviceAccountRef": {
                            "audiences": null,
                            "name": null,
                            "namespace": null
                          },
                          "serviceID": null
                        }
                      },
                      "caBundle": null,
                      "caProvider": {
                        "key": null,
                        "name": null,
                        "namespace": null,
                        "type": null
                      },
                      "url": null
                    },
                    "delinea": {
                      "clientId": {
                        "secretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        },
                        "value": null
                      },
                      "clientSecret": {
                        "secretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        },
                        "value": null
                      },
                      "tenant": null,
                      "tld": null,
                      "urlTemplate": null
                    },
                    "doppler": {
                      "auth": {
                        "secretRef": {
                          "dopplerToken": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "config": null,
                      "format": null,
                      "nameTransformer": null,
                      "project": null
                    },
                    "fake": {
                      "data": null
                    },
                    "gcpsm": {
                      "auth": {
                        "secretRef": {
                          "secretAccessKeySecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "workloadIdentity": {
                          "clusterLocation": null,
                          "clusterName": null,
                          "clusterProjectID": null,
                          "serviceAccountRef": {
                            "audiences": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "projectID": null
                    },
                    "gitlab": {
                      "auth": {
                        "SecretRef": {
                          "accessToken": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "environment": null,
                      "groupIDs": null,
                      "inheritFromGroups": null,
                      "projectID": null,
                      "url": null
                    },
                    "ibm": {
                      "auth": {
                        "containerAuth": {
                          "iamEndpoint": null,
                          "profile": null,
                          "tokenLocation": null
                        },
                        "secretRef": {
                          "secretApiKeySecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "serviceUrl": null
                    },
                    "keepersecurity": {
                      "authRef": {
                        "key": null,
                        "name": null,
                        "namespace": null
                      },
                      "folderID": null
                    },
                    "kubernetes": {
                      "auth": {
                        "cert": {
                          "clientCert": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "clientKey": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "serviceAccount": {
                          "audiences": null,
                          "name": null,
                          "namespace": null
                        },
                        "token": {
                          "bearerToken": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "remoteNamespace": null,
                      "server": {
                        "caBundle": null,
                        "caProvider": {
                          "key": null,
                          "name": null,
                          "namespace": null,
                          "type": null
                        },
                        "url": null
                      }
                    },
                    "onepassword": {
                      "auth": {
                        "secretRef": {
                          "connectTokenSecretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        }
                      },
                      "connectHost": null,
                      "vaults": null
                    },
                    "oracle": {
                      "auth": {
                        "secretRef": {
                          "fingerprint": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "privatekey": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "tenancy": null,
                        "user": null
                      },
                      "region": null,
                      "vault": null
                    },
                    "scaleway": {
                      "accessKey": {
                        "secretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        },
                        "value": null
                      },
                      "apiUrl": null,
                      "projectId": null,
                      "region": null,
                      "secretKey": {
                        "secretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        },
                        "value": null
                      }
                    },
                    "senhasegura": {
                      "auth": {
                        "clientId": null,
                        "clientSecretSecretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        }
                      },
                      "ignoreSslCertificate": null,
                      "module": null,
                      "url": null
                    },
                    "vault": {
                      "auth": {
                        "appRole": {
                          "path": null,
                          "roleId": null,
                          "roleRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "cert": {
                          "clientCert": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "iam": {
                          "externalID": null,
                          "jwt": {
                            "serviceAccountRef": {
                              "audiences": null,
                              "name": null,
                              "namespace": null
                            }
                          },
                          "path": null,
                          "region": null,
                          "role": null,
                          "secretRef": {
                            "accessKeyIDSecretRef": {
                              "key": null,
                              "name": null,
                              "namespace": null
                            },
                            "secretAccessKeySecretRef": {
                              "key": null,
                              "name": null,
                              "namespace": null
                            },
                            "sessionTokenSecretRef": {
                              "key": null,
                              "name": null,
                              "namespace": null
                            }
                          },
                          "vaultAwsIamServerID": null,
                          "vaultRole": null
                        },
                        "jwt": {
                          "kubernetesServiceAccountToken": {
                            "audiences": null,
                            "expirationSeconds": null,
                            "serviceAccountRef": {
                              "audiences": null,
                              "name": null,
                              "namespace": null
                            }
                          },
                          "path": null,
                          "role": null,
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "kubernetes": {
                          "mountPath": "kubernetes",
                          "role": "external-secrets",
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "serviceAccountRef": {
                            "audiences": null,
                            "name": null,
                            "namespace": null
                          }
                        },
                        "ldap": {
                          "path": null,
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "username": null
                        },
                        "tokenSecretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        },
                        "userPass": {
                          "path": null,
                          "secretRef": {
                            "key": null,
                            "name": null,
                            "namespace": null
                          },
                          "username": null
                        }
                      },
                      "caBundle": null,
                      "caProvider": {
                        "key": null,
                        "name": null,
                        "namespace": null,
                        "type": null
                      },
                      "forwardInconsistent": null,
                      "namespace": null,
                      "path": "secret",
                      "readYourWrites": null,
                      "server": "http://vault.vault.svc.cluster.local:8200",
                      "version": "v2"
                    },
                    "webhook": {
                      "body": null,
                      "caBundle": null,
                      "caProvider": {
                        "key": null,
                        "name": null,
                        "namespace": null,
                        "type": null
                      },
                      "headers": null,
                      "method": null,
                      "result": {
                        "jsonPath": null
                      },
                      "secrets": null,
                      "timeout": null,
                      "url": null
                    },
                    "yandexcertificatemanager": {
                      "apiEndpoint": null,
                      "auth": {
                        "authorizedKeySecretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        }
                      },
                      "caProvider": {
                        "certSecretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        }
                      }
                    },
                    "yandexlockbox": {
                      "apiEndpoint": null,
                      "auth": {
                        "authorizedKeySecretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        }
                      },
                      "caProvider": {
                        "certSecretRef": {
                          "key": null,
                          "name": null,
                          "namespace": null
                        }
                      }
                    }
                  },
                  "refreshInterval": null,
                  "retrySettings": {
                    "maxRetries": null,
                    "retryInterval": null
                  }
                }
              },
              "type": [
                "object",
                {
                  "apiVersion": "string",
                  "kind": "string",
                  "metadata": [
                    "object",
                    {
                      "annotations": [
                        "map",
                        "string"
                      ],
                      "creationTimestamp": "string",
                      "deletionGracePeriodSeconds": "number",
                      "deletionTimestamp": "string",
                      "finalizers": [
                        "list",
                        "string"
                      ],
                      "generateName": "string",
                      "generation": "number",
                      "labels": [
                        "map",
                        "string"
                      ],
                      "managedFields": [
                        "tuple",
                        [
                          [
                            "object",
                            {
                              "apiVersion": "string",
                              "fieldsType": "string",
                              "fieldsV1": "dynamic",
                              "manager": "string",
                              "operation": "string",
                              "subresource": "string",
                              "time": "string"
                            }
                          ]
                        ]
                      ],
                      "name": "string",
                      "namespace": "string",
                      "ownerReferences": [
                        "list",
                        [
                          "object",
                          {
                            "apiVersion": "string",
                            "blockOwnerDeletion": "bool",
                            "controller": "bool",
                            "kind": "string",
                            "name": "string",
                            "uid": "string"
                          }
                        ]
                      ],
                      "resourceVersion": "string",
                      "selfLink": "string",
                      "uid": "string"
                    }
                  ],
                  "spec": [
                    "object",
                    {
                      "conditions": [
                        "list",
                        [
                          "object",
                          {
                            "namespaceSelector": [
                              "object",
                              {
                                "matchExpressions": [
                                  "list",
                                  [
                                    "object",
                                    {
                                      "key": "string",
                                      "operator": "string",
                                      "values": [
                                        "list",
                                        "string"
                                      ]
                                    }
                                  ]
                                ],
                                "matchLabels": [
                                  "map",
                                  "string"
                                ]
                              }
                            ],
                            "namespaces": [
                              "list",
                              "string"
                            ]
                          }
                        ]
                      ],
                      "controller": "string",
                      "provider": [
                        "object",
                        {
                          "akeyless": [
                            "object",
                            {
                              "akeylessGWApiURL": "string",
                              "authSecretRef": [
                                "object",
                                {
                                  "kubernetesAuth": [
                                    "object",
                                    {
                                      "accessID": "string",
                                      "k8sConfName": "string",
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "serviceAccountRef": [
                                        "object",
                                        {
                                          "audiences": [
                                            "list",
                                            "string"
                                          ],
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "secretRef": [
                                    "object",
                                    {
                                      "accessID": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "accessType": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "accessTypeParam": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "caBundle": "string",
                              "caProvider": [
                                "object",
                                {
                                  "key": "string",
                                  "name": "string",
                                  "namespace": "string",
                                  "type": "string"
                                }
                              ]
                            }
                          ],
                          "alibaba": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "rrsa": [
                                    "object",
                                    {
                                      "oidcProviderArn": "string",
                                      "oidcTokenFilePath": "string",
                                      "roleArn": "string",
                                      "sessionName": "string"
                                    }
                                  ],
                                  "secretRef": [
                                    "object",
                                    {
                                      "accessKeyIDSecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "accessKeySecretSecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "regionID": "string"
                            }
                          ],
                          "aws": [
                            "object",
                            {
                              "additionalRoles": [
                                "list",
                                "string"
                              ],
                              "auth": [
                                "object",
                                {
                                  "jwt": [
                                    "object",
                                    {
                                      "serviceAccountRef": [
                                        "object",
                                        {
                                          "audiences": [
                                            "list",
                                            "string"
                                          ],
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "secretRef": [
                                    "object",
                                    {
                                      "accessKeyIDSecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "secretAccessKeySecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "sessionTokenSecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "externalID": "string",
                              "region": "string",
                              "role": "string",
                              "service": "string",
                              "sessionTags": [
                                "list",
                                [
                                  "object",
                                  {
                                    "key": "string",
                                    "value": "string"
                                  }
                                ]
                              ],
                              "transitiveTagKeys": [
                                "list",
                                "string"
                              ]
                            }
                          ],
                          "azurekv": [
                            "object",
                            {
                              "authSecretRef": [
                                "object",
                                {
                                  "clientId": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ],
                                  "clientSecret": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ]
                                }
                              ],
                              "authType": "string",
                              "environmentType": "string",
                              "identityId": "string",
                              "serviceAccountRef": [
                                "object",
                                {
                                  "audiences": [
                                    "list",
                                    "string"
                                  ],
                                  "name": "string",
                                  "namespace": "string"
                                }
                              ],
                              "tenantId": "string",
                              "vaultUrl": "string"
                            }
                          ],
                          "conjur": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "apikey": [
                                    "object",
                                    {
                                      "account": "string",
                                      "apiKeyRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "userRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "jwt": [
                                    "object",
                                    {
                                      "account": "string",
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "serviceAccountRef": [
                                        "object",
                                        {
                                          "audiences": [
                                            "list",
                                            "string"
                                          ],
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "serviceID": "string"
                                    }
                                  ]
                                }
                              ],
                              "caBundle": "string",
                              "caProvider": [
                                "object",
                                {
                                  "key": "string",
                                  "name": "string",
                                  "namespace": "string",
                                  "type": "string"
                                }
                              ],
                              "url": "string"
                            }
                          ],
                          "delinea": [
                            "object",
                            {
                              "clientId": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ],
                                  "value": "string"
                                }
                              ],
                              "clientSecret": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ],
                                  "value": "string"
                                }
                              ],
                              "tenant": "string",
                              "tld": "string",
                              "urlTemplate": "string"
                            }
                          ],
                          "doppler": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "dopplerToken": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "config": "string",
                              "format": "string",
                              "nameTransformer": "string",
                              "project": "string"
                            }
                          ],
                          "fake": [
                            "object",
                            {
                              "data": [
                                "list",
                                [
                                  "object",
                                  {
                                    "key": "string",
                                    "value": "string",
                                    "valueMap": [
                                      "map",
                                      "string"
                                    ],
                                    "version": "string"
                                  }
                                ]
                              ]
                            }
                          ],
                          "gcpsm": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "secretAccessKeySecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "workloadIdentity": [
                                    "object",
                                    {
                                      "clusterLocation": "string",
                                      "clusterName": "string",
                                      "clusterProjectID": "string",
                                      "serviceAccountRef": [
                                        "object",
                                        {
                                          "audiences": [
                                            "list",
                                            "string"
                                          ],
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "projectID": "string"
                            }
                          ],
                          "gitlab": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "SecretRef": [
                                    "object",
                                    {
                                      "accessToken": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "environment": "string",
                              "groupIDs": [
                                "list",
                                "string"
                              ],
                              "inheritFromGroups": "bool",
                              "projectID": "string",
                              "url": "string"
                            }
                          ],
                          "ibm": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "containerAuth": [
                                    "object",
                                    {
                                      "iamEndpoint": "string",
                                      "profile": "string",
                                      "tokenLocation": "string"
                                    }
                                  ],
                                  "secretRef": [
                                    "object",
                                    {
                                      "secretApiKeySecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "serviceUrl": "string"
                            }
                          ],
                          "keepersecurity": [
                            "object",
                            {
                              "authRef": [
                                "object",
                                {
                                  "key": "string",
                                  "name": "string",
                                  "namespace": "string"
                                }
                              ],
                              "folderID": "string"
                            }
                          ],
                          "kubernetes": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "cert": [
                                    "object",
                                    {
                                      "clientCert": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "clientKey": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "serviceAccount": [
                                    "object",
                                    {
                                      "audiences": [
                                        "list",
                                        "string"
                                      ],
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ],
                                  "token": [
                                    "object",
                                    {
                                      "bearerToken": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "remoteNamespace": "string",
                              "server": [
                                "object",
                                {
                                  "caBundle": "string",
                                  "caProvider": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string",
                                      "type": "string"
                                    }
                                  ],
                                  "url": "string"
                                }
                              ]
                            }
                          ],
                          "onepassword": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "connectTokenSecretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ],
                              "connectHost": "string",
                              "vaults": [
                                "map",
                                "number"
                              ]
                            }
                          ],
                          "oracle": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "fingerprint": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "privatekey": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "tenancy": "string",
                                  "user": "string"
                                }
                              ],
                              "region": "string",
                              "vault": "string"
                            }
                          ],
                          "scaleway": [
                            "object",
                            {
                              "accessKey": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ],
                                  "value": "string"
                                }
                              ],
                              "apiUrl": "string",
                              "projectId": "string",
                              "region": "string",
                              "secretKey": [
                                "object",
                                {
                                  "secretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ],
                                  "value": "string"
                                }
                              ]
                            }
                          ],
                          "senhasegura": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "clientId": "string",
                                  "clientSecretSecretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ]
                                }
                              ],
                              "ignoreSslCertificate": "bool",
                              "module": "string",
                              "url": "string"
                            }
                          ],
                          "vault": [
                            "object",
                            {
                              "auth": [
                                "object",
                                {
                                  "appRole": [
                                    "object",
                                    {
                                      "path": "string",
                                      "roleId": "string",
                                      "roleRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "cert": [
                                    "object",
                                    {
                                      "clientCert": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "iam": [
                                    "object",
                                    {
                                      "externalID": "string",
                                      "jwt": [
                                        "object",
                                        {
                                          "serviceAccountRef": [
                                            "object",
                                            {
                                              "audiences": [
                                                "list",
                                                "string"
                                              ],
                                              "name": "string",
                                              "namespace": "string"
                                            }
                                          ]
                                        }
                                      ],
                                      "path": "string",
                                      "region": "string",
                                      "role": "string",
                                      "secretRef": [
                                        "object",
                                        {
                                          "accessKeyIDSecretRef": [
                                            "object",
                                            {
                                              "key": "string",
                                              "name": "string",
                                              "namespace": "string"
                                            }
                                          ],
                                          "secretAccessKeySecretRef": [
                                            "object",
                                            {
                                              "key": "string",
                                              "name": "string",
                                              "namespace": "string"
                                            }
                                          ],
                                          "sessionTokenSecretRef": [
                                            "object",
                                            {
                                              "key": "string",
                                              "name": "string",
                                              "namespace": "string"
                                            }
                                          ]
                                        }
                                      ],
                                      "vaultAwsIamServerID": "string",
                                      "vaultRole": "string"
                                    }
                                  ],
                                  "jwt": [
                                    "object",
                                    {
                                      "kubernetesServiceAccountToken": [
                                        "object",
                                        {
                                          "audiences": [
                                            "list",
                                            "string"
                                          ],
                                          "expirationSeconds": "number",
                                          "serviceAccountRef": [
                                            "object",
                                            {
                                              "audiences": [
                                                "list",
                                                "string"
                                              ],
                                              "name": "string",
                                              "namespace": "string"
                                            }
                                          ]
                                        }
                                      ],
                                      "path": "string",
                                      "role": "string",
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "kubernetes": [
                                    "object",
                                    {
                                      "mountPath": "string",
                                      "role": "string",
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "serviceAccountRef": [
                                        "object",
                                        {
                                          "audiences": [
                                            "list",
                                            "string"
                                          ],
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ]
                                    }
                                  ],
                                  "ldap": [
                                    "object",
                                    {
                                      "path": "string",
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "username": "string"
                                    }
                                  ],
                                  "tokenSecretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ],
                                  "userPass": [
                                    "object",
                                    {
                                      "path": "string",
                                      "secretRef": [
                                        "object",
                                        {
                                          "key": "string",
                                          "name": "string",
                                          "namespace": "string"
                                        }
                                      ],
                                      "username": "string"
                                    }
                                  ]
                                }
                              ],
                              "caBundle": "string",
                              "caProvider": [
                                "object",
                                {
                                  "key": "string",
                                  "name": "string",
                                  "namespace": "string",
                                  "type": "string"
                                }
                              ],
                              "forwardInconsistent": "bool",
                              "namespace": "string",
                              "path": "string",
                              "readYourWrites": "bool",
                              "server": "string",
                              "version": "string"
                            }
                          ],
                          "webhook": [
                            "object",
                            {
                              "body": "string",
                              "caBundle": "string",
                              "caProvider": [
                                "object",
                                {
                                  "key": "string",
                                  "name": "string",
                                  "namespace": "string",
                                  "type": "string"
                                }
                              ],
                              "headers": [
                                "map",
                                "string"
                              ],
                              "method": "string",
                              "result": [
                                "object",
                                {
                                  "jsonPath": "string"
                                }
                              ],
                              "secrets": [
                                "list",
                                [
                                  "object",
                                  {
                                    "name": "string",
                                    "secretRef": [
                                      "object",
                                      {
                                        "key": "string",
                                        "name": "string",
                                        "namespace": "string"
                                      }
                                    ]
                                  }
                                ]
                              ],
                              "timeout": "string",
                              "url": "string"
                            }
                          ],
                          "yandexcertificatemanager": [
                            "object",
                            {
                              "apiEndpoint": "string",
                              "auth": [
                                "object",
                                {
                                  "authorizedKeySecretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ]
                                }
                              ],
                              "caProvider": [
                                "object",
                                {
                                  "certSecretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ]
                                }
                              ]
                            }
                          ],
                          "yandexlockbox": [
                            "object",
                            {
                              "apiEndpoint": "string",
                              "auth": [
                                "object",
                                {
                                  "authorizedKeySecretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ]
                                }
                              ],
                              "caProvider": [
                                "object",
                                {
                                  "certSecretRef": [
                                    "object",
                                    {
                                      "key": "string",
                                      "name": "string",
                                      "namespace": "string"
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        }
                      ],
                      "refreshInterval": "number",
                      "retrySettings": [
                        "object",
                        {
                          "maxRetries": "number",
                          "retryInterval": "string"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            "timeouts": [],
            "wait": [],
            "wait_for": null
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "monitoring",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "monitoring",
            "metadata": [
              {
                "annotations": {
                  "iam.amazonaws.com/permitted": ".*",
                  "name": "monitoring"
                },
                "generate_name": "",
                "generation": 0,
                "labels": {
                  "networking/namespace": "monitoring"
                },
                "name": "monitoring",
                "resource_version": "1909",
                "uid": "dcd0f7fa-eefc-4fd1-a157-a7ac7d4da1d2"
              }
            ],
            "timeouts": null,
            "wait_for_default_service_account": false
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ==",
          "dependencies": [
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "tailscale",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "tailscale",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "tailscale",
                "resource_version": "1910",
                "uid": "6a9b64fd-012c-4d14-ac35-96b9c489ec73"
              }
            ],
            "timeouts": null,
            "wait_for_default_service_account": false
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ==",
          "dependencies": [
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_namespace",
      "name": "vault",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "vault",
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "vault",
                "resource_version": "1908",
                "uid": "0d774ad6-7881-42ad-9ec3-dabd444cbb01"
              }
            ],
            "timeouts": null,
            "wait_for_default_service_account": false
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiZGVsZXRlIjozMDAwMDAwMDAwMDB9fQ==",
          "dependencies": [
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_secret",
      "name": "vault_auth",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "binary_data": null,
            "data": {
              "clientID": "Z1LsgVC56rmG3AfBH7HefjLxG6yUCY35",
              "clientSecret": "CSeesCavd3DkRrOROJd6Be1gpwmAz1n_jh6M5RuxoC9zsLLvu7gAEDC52COF_scd"
            },
            "id": "vault/default",
            "immutable": false,
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "default",
                "namespace": "vault",
                "resource_version": "1921",
                "uid": "bc3208e2-fefb-468a-9a33-c5ea3309beca"
              }
            ],
            "timeouts": null,
            "type": "Opaque",
            "wait_for_service_account_token": true
          },
          "sensitive_attributes": [
            [
              {
                "type": "get_attr",
                "value": "data"
              },
              {
                "type": "index",
                "value": {
                  "value": "clientID",
                  "type": "string"
                }
              }
            ],
            [
              {
                "type": "get_attr",
                "value": "data"
              },
              {
                "type": "index",
                "value": {
                  "value": "clientSecret",
                  "type": "string"
                }
              }
            ]
          ],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMH19"
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_secret",
      "name": "vault_tailscale_auth",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "binary_data": null,
            "data": {
              "clientID": "Z1LsgVC56rmG3AfBH7HefjLxG6yUCY35",
              "clientSecret": "CSeesCavd3DkRrOROJd6Be1gpwmAz1n_jh6M5RuxoC9zsLLvu7gAEDC52COF_scd"
            },
            "id": "tailscale/vault-tailscale-auth",
            "immutable": false,
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "vault-tailscale-auth",
                "namespace": "tailscale",
                "resource_version": "1920",
                "uid": "e99cb106-f9ee-48b6-ac2f-7c638b4ccadd"
              }
            ],
            "timeouts": null,
            "type": "Opaque",
            "wait_for_service_account_token": true
          },
          "sensitive_attributes": [
            [
              {
                "type": "get_attr",
                "value": "data"
              },
              {
                "type": "index",
                "value": {
                  "value": "clientID",
                  "type": "string"
                }
              }
            ],
            [
              {
                "type": "get_attr",
                "value": "data"
              },
              {
                "type": "index",
                "value": {
                  "value": "clientSecret",
                  "type": "string"
                }
              }
            ]
          ],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjo2MDAwMDAwMDAwMH19"
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "kubernetes_service_account_v1",
      "name": "internal_app_sa",
      "provider": "provider[\"registry.terraform.io/hashicorp/kubernetes\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "automount_service_account_token": true,
            "default_secret_name": "",
            "id": "vault/internal-app",
            "image_pull_secret": [],
            "metadata": [
              {
                "annotations": {},
                "generate_name": "",
                "generation": 0,
                "labels": {},
                "name": "internal-app",
                "namespace": "vault",
                "resource_version": "1918",
                "uid": "b183be26-f03a-4041-9ee4-efa01c2d573f"
              }
            ],
            "secret": [],
            "timeouts": null
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjozMDAwMDAwMDAwMH19"
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "null_resource",
      "name": "prometheus_operator_crd_install",
      "provider": "provider[\"registry.terraform.io/hashicorp/null\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "653386072054878513",
            "triggers": {
              "kubeconfig_filename": "/home/stollenaar/.kube/config"
            }
          },
          "sensitive_attributes": [],
          "dependencies": [
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    },
    {
      "module": "module.vault",
      "mode": "managed",
      "type": "null_resource",
      "name": "tailscale",
      "provider": "provider[\"registry.terraform.io/hashicorp/null\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "id": "4977378352797724109",
            "triggers": null
          },
          "sensitive_attributes": [],
          "dependencies": [
            "helm_release.openebs_jiva",
            "kubernetes_namespace.openebs"
          ]
        }
      ]
    }
  ],
  "check_results": null
}
